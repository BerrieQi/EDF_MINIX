diff -crN usr_orig/include/minix/callnr.h EDF/include/minix/callnr.h
*** usr_orig/include/minix/callnr.h	2016-12-01 21:58:20.805284000 +0800
--- EDF/include/minix/callnr.h	2016-12-08 00:17:19.755910739 +0800
***************
*** 1,115 ****
! #define NCALLS		 114	/* number of system calls allowed */
! 
! /* In case it isn't obvious enough: this list is sorted numerically. */
! #define EXIT		   1 
! #define FORK		   2 
! #define READ		   3 
! #define WRITE		   4 
! #define OPEN		   5 
! #define CLOSE		   6 
! #define WAIT		   7
! #define CREAT		   8 
! #define LINK		   9 
! #define UNLINK		  10 
! #define WAITPID		  11
! #define CHDIR		  12 
! #define TIME		  13
! #define MKNOD		  14 
! #define CHMOD		  15 
! #define CHOWN		  16 
! #define BRK		  17
! #define PREV_STAT	  18
! #define LSEEK		  19
! #define MINIX_GETPID	  20
! #define MOUNT		  21 
! #define UMOUNT		  22 
! #define SETUID		  23
! #define GETUID		  24
! #define STIME		  25
! #define PTRACE		  26
! #define ALARM		  27
! #define PREV_FSTAT	  28
! #define PAUSE		  29
! #define UTIME		  30 
! #define GETEPINFO	  31
! #define SETGROUPS	  32
! #define ACCESS		  33 
! #define GETGROUPS	  34
! #define SYNC		  36 
! #define KILL		  37
! #define RENAME		  38
! #define MKDIR		  39
! #define RMDIR		  40
! #define DUP		  41 
! #define PIPE		  42 
! #define TIMES		  43
! #define SYMLINK		  45
! #define SETGID		  46
! #define GETGID		  47
! #define SIGNAL		  48
! #define RDLNK		  49
! #define PREV_LSTAT	  50
! #define STAT		  51
! #define FSTAT		  52
! #define LSTAT		  53
! #define IOCTL		  54
! #define FCNTL		  55
! #define FS_READY	  57
! #define EXEC		  59
! #define UMASK		  60 
! #define CHROOT		  61 
! #define SETSID		  62
! #define GETPGRP		  63
! #define ITIMER		  64
! #define GETGROUPS_O	  65
! #define SETGROUPS_O	  66
! #define GETMCONTEXT       67
! #define SETMCONTEXT       68
! 
! /* Posix signal handling. */
! #define SIGACTION	  71
! #define SIGSUSPEND	  72
! #define SIGPENDING	  73
! #define SIGPROCMASK	  74
! #define SIGRETURN	  75
! 
! #define REBOOT		  76
! #define SVRCTL		  77
! #define SYSUNAME	  78
! #define GETDENTS	  80	/* to VFS */
! #define LLSEEK		  81	/* to VFS */
! #define FSTATFS	 	  82	/* to VFS */
! #define STATVFS 	  83	/* to VFS */
! #define FSTATVFS 	  84	/* to VFS */
! #define SELECT            85	/* to VFS */
! #define FCHDIR            86	/* to VFS */
! #define FSYNC             87	/* to VFS */
! #define GETPRIORITY       88	/* to PM */
! #define SETPRIORITY       89	/* to PM */
! #define GETTIMEOFDAY      90	/* to PM */
! #define SETEUID		  91	/* to PM */
! #define SETEGID		  92	/* to PM */
! #define TRUNCATE	  93	/* to VFS */
! #define FTRUNCATE	  94	/* to VFS */
! #define FCHMOD		  95	/* to VFS */
! #define FCHOWN		  96	/* to VFS */
! #define SPROF             98    /* to PM */
! #define CPROF             99    /* to PM */
! 
! /* Calls provided by PM and FS that are not part of the API */
! #define PM_NEWEXEC	100	/* from VFS or RS to PM: new exec */
! #define SRV_FORK  	101	/* to PM: special fork call for RS */
! #define EXEC_RESTART	102	/* to PM: final part of exec for RS */
! #define GETPROCNR	104	/* to PM */
! #define ISSETUGID	106	/* to PM: ask if process is tainted */
! #define GETEPINFO_O	107	/* to PM: get pid/uid/gid of an endpoint */
! #define SRV_KILL  	111	/* to PM: special kill call for RS */
! 
! #define GCOV_FLUSH	112	/* flush gcov data from server to gcov files */
! 
! #define PM_GETSID	113	/* PM getsid() */
! 
! #define TASK_REPLY	121	/* to VFS: reply code from drivers, not 
! 				 * really a standalone call.
! 				 */
! #define MAPDRIVER      122     /* to VFS, map a device */
--- 1,116 ----
! #define NCALLS		 114	/* number of system calls allowed */
! 
! /* In case it isn't obvious enough: this list is sorted numerically. */
! #define EXIT		   1 
! #define FORK		   2 
! #define READ		   3 
! #define WRITE		   4 
! #define OPEN		   5 
! #define CLOSE		   6 
! #define WAIT		   7
! #define CREAT		   8 
! #define LINK		   9 
! #define UNLINK		  10 
! #define WAITPID		  11
! #define CHDIR		  12 
! #define TIME		  13
! #define MKNOD		  14 
! #define CHMOD		  15 
! #define CHOWN		  16 
! #define BRK		  17
! #define PREV_STAT	  18
! #define LSEEK		  19
! #define MINIX_GETPID	  20
! #define MOUNT		  21 
! #define UMOUNT		  22 
! #define SETUID		  23
! #define GETUID		  24
! #define STIME		  25
! #define PTRACE		  26
! #define ALARM		  27
! #define PREV_FSTAT	  28
! #define PAUSE		  29
! #define UTIME		  30 
! #define GETEPINFO	  31
! #define SETGROUPS	  32
! #define ACCESS		  33 
! #define GETGROUPS	  34
! #define SYNC		  36 
! #define KILL		  37
! #define RENAME		  38
! #define MKDIR		  39
! #define RMDIR		  40
! #define DUP		  41 
! #define PIPE		  42 
! #define TIMES		  43
! #define SYMLINK		  45
! #define SETGID		  46
! #define GETGID		  47
! #define SIGNAL		  48
! #define RDLNK		  49
! #define PREV_LSTAT	  50
! #define STAT		  51
! #define FSTAT		  52
! #define LSTAT		  53
! #define IOCTL		  54
! #define FCNTL		  55
! #define FS_READY	  57
! #define EXEC		  59
! #define UMASK		  60 
! #define CHROOT		  61 
! #define SETSID		  62
! #define GETPGRP		  63
! #define ITIMER		  64
! #define GETGROUPS_O	  65
! #define SETGROUPS_O	  66
! #define GETMCONTEXT       67
! #define SETMCONTEXT       68
! 
! /* Posix signal handling. */
! #define SIGACTION	  71
! #define SIGSUSPEND	  72
! #define SIGPENDING	  73
! #define SIGPROCMASK	  74
! #define SIGRETURN	  75
! 
! #define REBOOT		  76
! #define SVRCTL		  77
! #define SYSUNAME	  78
! #define GETDENTS	  80	/* to VFS */
! #define LLSEEK		  81	/* to VFS */
! #define FSTATFS	 	  82	/* to VFS */
! #define STATVFS 	  83	/* to VFS */
! #define FSTATVFS 	  84	/* to VFS */
! #define SELECT            85	/* to VFS */
! #define FCHDIR            86	/* to VFS */
! #define FSYNC             87	/* to VFS */
! #define GETPRIORITY       88	/* to PM */
! #define SETPRIORITY       89	/* to PM */
! #define GETTIMEOFDAY      90	/* to PM */
! #define SETEUID		  91	/* to PM */
! #define SETEGID		  92	/* to PM */
! #define TRUNCATE	  93	/* to VFS */
! #define FTRUNCATE	  94	/* to VFS */
! #define FCHMOD		  95	/* to VFS */
! #define FCHOWN		  96	/* to VFS */
! #define SPROF             98    /* to PM */
! #define CPROF             99    /* to PM */
! #define CHREALTIME              69    /* to PM */
! 
! /* Calls provided by PM and FS that are not part of the API */
! #define PM_NEWEXEC	100	/* from VFS or RS to PM: new exec */
! #define SRV_FORK  	101	/* to PM: special fork call for RS */
! #define EXEC_RESTART	102	/* to PM: final part of exec for RS */
! #define GETPROCNR	104	/* to PM */
! #define ISSETUGID	106	/* to PM: ask if process is tainted */
! #define GETEPINFO_O	107	/* to PM: get pid/uid/gid of an endpoint */
! #define SRV_KILL  	111	/* to PM: special kill call for RS */
! 
! #define GCOV_FLUSH	112	/* flush gcov data from server to gcov files */
! 
! #define PM_GETSID	113	/* PM getsid() */
! 
! #define TASK_REPLY	121	/* to VFS: reply code from drivers, not 
! 				 * really a standalone call.
! 				 */
! #define MAPDRIVER      122     /* to VFS, map a device */
diff -crN usr_orig/src/commands/service/parse.c EDF/src/commands/service/parse.c
*** usr_orig/src/commands/service/parse.c	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/commands/service/parse.c	2016-12-08 00:17:19.627910742 +0800
***************
*** 1,1152 ****
! 
! #include <stdarg.h>
! #include <assert.h>
! #include <stdlib.h>
! #include <stdio.h>
! #include <string.h>
! #include <errno.h>
! #include <pwd.h>
! #include <err.h>
! #include <unistd.h>
! #include <limits.h>
! #include <lib.h>
! #include <minix/config.h>
! #include <minix/com.h>
! #include <minix/const.h>
! #include <minix/type.h>
! #include <minix/ipc.h>
! #include <minix/rs.h>
! #include <minix/syslib.h>
! #include <minix/bitmap.h>
! #include <paths.h>
! #include <minix/sef.h>
! #include <minix/dmap.h>
! #include <sys/types.h>
! #include <sys/stat.h>
! #include <configfile.h>
! 
! #include <machine/archtypes.h>
! #include <timers.h>
! #include "kernel/proc.h"
! 
! #include "config.h"
! #include "proto.h"
! 
! static int class_recurs;       /* Nesting level of class statements */
! #define MAX_CLASS_RECURS        100     /* Max nesting level for classes */
! 
! #include "parse.h"
! 
! static void do_service(config_t *cpe, config_t *config, struct rs_config *);
! 
! static void do_class(config_t *cpe, config_t *config, struct rs_config *rs_config)
! {
! 	config_t *cp, *cp1;
! 
! 	if (class_recurs > MAX_CLASS_RECURS)
! 	{
! 		fatal(
! 		"do_class: nesting level too high for class '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 	class_recurs++;
! 
! 	/* Process classes */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_class: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_uid: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* Find entry for the class */
! 		for (cp= config; cp; cp= cp->next)
! 		{
! 			if (!(cp->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected list at %s:%d",
! 					cp->file, cp->line);
! 			}
! 			cp1= cp->list;
! 			if ((cp1->flags & CFG_STRING) ||
! 				(cp1->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected word at %s:%d",
! 					cp1->file, cp1->line);
! 			}
! 
! 			/* At this place we expect the word KW_SERVICE */
! 			if (strcmp(cp1->word, KW_SERVICE) != 0)
! 				fatal("do_class: exected word '%S' at %s:%d",
! 					KW_SERVICE, cp1->file, cp1->line);
! 
! 			cp1= cp1->next;
! 			if ((cp1->flags & CFG_STRING) ||
! 				(cp1->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected word at %s:%d",
! 					cp1->file, cp1->line);
! 			}
! 
! 			/* At this place we expect the name of the service */
! 			if (strcmp(cp1->word, cpe->word) == 0)
! 				break;
! 		}
! 		if (cp == NULL)
! 		{
! 			fatal(
! 			"do_class: no entry found for class '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		do_service(cp1->next, config, rs_config);
! 	}
! 
! 	class_recurs--;
! }
! 
! static void do_uid(config_t *cpe, struct rs_start *rs_start)
! {
! 	uid_t uid;
! 	struct passwd *pw;
! 	char *check;
! 
! 	/* Process a uid */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_uid: just one uid/login expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_uid: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_uid: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	pw= getpwnam(cpe->word);
! 	if (pw != NULL)
! 		uid= pw->pw_uid;
! 	else
! 	{
! 		if (!strncmp(cpe->word, KW_SELF, strlen(KW_SELF)+1))
! 		{
! 			uid= getuid();	/* Real uid */
! 		}
! 		else {
! 			uid= strtol(cpe->word, &check, 0);
! 			if (check[0] != '\0')
! 			{
! 				fatal("do_uid: bad uid/login '%s' at %s:%d",
! 					cpe->word, cpe->file, cpe->line);
! 			}
! 		}
! 	}
! 
! 	rs_start->rss_uid= uid;
! }
! 
! static void do_sigmgr(config_t *cpe, struct rs_start *rs_start)
! {
! 	endpoint_t sigmgr_ep;
! 	int r;
! 
! 	/* Process a signal manager value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_sigmgr: just one sigmgr value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_sigmgr: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_sigmgr: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(!strcmp(cpe->word, "SELF")) {
! 		sigmgr_ep = SELF;
! 	}
! 	else {
! 		if((r = minix_rs_lookup(cpe->word, &sigmgr_ep))) {
! 			fatal("do_sigmgr: unknown sigmgr %s at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 		}
! 	}
! 
! 	rs_start->rss_sigmgr= sigmgr_ep;
! }
! 
! static void do_type(config_t *cpe, struct rs_config *rs_config)
! {
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_type: just one type value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_type: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if ((cpe->flags & CFG_STRING))
! 	{
! 		fatal("do_type: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(rs_config->type)
! 		fatal("do_type: another type at %s:%d",
! 			cpe->file, cpe->line);
! 
! 	if(!strcmp(cpe->word, KW_NET))
! 		rs_config->type = KW_NET;
! 	else
! 		fatal("do_type: odd type at %s:%d",
! 			cpe->file, cpe->line);
! }
! 
! static void do_descr(config_t *cpe, struct rs_config *rs_config)
! {
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_descr: just one description expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_descr: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (!(cpe->flags & CFG_STRING))
! 	{
! 		fatal("do_descr: expected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(rs_config->descr)
! 		fatal("do_descr: another descr at %s:%d",
! 			cpe->file, cpe->line);
! 	rs_config->descr = cpe->word;
! }
! 
! static void do_scheduler(config_t *cpe, struct rs_start *rs_start)
! {
! 	endpoint_t scheduler_ep;
! 	int r;
! 
! 	/* Process a scheduler value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_scheduler: just one scheduler value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_scheduler: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_scheduler: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(!strcmp(cpe->word, "KERNEL")) {
! 		scheduler_ep = KERNEL;
! 	}
! 	else {
! 		if((r = minix_rs_lookup(cpe->word, &scheduler_ep))) {
! 			fatal("do_scheduler: unknown scheduler %s at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 		}
! 	}
! 
! 	rs_start->rss_scheduler= scheduler_ep;
! }
! 
! static void do_priority(config_t *cpe, struct rs_start *rs_start)
! {
! 	int priority_val;
! 	char *check;
! 
! 	/* Process a priority value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_priority: just one priority value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_priority: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_priority: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	priority_val= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_priority: bad priority value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (priority_val < 0 || priority_val >= NR_SCHED_QUEUES)
! 	{
! 		fatal("do_priority: priority %d out of range at %s:%d",
! 			priority_val, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_priority= priority_val;
! }
! 
! static void do_quantum(config_t *cpe, struct rs_start *rs_start)
! {
! 	int quantum_val;
! 	char *check;
! 
! 	/* Process a quantum value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_quantum: just one quantum value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_quantum: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_quantum: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	quantum_val= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_quantum: bad quantum value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (quantum_val <= 0)
! 	{
! 		fatal("do_quantum: quantum %d out of range at %s:%d",
! 			quantum_val, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_quantum= quantum_val;
! }
! 
! static void do_cpu(config_t *cpe, struct rs_start *rs_start)
! {
! 	int cpu;
! 	char *check;
! 
! 	/* Process a quantum value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_cpu: just one value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_cpu: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_cpu: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	cpu= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_cpu: bad value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (cpu < 0)
! 	{
! 		fatal("do_cpu: %d out of range at %s:%d",
! 			cpu, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_cpu= cpu;
! }
! 
! static void do_irq(config_t *cpe, struct rs_start *rs_start)
! {
! 	int irq;
! 	int first;
! 	char *check;
! 
! 	/* Process a list of IRQs */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_irq: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_irq: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* No IRQ allowed? (default) */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_irq: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* All IRQs are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_irq: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			rs_start->rss_nr_irq = RSS_IO_ALL;
! 			break;
! 		}
! 
! 		/* Set single IRQs as specified in the configuration. */
! 		irq= strtoul(cpe->word, &check, 0);
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_irq: bad irq '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		if (rs_start->rss_nr_irq >= RSS_NR_IRQ)
! 			fatal("do_irq: too many IRQs (max %d)", RSS_NR_IRQ);
! 		rs_start->rss_irq[rs_start->rss_nr_irq]= irq;
! 		rs_start->rss_nr_irq++;
! 		first = FALSE;
! 	}
! }
! 
! static void do_io(config_t *cpe, struct rs_start *rs_start)
! {
! 	unsigned base, len;
! 	int first;
! 	char *check;
! 
! 	/* Process a list of I/O ranges */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_io: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_io: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* No range allowed? (default) */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_io: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* All ranges are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_io: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			rs_start->rss_nr_io = RSS_IO_ALL;
! 			break;
! 		}
! 
! 		/* Set single ranges as specified in the configuration. */
! 		base= strtoul(cpe->word, &check, 0x10);
! 		len= 1;
! 		if (check[0] == ':')
! 		{
! 			len= strtoul(check+1, &check, 0x10);
! 		}
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_io: bad I/O range '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 
! 		if (rs_start->rss_nr_io >= RSS_NR_IO)
! 			fatal("do_io: too many I/O ranges (max %d)", RSS_NR_IO);
! 		rs_start->rss_io[rs_start->rss_nr_io].base= base;
! 		rs_start->rss_io[rs_start->rss_nr_io].len= len;
! 		rs_start->rss_nr_io++;
! 		first = FALSE;
! 	}
! }
! 
! static void do_pci_device(config_t *cpe, struct rs_start *rs_start)
! {
! 	u16_t vid, did;
! 	char *check, *check2;
! 
! 	/* Process a list of PCI device IDs */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_pci_device: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_pci_device: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		vid= strtoul(cpe->word, &check, 0x10);
! 		if (check[0] == '/')
! 			did= strtoul(check+1, &check2, 0x10);
! 		if (check[0] != '/' || check2[0] != '\0')
! 		{
! 			fatal("do_pci_device: bad ID '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		if (rs_start->rss_nr_pci_id >= RS_NR_PCI_DEVICE)
! 		{
! 			fatal("do_pci_device: too many device IDs (max %d)",
! 				RS_NR_PCI_DEVICE);
! 		}
! 		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].vid= vid;
! 		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].did= did;
! 		rs_start->rss_nr_pci_id++;
! 	}
! }
! 
! static void do_pci_class(config_t *cpe, struct rs_start *rs_start)
! {
! 	u8_t baseclass, subclass, interface;
! 	u32_t class_id, mask;
! 	char *check;
! 
! 	/* Process a list of PCI device class IDs */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_pci_device: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_pci_device: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		baseclass= strtoul(cpe->word, &check, 0x10);
! 		subclass= 0;
! 		interface= 0;
! 		mask= 0xff0000;
! 		if (check[0] == '/')
! 		{
! 			subclass= strtoul(check+1, &check, 0x10);
! 			mask= 0xffff00;
! 			if (check[0] == '/')
! 			{
! 				interface= strtoul(check+1, &check, 0x10);
! 				mask= 0xffffff;
! 			}
! 		}
! 
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_pci_class: bad class ID '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		class_id= (baseclass << 16) | (subclass << 8) | interface;
! 		if (rs_start->rss_nr_pci_class >= RS_NR_PCI_CLASS)
! 		{
! 			fatal("do_pci_class: too many class IDs (max %d)",
! 				RS_NR_PCI_CLASS);
! 		}
! 		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].pciclass=
! 			class_id;
! 		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].mask= mask;
! 		rs_start->rss_nr_pci_class++;
! 	}
! }
! 
! static void do_pci(config_t *cpe, struct rs_start *rs_start)
! {
! 	if (cpe == NULL)
! 		return;	/* Empty PCI statement */
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_pci: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_pci: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if (strcmp(cpe->word, KW_DEVICE) == 0)
! 	{
! 		do_pci_device(cpe->next, rs_start);
! 		return;
! 	}
! 	if (strcmp(cpe->word, KW_CLASS) == 0)
! 	{
! 		do_pci_class(cpe->next, rs_start);
! 		return;
! 	}
! 	fatal("do_pci: unexpected word '%s' at %s:%d",
! 		cpe->word, cpe->file, cpe->line);
! }
! 
! static void do_ipc(config_t *cpe, struct rs_start *rs_start)
! {
! 	char *list;
! 	const char *word;
! 	char *word_all = RSS_IPC_ALL;
! 	char *word_all_sys = RSS_IPC_ALL_SYS;
! 	size_t listsize, wordlen;
! 	int first;
! 
! 	list= NULL;
! 	listsize= 1;
! 	list= malloc(listsize);
! 	if (list == NULL)
! 		fatal("do_ipc: unable to malloc %d bytes", listsize);
! 	list[0]= '\0';
! 
! 	/* Process a list of process names that are allowed to be
! 	 * contacted
! 	 */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_ipc: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_ipc: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		word = cpe->word;
! 
! 		/* All (system) ipc targets are allowed? */
! 		if(!strcmp(word, KW_ALL) || !strcmp(word, KW_ALL_SYS)) {
! 			if(!first || cpe->next) {
! 				fatal("do_ipc: %s keyword not allowed in list",
! 				word);
! 			}
! 			word = !strcmp(word, KW_ALL) ? word_all : word_all_sys;
! 		}
! 
! 		wordlen= strlen(word);
! 
! 		listsize += 1 + wordlen;
! 		list= realloc(list, listsize);
! 		if (list == NULL)
! 		{
! 			fatal("do_ipc: unable to realloc %d bytes",
! 				listsize);
! 		}
! 		strcat(list, " ");
! 		strcat(list, word);
! 		first = FALSE;
! 	}
! #if 0
! 	printf("do_ipc: got list '%s'\n", list);
! #endif
! 
! 	if (rs_start->rss_ipc)
! 		fatal("do_ipc: req_ipc is set");
!         rs_start->rss_ipc = list+1;
! 	rs_start->rss_ipclen= strlen(rs_start->rss_ipc);
! }
! 
! 
! struct
! {
! 	char *label;
! 	int call_nr;
! } vm_table[] =
! {
! 	{ "EXIT",		VM_EXIT },
! 	{ "FORK",		VM_FORK },
! 	{ "BRK",		VM_BRK },
! 	{ "EXEC_NEWMEM",	VM_EXEC_NEWMEM },
! 	{ "PUSH_SIG",		0 },
! 	{ "WILLEXIT",		VM_WILLEXIT },
! 	{ "ADDDMA",		VM_ADDDMA },
! 	{ "DELDMA",		VM_DELDMA },
! 	{ "GETDMA",		VM_GETDMA },
! 	{ "REMAP",		VM_REMAP },
! 	{ "REMAP_RO",		VM_REMAP_RO },
! 	{ "SHM_UNMAP",		VM_SHM_UNMAP },
! 	{ "GETPHYS",		VM_GETPHYS },
! 	{ "GETREF",		VM_GETREF },
! 	{ "RS_SET_PRIV",	VM_RS_SET_PRIV },
! 	{ "QUERY_EXIT",		VM_QUERY_EXIT },
! 	{ "WATCH_EXIT",		VM_WATCH_EXIT },
! 	{ "NOTIFY_SIG",		VM_NOTIFY_SIG },
! 	{ "INFO",		VM_INFO },
! 	{ "RS_UPDATE",		VM_RS_UPDATE },
! 	{ "RS_MEMCTL",		VM_RS_MEMCTL },
! 	{ "PROCCTL",		VM_PROCCTL },
! 	{ NULL,			0 },
! };
! 
! static void do_vm(config_t *cpe, struct rs_start *rs_start)
! {
! 	int i, first;
! 
! 	first = TRUE;
! 	for (; cpe; cpe = cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_vm: unexpected sublist at %s:%d",
! 			      cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_vm: unexpected string at %s:%d",
! 			      cpe->file, cpe->line);
! 		}
! 
! 		/* Only basic calls allowed? (default). */
! 		if(!strcmp(cpe->word, KW_BASIC)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* No calls allowed? */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			rs_start->rss_flags &= ~RSS_VM_BASIC_CALLS;
! 			break;
! 		}
! 
! 		/* All calls are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			for (i = 0; i < NR_VM_CALLS; i++)
! 				SET_BIT(rs_start->rss_vm, i);
! 			break;
! 		}
! 
! 		/* Set single calls as specified in the configuration. */
! 		for (i = 0; vm_table[i].label != NULL; i++)
! 			if (!strcmp(cpe->word, vm_table[i].label))
! 				break;
! 		if (vm_table[i].label == NULL) {
! 			warning("do_vm: ignoring unknown call '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		} else if(vm_table[i].call_nr) {
! 			SET_BIT(rs_start->rss_vm,
! 				vm_table[i].call_nr - VM_RQ_BASE);
! 		}
! 
! 		first = FALSE;
! 	}
! }
! 
! struct
! {
! 	char *label;
! 	int call_nr;
! } system_tab[]=
! {
! 	{ "PRIVCTL",		SYS_PRIVCTL },
! 	{ "TRACE",		SYS_TRACE },
! 	{ "KILL",		SYS_KILL },
! 	{ "UMAP",		SYS_UMAP },
! 	{ "VIRCOPY",		SYS_VIRCOPY },
! 	{ "PHYSCOPY",		SYS_PHYSCOPY },
! 	{ "UMAP_REMOTE",	SYS_UMAP_REMOTE },
! 	{ "VUMAP",		SYS_VUMAP },
! 	{ "IRQCTL",		SYS_IRQCTL },
! 	{ "INT86",		SYS_INT86 },
! 	{ "DEVIO",		SYS_DEVIO },
! 	{ "SDEVIO",		SYS_SDEVIO },
! 	{ "VDEVIO",		SYS_VDEVIO },
! 	{ "ABORT",		SYS_ABORT },
! 	{ "IOPENABLE",		SYS_IOPENABLE },
! 	{ "READBIOS",		SYS_READBIOS },
! 	{ "STIME",		SYS_STIME },
! 	{ "VMCTL",		SYS_VMCTL },
! 	{ "MEMSET",		SYS_MEMSET },
! 	{ NULL,		0 }
! };
! 
! static void do_system(config_t *cpe, struct rs_start *rs_start)
! {
! 	int i, first;
! 
! 	/* Process a list of 'system' calls that are allowed */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_system: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_system: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* Only basic calls allowed? (default). */
! 		if(!strcmp(cpe->word, KW_BASIC)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* No calls allowed? */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			rs_start->rss_flags &= ~RSS_SYS_BASIC_CALLS;
! 			break;
! 		}
! 
! 		/* All calls are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			for (i = 0; i < NR_SYS_CALLS; i++)
! 				SET_BIT(rs_start->rss_system, i);
! 			break;
! 		}
! 
! 		/* Set single calls as specified in the configuration. */
! 		for (i = 0; system_tab[i].label != NULL; i++)
! 			if (!strcmp(cpe->word, system_tab[i].label))
! 				break;
! 		if (system_tab[i].label == NULL) {
! 		   warning("do_system: ignoring unknown call '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		} else {
! 			SET_BIT(rs_start->rss_system,
! 				system_tab[i].call_nr - KERNEL_CALL);
! 		}
! 		first = FALSE;
! 	}
! }
! 
! static void do_control(config_t *cpe, struct rs_start *rs_start)
! {
! 	int nr_control = 0;
! 
! 	/* Process a list of 'control' labels. */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_control: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_control: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (nr_control >= RS_NR_CONTROL)
! 		{
! 			fatal(
! 			"do_control: RS_NR_CONTROL is too small (%d needed)",
! 				nr_control+1);
! 		}
! 
! 		rs_start->rss_control[nr_control].l_addr = (char*) cpe->word;
! 		rs_start->rss_control[nr_control].l_len = strlen(cpe->word);
! 		rs_start->rss_nr_control = ++nr_control;
! 	}
! }
! 
! static void do_service(config_t *cpe, config_t *config, struct rs_config *rs_config)
! {
! 	struct rs_start *rs_start = &rs_config->rs_start;
! 	config_t *cp;
! 
! 	/* At this point we expect one sublist that contains the varios
! 	 * resource allocations
! 	 */
! 	if (!(cpe->flags & CFG_SUBLIST))
! 	{
! 		fatal("do_service: expected list at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->next != NULL)
! 	{
! 		cpe= cpe->next;
! 		fatal("do_service: expected end of list at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	cpe= cpe->list;
! 
! 	/* Process the list */
! 	for (cp= cpe; cp; cp= cp->next)
! 	{
! 		if (!(cp->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_service: expected list at %s:%d",
! 				cp->file, cp->line);
! 		}
! 		cpe= cp->list;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_service: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		if (strcmp(cpe->word, KW_CLASS) == 0)
! 		{
! 			do_class(cpe->next, config, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_UID) == 0)
! 		{
! 			do_uid(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SIGMGR) == 0)
! 		{
! 			do_sigmgr(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_TYPE) == 0)
! 		{
! 			do_type(cpe->next, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_DESCR) == 0)
! 		{
! 			do_descr(cpe->next, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SCHEDULER) == 0)
! 		{
! 			do_scheduler(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_PRIORITY) == 0)
! 		{
! 			do_priority(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_QUANTUM) == 0)
! 		{
! 			do_quantum(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_CPU) == 0)
! 		{
! 			do_cpu(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IRQ) == 0)
! 		{
! 			do_irq(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IO) == 0)
! 		{
! 			do_io(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_PCI) == 0)
! 		{
! 			do_pci(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SYSTEM) == 0)
! 		{
! 			do_system(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IPC) == 0)
! 		{
! 			do_ipc(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_VM) == 0)
! 		{
! 			do_vm(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_CONTROL) == 0)
! 		{
! 			do_control(cpe->next, rs_start);
! 			continue;
! 		}
! 	}
! }
! 
! static const char *do_config(const char *label, char *filename, struct rs_config *rs_config)
! {
! 	config_t *config, *cp, *cpe;
! 	struct passwd *pw;
! 	struct rs_start *rs_start = &rs_config->rs_start;
! 
! 	if(!(config= config_read(filename, 0, NULL)))
! 		return NULL; /* config file read failed. */
! 
! 	/* Set clean rs_start defaults. */
! 	memset(rs_config, 0, sizeof(*rs_config));
! 	if(!(pw= getpwnam(SERVICE_LOGIN)))
! 		fatal("no passwd file entry for '%s'", SERVICE_LOGIN);
! 	rs_start->rss_uid= pw->pw_uid;
! 	rs_start->rss_sigmgr= DSRV_SM;
! 	rs_start->rss_scheduler= DSRV_SCH;
! 	rs_start->rss_priority= DSRV_Q;
! 	rs_start->rss_quantum= DSRV_QT;
! 	rs_start->rss_cpu = DSRV_CPU;
! 	rs_start->rss_flags = RSS_VM_BASIC_CALLS | RSS_SYS_BASIC_CALLS;
! 
! 	/* Find an entry for our service */
! 	for (cp= config; cp; cp= cp->next)
! 	{
! 		if (!(cp->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected list at %s:%d",
! 				cp->file, cp->line);
! 		}
! 		cpe= cp->list;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* At this place we expect the word KW_SERVICE */
! 		if (strcmp(cpe->word, KW_SERVICE) != 0)
! 			fatal("do_config: exected word '%S' at %s:%d",
! 				KW_SERVICE, cpe->file, cpe->line);
! 
! 		cpe= cpe->next;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* At this place we expect the name of the service. */
! 		if (!label || strcmp(cpe->word, label) == 0) {
! 			label = cpe->word;
! 			break;
! 		}
! 	}
! 	if (cp == NULL)
! 	{
! 		fprintf(stderr, "service: service '%s' not found in '%s'\n",
! 			label, filename);
! 		exit(1);
! 	}
! 
! 	cpe= cpe->next;
! 
! 	do_service(cpe, config, rs_config);
! 
! 	{
! 		char *default_ipc = RSS_IPC_ALL_SYS;
! 		if(!rs_start->rss_ipc) {
! 		      rs_start->rss_ipc= default_ipc;
! 		      rs_start->rss_ipclen= strlen(default_ipc);
! 		}
! 	}
! 
! 	/* config file read ok. */
! 	return label;
! }
! 
! /* returns failure */
! const char *parse_config(char *progname, int custom_config, char *req_config,
! 	struct rs_config *rs_config)
! {
!         char *specificconfig, *specific_pkg_config;
! 	const char *l;
! 
! 	/* Config file specified? */
!         if(custom_config)
!           return do_config(progname, req_config, rs_config);
! 
! 	/* No specific config file. */
!         if(asprintf(&specificconfig, "%s/%s", _PATH_SYSTEM_CONF_DIR,
!               progname) < 0) {
!               errx(1, "no memory");
!         }
! 
!         if(asprintf(&specific_pkg_config, "%s/%s", _PATH_SYSTEM_CONF_PKG_DIR,
!               progname) < 0) {
!               errx(1, "no memory");
!         }
! 
!         /* Try specific config filename first, in base system
! 	 * and package locations, * and only if it fails, the global
! 	 * system one.
!          */
! 	if((l=do_config(progname, specific_pkg_config, rs_config))) return l;
! 	if((l=do_config(progname, specificconfig, rs_config))) return l;
! 	if((l=do_config(progname, req_config, rs_config))) return l;
! 
! 	return NULL;
! }
! 
--- 1,1153 ----
! 
! #include <stdarg.h>
! #include <assert.h>
! #include <stdlib.h>
! #include <stdio.h>
! #include <string.h>
! #include <errno.h>
! #include <pwd.h>
! #include <err.h>
! #include <unistd.h>
! #include <limits.h>
! #include <lib.h>
! #include <minix/config.h>
! #include <minix/com.h>
! #include <minix/const.h>
! #include <minix/type.h>
! #include <minix/ipc.h>
! #include <minix/rs.h>
! #include <minix/syslib.h>
! #include <minix/bitmap.h>
! #include <paths.h>
! #include <minix/sef.h>
! #include <minix/dmap.h>
! #include <sys/types.h>
! #include <sys/stat.h>
! #include <configfile.h>
! 
! #include <machine/archtypes.h>
! #include <timers.h>
! #include "kernel/proc.h"
! 
! #include "config.h"
! #include "proto.h"
! 
! static int class_recurs;       /* Nesting level of class statements */
! #define MAX_CLASS_RECURS        100     /* Max nesting level for classes */
! 
! #include "parse.h"
! 
! static void do_service(config_t *cpe, config_t *config, struct rs_config *);
! 
! static void do_class(config_t *cpe, config_t *config, struct rs_config *rs_config)
! {
! 	config_t *cp, *cp1;
! 
! 	if (class_recurs > MAX_CLASS_RECURS)
! 	{
! 		fatal(
! 		"do_class: nesting level too high for class '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 	class_recurs++;
! 
! 	/* Process classes */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_class: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_uid: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* Find entry for the class */
! 		for (cp= config; cp; cp= cp->next)
! 		{
! 			if (!(cp->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected list at %s:%d",
! 					cp->file, cp->line);
! 			}
! 			cp1= cp->list;
! 			if ((cp1->flags & CFG_STRING) ||
! 				(cp1->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected word at %s:%d",
! 					cp1->file, cp1->line);
! 			}
! 
! 			/* At this place we expect the word KW_SERVICE */
! 			if (strcmp(cp1->word, KW_SERVICE) != 0)
! 				fatal("do_class: exected word '%S' at %s:%d",
! 					KW_SERVICE, cp1->file, cp1->line);
! 
! 			cp1= cp1->next;
! 			if ((cp1->flags & CFG_STRING) ||
! 				(cp1->flags & CFG_SUBLIST))
! 			{
! 				fatal("do_class: expected word at %s:%d",
! 					cp1->file, cp1->line);
! 			}
! 
! 			/* At this place we expect the name of the service */
! 			if (strcmp(cp1->word, cpe->word) == 0)
! 				break;
! 		}
! 		if (cp == NULL)
! 		{
! 			fatal(
! 			"do_class: no entry found for class '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		do_service(cp1->next, config, rs_config);
! 	}
! 
! 	class_recurs--;
! }
! 
! static void do_uid(config_t *cpe, struct rs_start *rs_start)
! {
! 	uid_t uid;
! 	struct passwd *pw;
! 	char *check;
! 
! 	/* Process a uid */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_uid: just one uid/login expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_uid: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_uid: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	pw= getpwnam(cpe->word);
! 	if (pw != NULL)
! 		uid= pw->pw_uid;
! 	else
! 	{
! 		if (!strncmp(cpe->word, KW_SELF, strlen(KW_SELF)+1))
! 		{
! 			uid= getuid();	/* Real uid */
! 		}
! 		else {
! 			uid= strtol(cpe->word, &check, 0);
! 			if (check[0] != '\0')
! 			{
! 				fatal("do_uid: bad uid/login '%s' at %s:%d",
! 					cpe->word, cpe->file, cpe->line);
! 			}
! 		}
! 	}
! 
! 	rs_start->rss_uid= uid;
! }
! 
! static void do_sigmgr(config_t *cpe, struct rs_start *rs_start)
! {
! 	endpoint_t sigmgr_ep;
! 	int r;
! 
! 	/* Process a signal manager value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_sigmgr: just one sigmgr value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_sigmgr: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_sigmgr: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(!strcmp(cpe->word, "SELF")) {
! 		sigmgr_ep = SELF;
! 	}
! 	else {
! 		if((r = minix_rs_lookup(cpe->word, &sigmgr_ep))) {
! 			fatal("do_sigmgr: unknown sigmgr %s at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 		}
! 	}
! 
! 	rs_start->rss_sigmgr= sigmgr_ep;
! }
! 
! static void do_type(config_t *cpe, struct rs_config *rs_config)
! {
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_type: just one type value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_type: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if ((cpe->flags & CFG_STRING))
! 	{
! 		fatal("do_type: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(rs_config->type)
! 		fatal("do_type: another type at %s:%d",
! 			cpe->file, cpe->line);
! 
! 	if(!strcmp(cpe->word, KW_NET))
! 		rs_config->type = KW_NET;
! 	else
! 		fatal("do_type: odd type at %s:%d",
! 			cpe->file, cpe->line);
! }
! 
! static void do_descr(config_t *cpe, struct rs_config *rs_config)
! {
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_descr: just one description expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_descr: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (!(cpe->flags & CFG_STRING))
! 	{
! 		fatal("do_descr: expected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(rs_config->descr)
! 		fatal("do_descr: another descr at %s:%d",
! 			cpe->file, cpe->line);
! 	rs_config->descr = cpe->word;
! }
! 
! static void do_scheduler(config_t *cpe, struct rs_start *rs_start)
! {
! 	endpoint_t scheduler_ep;
! 	int r;
! 
! 	/* Process a scheduler value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_scheduler: just one scheduler value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_scheduler: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_scheduler: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if(!strcmp(cpe->word, "KERNEL")) {
! 		scheduler_ep = KERNEL;
! 	}
! 	else {
! 		if((r = minix_rs_lookup(cpe->word, &scheduler_ep))) {
! 			fatal("do_scheduler: unknown scheduler %s at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 		}
! 	}
! 
! 	rs_start->rss_scheduler= scheduler_ep;
! }
! 
! static void do_priority(config_t *cpe, struct rs_start *rs_start)
! {
! 	int priority_val;
! 	char *check;
! 
! 	/* Process a priority value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_priority: just one priority value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_priority: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_priority: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	priority_val= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_priority: bad priority value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (priority_val < 0 || priority_val >= NR_SCHED_QUEUES)
! 	{
! 		fatal("do_priority: priority %d out of range at %s:%d",
! 			priority_val, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_priority= priority_val;
! }
! 
! static void do_quantum(config_t *cpe, struct rs_start *rs_start)
! {
! 	int quantum_val;
! 	char *check;
! 
! 	/* Process a quantum value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_quantum: just one quantum value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_quantum: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_quantum: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	quantum_val= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_quantum: bad quantum value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (quantum_val <= 0)
! 	{
! 		fatal("do_quantum: quantum %d out of range at %s:%d",
! 			quantum_val, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_quantum= quantum_val;
! }
! 
! static void do_cpu(config_t *cpe, struct rs_start *rs_start)
! {
! 	int cpu;
! 	char *check;
! 
! 	/* Process a quantum value */
! 	if (cpe->next != NULL)
! 	{
! 		fatal("do_cpu: just one value expected at %s:%d",
! 			cpe->file, cpe->line);
! 	}	
! 	
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_cpu: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_cpu: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	cpu= strtol(cpe->word, &check, 0);
! 	if (check[0] != '\0')
! 	{
! 		fatal("do_cpu: bad value '%s' at %s:%d",
! 			cpe->word, cpe->file, cpe->line);
! 	}
! 
! 	if (cpu < 0)
! 	{
! 		fatal("do_cpu: %d out of range at %s:%d",
! 			cpu, cpe->file, cpe->line);
! 	}
! 	rs_start->rss_cpu= cpu;
! }
! 
! static void do_irq(config_t *cpe, struct rs_start *rs_start)
! {
! 	int irq;
! 	int first;
! 	char *check;
! 
! 	/* Process a list of IRQs */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_irq: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_irq: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* No IRQ allowed? (default) */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_irq: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* All IRQs are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_irq: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			rs_start->rss_nr_irq = RSS_IO_ALL;
! 			break;
! 		}
! 
! 		/* Set single IRQs as specified in the configuration. */
! 		irq= strtoul(cpe->word, &check, 0);
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_irq: bad irq '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		if (rs_start->rss_nr_irq >= RSS_NR_IRQ)
! 			fatal("do_irq: too many IRQs (max %d)", RSS_NR_IRQ);
! 		rs_start->rss_irq[rs_start->rss_nr_irq]= irq;
! 		rs_start->rss_nr_irq++;
! 		first = FALSE;
! 	}
! }
! 
! static void do_io(config_t *cpe, struct rs_start *rs_start)
! {
! 	unsigned base, len;
! 	int first;
! 	char *check;
! 
! 	/* Process a list of I/O ranges */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_io: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_io: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* No range allowed? (default) */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_io: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* All ranges are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_io: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			rs_start->rss_nr_io = RSS_IO_ALL;
! 			break;
! 		}
! 
! 		/* Set single ranges as specified in the configuration. */
! 		base= strtoul(cpe->word, &check, 0x10);
! 		len= 1;
! 		if (check[0] == ':')
! 		{
! 			len= strtoul(check+1, &check, 0x10);
! 		}
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_io: bad I/O range '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 
! 		if (rs_start->rss_nr_io >= RSS_NR_IO)
! 			fatal("do_io: too many I/O ranges (max %d)", RSS_NR_IO);
! 		rs_start->rss_io[rs_start->rss_nr_io].base= base;
! 		rs_start->rss_io[rs_start->rss_nr_io].len= len;
! 		rs_start->rss_nr_io++;
! 		first = FALSE;
! 	}
! }
! 
! static void do_pci_device(config_t *cpe, struct rs_start *rs_start)
! {
! 	u16_t vid, did;
! 	char *check, *check2;
! 
! 	/* Process a list of PCI device IDs */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_pci_device: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_pci_device: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		vid= strtoul(cpe->word, &check, 0x10);
! 		if (check[0] == '/')
! 			did= strtoul(check+1, &check2, 0x10);
! 		if (check[0] != '/' || check2[0] != '\0')
! 		{
! 			fatal("do_pci_device: bad ID '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		if (rs_start->rss_nr_pci_id >= RS_NR_PCI_DEVICE)
! 		{
! 			fatal("do_pci_device: too many device IDs (max %d)",
! 				RS_NR_PCI_DEVICE);
! 		}
! 		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].vid= vid;
! 		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].did= did;
! 		rs_start->rss_nr_pci_id++;
! 	}
! }
! 
! static void do_pci_class(config_t *cpe, struct rs_start *rs_start)
! {
! 	u8_t baseclass, subclass, interface;
! 	u32_t class_id, mask;
! 	char *check;
! 
! 	/* Process a list of PCI device class IDs */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_pci_device: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_pci_device: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		baseclass= strtoul(cpe->word, &check, 0x10);
! 		subclass= 0;
! 		interface= 0;
! 		mask= 0xff0000;
! 		if (check[0] == '/')
! 		{
! 			subclass= strtoul(check+1, &check, 0x10);
! 			mask= 0xffff00;
! 			if (check[0] == '/')
! 			{
! 				interface= strtoul(check+1, &check, 0x10);
! 				mask= 0xffffff;
! 			}
! 		}
! 
! 		if (check[0] != '\0')
! 		{
! 			fatal("do_pci_class: bad class ID '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		}
! 		class_id= (baseclass << 16) | (subclass << 8) | interface;
! 		if (rs_start->rss_nr_pci_class >= RS_NR_PCI_CLASS)
! 		{
! 			fatal("do_pci_class: too many class IDs (max %d)",
! 				RS_NR_PCI_CLASS);
! 		}
! 		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].pciclass=
! 			class_id;
! 		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].mask= mask;
! 		rs_start->rss_nr_pci_class++;
! 	}
! }
! 
! static void do_pci(config_t *cpe, struct rs_start *rs_start)
! {
! 	if (cpe == NULL)
! 		return;	/* Empty PCI statement */
! 
! 	if (cpe->flags & CFG_SUBLIST)
! 	{
! 		fatal("do_pci: unexpected sublist at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->flags & CFG_STRING)
! 	{
! 		fatal("do_pci: unexpected string at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 
! 	if (strcmp(cpe->word, KW_DEVICE) == 0)
! 	{
! 		do_pci_device(cpe->next, rs_start);
! 		return;
! 	}
! 	if (strcmp(cpe->word, KW_CLASS) == 0)
! 	{
! 		do_pci_class(cpe->next, rs_start);
! 		return;
! 	}
! 	fatal("do_pci: unexpected word '%s' at %s:%d",
! 		cpe->word, cpe->file, cpe->line);
! }
! 
! static void do_ipc(config_t *cpe, struct rs_start *rs_start)
! {
! 	char *list;
! 	const char *word;
! 	char *word_all = RSS_IPC_ALL;
! 	char *word_all_sys = RSS_IPC_ALL_SYS;
! 	size_t listsize, wordlen;
! 	int first;
! 
! 	list= NULL;
! 	listsize= 1;
! 	list= malloc(listsize);
! 	if (list == NULL)
! 		fatal("do_ipc: unable to malloc %d bytes", listsize);
! 	list[0]= '\0';
! 
! 	/* Process a list of process names that are allowed to be
! 	 * contacted
! 	 */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_ipc: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_ipc: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		word = cpe->word;
! 
! 		/* All (system) ipc targets are allowed? */
! 		if(!strcmp(word, KW_ALL) || !strcmp(word, KW_ALL_SYS)) {
! 			if(!first || cpe->next) {
! 				fatal("do_ipc: %s keyword not allowed in list",
! 				word);
! 			}
! 			word = !strcmp(word, KW_ALL) ? word_all : word_all_sys;
! 		}
! 
! 		wordlen= strlen(word);
! 
! 		listsize += 1 + wordlen;
! 		list= realloc(list, listsize);
! 		if (list == NULL)
! 		{
! 			fatal("do_ipc: unable to realloc %d bytes",
! 				listsize);
! 		}
! 		strcat(list, " ");
! 		strcat(list, word);
! 		first = FALSE;
! 	}
! #if 0
! 	printf("do_ipc: got list '%s'\n", list);
! #endif
! 
! 	if (rs_start->rss_ipc)
! 		fatal("do_ipc: req_ipc is set");
!         rs_start->rss_ipc = list+1;
! 	rs_start->rss_ipclen= strlen(rs_start->rss_ipc);
! }
! 
! 
! struct
! {
! 	char *label;
! 	int call_nr;
! } vm_table[] =
! {
! 	{ "EXIT",		VM_EXIT },
! 	{ "FORK",		VM_FORK },
! 	{ "BRK",		VM_BRK },
! 	{ "EXEC_NEWMEM",	VM_EXEC_NEWMEM },
! 	{ "PUSH_SIG",		0 },
! 	{ "WILLEXIT",		VM_WILLEXIT },
! 	{ "ADDDMA",		VM_ADDDMA },
! 	{ "DELDMA",		VM_DELDMA },
! 	{ "GETDMA",		VM_GETDMA },
! 	{ "REMAP",		VM_REMAP },
! 	{ "REMAP_RO",		VM_REMAP_RO },
! 	{ "SHM_UNMAP",		VM_SHM_UNMAP },
! 	{ "GETPHYS",		VM_GETPHYS },
! 	{ "GETREF",		VM_GETREF },
! 	{ "RS_SET_PRIV",	VM_RS_SET_PRIV },
! 	{ "QUERY_EXIT",		VM_QUERY_EXIT },
! 	{ "WATCH_EXIT",		VM_WATCH_EXIT },
! 	{ "NOTIFY_SIG",		VM_NOTIFY_SIG },
! 	{ "INFO",		VM_INFO },
! 	{ "RS_UPDATE",		VM_RS_UPDATE },
! 	{ "RS_MEMCTL",		VM_RS_MEMCTL },
! 	{ "PROCCTL",		VM_PROCCTL },
! 	{ NULL,			0 },
! };
! 
! static void do_vm(config_t *cpe, struct rs_start *rs_start)
! {
! 	int i, first;
! 
! 	first = TRUE;
! 	for (; cpe; cpe = cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_vm: unexpected sublist at %s:%d",
! 			      cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_vm: unexpected string at %s:%d",
! 			      cpe->file, cpe->line);
! 		}
! 
! 		/* Only basic calls allowed? (default). */
! 		if(!strcmp(cpe->word, KW_BASIC)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* No calls allowed? */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			rs_start->rss_flags &= ~RSS_VM_BASIC_CALLS;
! 			break;
! 		}
! 
! 		/* All calls are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_vm: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			for (i = 0; i < NR_VM_CALLS; i++)
! 				SET_BIT(rs_start->rss_vm, i);
! 			break;
! 		}
! 
! 		/* Set single calls as specified in the configuration. */
! 		for (i = 0; vm_table[i].label != NULL; i++)
! 			if (!strcmp(cpe->word, vm_table[i].label))
! 				break;
! 		if (vm_table[i].label == NULL) {
! 			warning("do_vm: ignoring unknown call '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		} else if(vm_table[i].call_nr) {
! 			SET_BIT(rs_start->rss_vm,
! 				vm_table[i].call_nr - VM_RQ_BASE);
! 		}
! 
! 		first = FALSE;
! 	}
! }
! 
! struct
! {
! 	char *label;
! 	int call_nr;
! } system_tab[]=
! {
! 	{ "PRIVCTL",		SYS_PRIVCTL },
! 	{ "TRACE",		SYS_TRACE },
! 	{ "KILL",		SYS_KILL },
! 	{ "UMAP",		SYS_UMAP },
! 	{ "VIRCOPY",		SYS_VIRCOPY },
! 	{ "PHYSCOPY",		SYS_PHYSCOPY },
! 	{ "UMAP_REMOTE",	SYS_UMAP_REMOTE },
! 	{ "VUMAP",		SYS_VUMAP },
! 	{ "IRQCTL",		SYS_IRQCTL },
! 	{ "INT86",		SYS_INT86 },
! 	{ "DEVIO",		SYS_DEVIO },
! 	{ "SDEVIO",		SYS_SDEVIO },
! 	{ "VDEVIO",		SYS_VDEVIO },
! 	{ "ABORT",		SYS_ABORT },
! 	{ "IOPENABLE",		SYS_IOPENABLE },
! 	{ "READBIOS",		SYS_READBIOS },
! 	{ "STIME",		SYS_STIME },
! 	{ "VMCTL",		SYS_VMCTL },
! 	{ "MEMSET",		SYS_MEMSET },
! 	{ "CHREALTIME",		SYS_CHREALTIME },
! 	{ NULL,		0 }
! };
! 
! static void do_system(config_t *cpe, struct rs_start *rs_start)
! {
! 	int i, first;
! 
! 	/* Process a list of 'system' calls that are allowed */
! 	first = TRUE;
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_system: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_system: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* Only basic calls allowed? (default). */
! 		if(!strcmp(cpe->word, KW_BASIC)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			break;
! 		}
! 
! 		/* No calls allowed? */
! 		if(!strcmp(cpe->word, KW_NONE)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_NONE);
! 			}
! 			rs_start->rss_flags &= ~RSS_SYS_BASIC_CALLS;
! 			break;
! 		}
! 
! 		/* All calls are allowed? */
! 		if(!strcmp(cpe->word, KW_ALL)) {
! 			if(!first || cpe->next) {
! 				fatal("do_system: %s keyword not allowed in list",
! 				KW_ALL);
! 			}
! 			for (i = 0; i < NR_SYS_CALLS; i++)
! 				SET_BIT(rs_start->rss_system, i);
! 			break;
! 		}
! 
! 		/* Set single calls as specified in the configuration. */
! 		for (i = 0; system_tab[i].label != NULL; i++)
! 			if (!strcmp(cpe->word, system_tab[i].label))
! 				break;
! 		if (system_tab[i].label == NULL) {
! 		   warning("do_system: ignoring unknown call '%s' at %s:%d",
! 				cpe->word, cpe->file, cpe->line);
! 		} else {
! 			SET_BIT(rs_start->rss_system,
! 				system_tab[i].call_nr - KERNEL_CALL);
! 		}
! 		first = FALSE;
! 	}
! }
! 
! static void do_control(config_t *cpe, struct rs_start *rs_start)
! {
! 	int nr_control = 0;
! 
! 	/* Process a list of 'control' labels. */
! 	for (; cpe; cpe= cpe->next)
! 	{
! 		if (cpe->flags & CFG_SUBLIST)
! 		{
! 			fatal("do_control: unexpected sublist at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (cpe->flags & CFG_STRING)
! 		{
! 			fatal("do_control: unexpected string at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 		if (nr_control >= RS_NR_CONTROL)
! 		{
! 			fatal(
! 			"do_control: RS_NR_CONTROL is too small (%d needed)",
! 				nr_control+1);
! 		}
! 
! 		rs_start->rss_control[nr_control].l_addr = (char*) cpe->word;
! 		rs_start->rss_control[nr_control].l_len = strlen(cpe->word);
! 		rs_start->rss_nr_control = ++nr_control;
! 	}
! }
! 
! static void do_service(config_t *cpe, config_t *config, struct rs_config *rs_config)
! {
! 	struct rs_start *rs_start = &rs_config->rs_start;
! 	config_t *cp;
! 
! 	/* At this point we expect one sublist that contains the varios
! 	 * resource allocations
! 	 */
! 	if (!(cpe->flags & CFG_SUBLIST))
! 	{
! 		fatal("do_service: expected list at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	if (cpe->next != NULL)
! 	{
! 		cpe= cpe->next;
! 		fatal("do_service: expected end of list at %s:%d",
! 			cpe->file, cpe->line);
! 	}
! 	cpe= cpe->list;
! 
! 	/* Process the list */
! 	for (cp= cpe; cp; cp= cp->next)
! 	{
! 		if (!(cp->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_service: expected list at %s:%d",
! 				cp->file, cp->line);
! 		}
! 		cpe= cp->list;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_service: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		if (strcmp(cpe->word, KW_CLASS) == 0)
! 		{
! 			do_class(cpe->next, config, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_UID) == 0)
! 		{
! 			do_uid(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SIGMGR) == 0)
! 		{
! 			do_sigmgr(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_TYPE) == 0)
! 		{
! 			do_type(cpe->next, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_DESCR) == 0)
! 		{
! 			do_descr(cpe->next, rs_config);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SCHEDULER) == 0)
! 		{
! 			do_scheduler(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_PRIORITY) == 0)
! 		{
! 			do_priority(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_QUANTUM) == 0)
! 		{
! 			do_quantum(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_CPU) == 0)
! 		{
! 			do_cpu(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IRQ) == 0)
! 		{
! 			do_irq(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IO) == 0)
! 		{
! 			do_io(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_PCI) == 0)
! 		{
! 			do_pci(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_SYSTEM) == 0)
! 		{
! 			do_system(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_IPC) == 0)
! 		{
! 			do_ipc(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_VM) == 0)
! 		{
! 			do_vm(cpe->next, rs_start);
! 			continue;
! 		}
! 		if (strcmp(cpe->word, KW_CONTROL) == 0)
! 		{
! 			do_control(cpe->next, rs_start);
! 			continue;
! 		}
! 	}
! }
! 
! static const char *do_config(const char *label, char *filename, struct rs_config *rs_config)
! {
! 	config_t *config, *cp, *cpe;
! 	struct passwd *pw;
! 	struct rs_start *rs_start = &rs_config->rs_start;
! 
! 	if(!(config= config_read(filename, 0, NULL)))
! 		return NULL; /* config file read failed. */
! 
! 	/* Set clean rs_start defaults. */
! 	memset(rs_config, 0, sizeof(*rs_config));
! 	if(!(pw= getpwnam(SERVICE_LOGIN)))
! 		fatal("no passwd file entry for '%s'", SERVICE_LOGIN);
! 	rs_start->rss_uid= pw->pw_uid;
! 	rs_start->rss_sigmgr= DSRV_SM;
! 	rs_start->rss_scheduler= DSRV_SCH;
! 	rs_start->rss_priority= DSRV_Q;
! 	rs_start->rss_quantum= DSRV_QT;
! 	rs_start->rss_cpu = DSRV_CPU;
! 	rs_start->rss_flags = RSS_VM_BASIC_CALLS | RSS_SYS_BASIC_CALLS;
! 
! 	/* Find an entry for our service */
! 	for (cp= config; cp; cp= cp->next)
! 	{
! 		if (!(cp->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected list at %s:%d",
! 				cp->file, cp->line);
! 		}
! 		cpe= cp->list;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* At this place we expect the word KW_SERVICE */
! 		if (strcmp(cpe->word, KW_SERVICE) != 0)
! 			fatal("do_config: exected word '%S' at %s:%d",
! 				KW_SERVICE, cpe->file, cpe->line);
! 
! 		cpe= cpe->next;
! 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
! 		{
! 			fatal("do_config: expected word at %s:%d",
! 				cpe->file, cpe->line);
! 		}
! 
! 		/* At this place we expect the name of the service. */
! 		if (!label || strcmp(cpe->word, label) == 0) {
! 			label = cpe->word;
! 			break;
! 		}
! 	}
! 	if (cp == NULL)
! 	{
! 		fprintf(stderr, "service: service '%s' not found in '%s'\n",
! 			label, filename);
! 		exit(1);
! 	}
! 
! 	cpe= cpe->next;
! 
! 	do_service(cpe, config, rs_config);
! 
! 	{
! 		char *default_ipc = RSS_IPC_ALL_SYS;
! 		if(!rs_start->rss_ipc) {
! 		      rs_start->rss_ipc= default_ipc;
! 		      rs_start->rss_ipclen= strlen(default_ipc);
! 		}
! 	}
! 
! 	/* config file read ok. */
! 	return label;
! }
! 
! /* returns failure */
! const char *parse_config(char *progname, int custom_config, char *req_config,
! 	struct rs_config *rs_config)
! {
!         char *specificconfig, *specific_pkg_config;
! 	const char *l;
! 
! 	/* Config file specified? */
!         if(custom_config)
!           return do_config(progname, req_config, rs_config);
! 
! 	/* No specific config file. */
!         if(asprintf(&specificconfig, "%s/%s", _PATH_SYSTEM_CONF_DIR,
!               progname) < 0) {
!               errx(1, "no memory");
!         }
! 
!         if(asprintf(&specific_pkg_config, "%s/%s", _PATH_SYSTEM_CONF_PKG_DIR,
!               progname) < 0) {
!               errx(1, "no memory");
!         }
! 
!         /* Try specific config filename first, in base system
! 	 * and package locations, * and only if it fails, the global
! 	 * system one.
!          */
! 	if((l=do_config(progname, specific_pkg_config, rs_config))) return l;
! 	if((l=do_config(progname, specificconfig, rs_config))) return l;
! 	if((l=do_config(progname, req_config, rs_config))) return l;
! 
! 	return NULL;
! }
! 
diff -crN usr_orig/src/include/minix/callnr.h EDF/src/include/minix/callnr.h
*** usr_orig/src/include/minix/callnr.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/include/minix/callnr.h	2016-12-08 00:17:19.631910742 +0800
***************
*** 1,115 ****
! #define NCALLS		 114	/* number of system calls allowed */
! 
! /* In case it isn't obvious enough: this list is sorted numerically. */
! #define EXIT		   1 
! #define FORK		   2 
! #define READ		   3 
! #define WRITE		   4 
! #define OPEN		   5 
! #define CLOSE		   6 
! #define WAIT		   7
! #define CREAT		   8 
! #define LINK		   9 
! #define UNLINK		  10 
! #define WAITPID		  11
! #define CHDIR		  12 
! #define TIME		  13
! #define MKNOD		  14 
! #define CHMOD		  15 
! #define CHOWN		  16 
! #define BRK		  17
! #define PREV_STAT	  18
! #define LSEEK		  19
! #define MINIX_GETPID	  20
! #define MOUNT		  21 
! #define UMOUNT		  22 
! #define SETUID		  23
! #define GETUID		  24
! #define STIME		  25
! #define PTRACE		  26
! #define ALARM		  27
! #define PREV_FSTAT	  28
! #define PAUSE		  29
! #define UTIME		  30 
! #define GETEPINFO	  31
! #define SETGROUPS	  32
! #define ACCESS		  33 
! #define GETGROUPS	  34
! #define SYNC		  36 
! #define KILL		  37
! #define RENAME		  38
! #define MKDIR		  39
! #define RMDIR		  40
! #define DUP		  41 
! #define PIPE		  42 
! #define TIMES		  43
! #define SYMLINK		  45
! #define SETGID		  46
! #define GETGID		  47
! #define SIGNAL		  48
! #define RDLNK		  49
! #define PREV_LSTAT	  50
! #define STAT		  51
! #define FSTAT		  52
! #define LSTAT		  53
! #define IOCTL		  54
! #define FCNTL		  55
! #define FS_READY	  57
! #define EXEC		  59
! #define UMASK		  60 
! #define CHROOT		  61 
! #define SETSID		  62
! #define GETPGRP		  63
! #define ITIMER		  64
! #define GETGROUPS_O	  65
! #define SETGROUPS_O	  66
! #define GETMCONTEXT       67
! #define SETMCONTEXT       68
! 
! /* Posix signal handling. */
! #define SIGACTION	  71
! #define SIGSUSPEND	  72
! #define SIGPENDING	  73
! #define SIGPROCMASK	  74
! #define SIGRETURN	  75
! 
! #define REBOOT		  76
! #define SVRCTL		  77
! #define SYSUNAME	  78
! #define GETDENTS	  80	/* to VFS */
! #define LLSEEK		  81	/* to VFS */
! #define FSTATFS	 	  82	/* to VFS */
! #define STATVFS 	  83	/* to VFS */
! #define FSTATVFS 	  84	/* to VFS */
! #define SELECT            85	/* to VFS */
! #define FCHDIR            86	/* to VFS */
! #define FSYNC             87	/* to VFS */
! #define GETPRIORITY       88	/* to PM */
! #define SETPRIORITY       89	/* to PM */
! #define GETTIMEOFDAY      90	/* to PM */
! #define SETEUID		  91	/* to PM */
! #define SETEGID		  92	/* to PM */
! #define TRUNCATE	  93	/* to VFS */
! #define FTRUNCATE	  94	/* to VFS */
! #define FCHMOD		  95	/* to VFS */
! #define FCHOWN		  96	/* to VFS */
! #define SPROF             98    /* to PM */
! #define CPROF             99    /* to PM */
! 
! /* Calls provided by PM and FS that are not part of the API */
! #define PM_NEWEXEC	100	/* from VFS or RS to PM: new exec */
! #define SRV_FORK  	101	/* to PM: special fork call for RS */
! #define EXEC_RESTART	102	/* to PM: final part of exec for RS */
! #define GETPROCNR	104	/* to PM */
! #define ISSETUGID	106	/* to PM: ask if process is tainted */
! #define GETEPINFO_O	107	/* to PM: get pid/uid/gid of an endpoint */
! #define SRV_KILL  	111	/* to PM: special kill call for RS */
! 
! #define GCOV_FLUSH	112	/* flush gcov data from server to gcov files */
! 
! #define PM_GETSID	113	/* PM getsid() */
! 
! #define TASK_REPLY	121	/* to VFS: reply code from drivers, not 
! 				 * really a standalone call.
! 				 */
! #define MAPDRIVER      122     /* to VFS, map a device */
--- 1,116 ----
! #define NCALLS		 114	/* number of system calls allowed */
! 
! /* In case it isn't obvious enough: this list is sorted numerically. */
! #define EXIT		   1 
! #define FORK		   2 
! #define READ		   3 
! #define WRITE		   4 
! #define OPEN		   5 
! #define CLOSE		   6 
! #define WAIT		   7
! #define CREAT		   8 
! #define LINK		   9 
! #define UNLINK		  10 
! #define WAITPID		  11
! #define CHDIR		  12 
! #define TIME		  13
! #define MKNOD		  14 
! #define CHMOD		  15 
! #define CHOWN		  16 
! #define BRK		  17
! #define PREV_STAT	  18
! #define LSEEK		  19
! #define MINIX_GETPID	  20
! #define MOUNT		  21 
! #define UMOUNT		  22 
! #define SETUID		  23
! #define GETUID		  24
! #define STIME		  25
! #define PTRACE		  26
! #define ALARM		  27
! #define PREV_FSTAT	  28
! #define PAUSE		  29
! #define UTIME		  30 
! #define GETEPINFO	  31
! #define SETGROUPS	  32
! #define ACCESS		  33 
! #define GETGROUPS	  34
! #define SYNC		  36 
! #define KILL		  37
! #define RENAME		  38
! #define MKDIR		  39
! #define RMDIR		  40
! #define DUP		  41 
! #define PIPE		  42 
! #define TIMES		  43
! #define SYMLINK		  45
! #define SETGID		  46
! #define GETGID		  47
! #define SIGNAL		  48
! #define RDLNK		  49
! #define PREV_LSTAT	  50
! #define STAT		  51
! #define FSTAT		  52
! #define LSTAT		  53
! #define IOCTL		  54
! #define FCNTL		  55
! #define FS_READY	  57
! #define EXEC		  59
! #define UMASK		  60 
! #define CHROOT		  61 
! #define SETSID		  62
! #define GETPGRP		  63
! #define ITIMER		  64
! #define GETGROUPS_O	  65
! #define SETGROUPS_O	  66
! #define GETMCONTEXT       67
! #define SETMCONTEXT       68
! 
! /* Posix signal handling. */
! #define SIGACTION	  71
! #define SIGSUSPEND	  72
! #define SIGPENDING	  73
! #define SIGPROCMASK	  74
! #define SIGRETURN	  75
! 
! #define REBOOT		  76
! #define SVRCTL		  77
! #define SYSUNAME	  78
! #define GETDENTS	  80	/* to VFS */
! #define LLSEEK		  81	/* to VFS */
! #define FSTATFS	 	  82	/* to VFS */
! #define STATVFS 	  83	/* to VFS */
! #define FSTATVFS 	  84	/* to VFS */
! #define SELECT            85	/* to VFS */
! #define FCHDIR            86	/* to VFS */
! #define FSYNC             87	/* to VFS */
! #define GETPRIORITY       88	/* to PM */
! #define SETPRIORITY       89	/* to PM */
! #define GETTIMEOFDAY      90	/* to PM */
! #define SETEUID		  91	/* to PM */
! #define SETEGID		  92	/* to PM */
! #define TRUNCATE	  93	/* to VFS */
! #define FTRUNCATE	  94	/* to VFS */
! #define FCHMOD		  95	/* to VFS */
! #define FCHOWN		  96	/* to VFS */
! #define SPROF             98    /* to PM */
! #define CPROF             99    /* to PM */
! #define CHREALTIME              69    /* to PM */
! 
! /* Calls provided by PM and FS that are not part of the API */
! #define PM_NEWEXEC	100	/* from VFS or RS to PM: new exec */
! #define SRV_FORK  	101	/* to PM: special fork call for RS */
! #define EXEC_RESTART	102	/* to PM: final part of exec for RS */
! #define GETPROCNR	104	/* to PM */
! #define ISSETUGID	106	/* to PM: ask if process is tainted */
! #define GETEPINFO_O	107	/* to PM: get pid/uid/gid of an endpoint */
! #define SRV_KILL  	111	/* to PM: special kill call for RS */
! 
! #define GCOV_FLUSH	112	/* flush gcov data from server to gcov files */
! 
! #define PM_GETSID	113	/* PM getsid() */
! 
! #define TASK_REPLY	121	/* to VFS: reply code from drivers, not 
! 				 * really a standalone call.
! 				 */
! #define MAPDRIVER      122     /* to VFS, map a device */
diff -crN usr_orig/src/include/minix/com.h EDF/src/include/minix/com.h
*** usr_orig/src/include/minix/com.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/include/minix/com.h	2016-12-08 00:17:19.643910742 +0800
***************
*** 1,1283 ****
! /* This file defines constants for use in message communication (mostly)
!  * between system processes.
!  *
!  * A number of protocol message request and response types are defined. For
!  * debugging purposes, each protocol is assigned its own unique number range.
!  * The following such message type ranges have been allocated:
!  *
!  *        1 -   0xFF	POSIX requests (see callnr.h)
!  *    0x200 -  0x2FF	Data link layer requests and responses
!  *    0x300 -  0x3FF	Bus controller requests and responses
!  *    0x400 -  0x4FF	Character device requests
!  *    0x500 -  0x5FF	Character device responses
!  *    0x600 -  0x6FF	Kernel calls to SYSTEM task
!  *    0x700 -  0x7FF	Reincarnation Server (RS) requests
!  *    0x800 -  0x8FF	Data Store (DS) requests
!  *    0x900 -  0x9FF	Requests from PM to VFS, and responses
!  *    0xA00 -  0xAFF	Requests from VFS to file systems (see vfsif.h)
!  *    0xB00 -  0xBFF	Requests from VM to VFS
!  *    0xC00 -  0xCFF	Virtual Memory (VM) requests
!  *    0xD00 -  0xDFF	IPC server requests
!  *    0xE00 -  0xEFF	Common system messages (e.g. system signals)
!  *    0xF00 -  0xFFF    Scheduling messages
!  *   0x1000 - 0x10FF	Notify messages
!  *   0x1100 - 0x11FF	USB  
!  *   0x1200 - 0x12FF    Devman
!  *   0x1300 - 0x13FF    TTY Input
!  *   0x1400 - 0x14FF	VFS-FS transaction IDs
!  *   0x1500 - 0x15FF	Block device requests and responses
!  *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
!  *
!  * Zero and negative values are widely used for OK and error responses.
!  */
! 
! #ifndef _MINIX_COM_H
! #define _MINIX_COM_H 
! 
! /*===========================================================================*
!  *          	    		Magic process numbers			     *
!  *===========================================================================*/
! 
! /* These may not be any valid endpoint (see <minix/endpoint.h>). */
! #define ANY	((endpoint_t) 0x7ace)	/* used to indicate 'any process' */
! #define NONE 	((endpoint_t) 0x6ace)   /* used to indicate 'no process at all' */
! #define SELF	((endpoint_t) 0x8ace) 	/* used to indicate 'own process' */
! #define _MAX_MAGIC_PROC (SELF)	/* used by <minix/endpoint.h> 
! 				   to determine generation size */
! 
! /*===========================================================================*
!  *            	Process numbers of processes in the system image	     *
!  *===========================================================================*/
! 
! /* The values of several task numbers depend on whether they or other tasks
!  * are enabled. They are defined as (PREVIOUS_TASK - ENABLE_TASK) in general.
!  * ENABLE_TASK is either 0 or 1, so a task either gets a new number, or gets
!  * the same number as the previous task and is further unused. Note that the
!  * order should correspond to the order in the task table defined in table.c. 
!  */
! 
! /* Kernel tasks. These all run in the same address space. */
! #define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
! #define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
! #define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
! #define SYSTEM  ((endpoint_t) -2) /* request system functionality */
! #define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
! #define HARDWARE     KERNEL	/* for hardware interrupt handlers */
! 
! /* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
! #define MAX_NR_TASKS	1023
! #define NR_TASKS	  5 
! 
! /* User-space processes, that is, device drivers, servers, and INIT. */
! #define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
! #define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
! #define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
! #define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
! #define LOG_PROC_NR  ((endpoint_t) 4)	/* log device driver */
! #define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
! #define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
! #define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
! #define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
! #define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
! #define SCHED_PROC_NR ((endpoint_t) 10)	/* scheduler */
! #define LAST_SPECIAL_PROC_NR	11	/* An untyped version for
!                                            computation in macros.*/
! #define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
!                                                         -- goes multiuser */
! #define NR_BOOT_MODULES (INIT_PROC_NR+1)
! 
! /* Root system process and root user process. */
! #define ROOT_SYS_PROC_NR  RS_PROC_NR
! #define ROOT_USR_PROC_NR  INIT_PROC_NR
! 
! /*===========================================================================*
!  *                	   Kernel notification types                         *
!  *===========================================================================*/
! 
! /* Kernel notification types. In principle, these can be sent to any process,
!  * so make sure that these types do not interfere with other message types.
!  * Notifications are prioritized because of the way they are unhold() and
!  * blocking notifications are delivered. The lowest numbers go first. The
!  * offset are used for the per-process notification bit maps. 
!  */
! #define NOTIFY_MESSAGE		  0x1000
! /* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
! #define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
! #define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
! #define is_ipc_asynch(ipc_status) \
!     (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
! 
! /* Shorthands for message parameters passed with notifications. */
! #define NOTIFY_ARG		m2_l1
! #define NOTIFY_TIMESTAMP	m2_l2
! 
! /*===========================================================================*
!  *                Messages for BUS controller drivers 			     *
!  *===========================================================================*/
! #define BUSC_RQ_BASE	0x300	/* base for request types */
! #define BUSC_RS_BASE	0x380	/* base for response types */
! 
! #define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
! 							 * PCI driver
! 							 */
! #define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
! 							 * vid/did) of the
! 							 * first PCI device
! 							 */
! #define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
! 							 * vid/did) of the
! 							 * next PCI device
! 							 */
! #define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
! 							 * PCI device based on
! 							 * bus/dev/function
! 							 */
! #define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
! 							 * index
! 							 */
! #define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
! #define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
! #define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
! 							 * PCI device
! 							 * (safecopy)
! 							 */
! #define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
! 							 * PCI slot (safecopy)
! 							 */
! #define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
! 							 * driver (safecopy)
! 							 */
! #define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
! 							 * driver 
! 							 */
! #define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
! 							 * Register properties
! 							 */
! #define   BUSC_PGB_DEVIND	m2_i1			/* device index */
! #define   BUSC_PGB_PORT		m2_i2			/* port (BAR offset) */
! #define   BUSC_PGB_BASE		m2_l1			/* BAR base address */
! #define   BUSC_PGB_SIZE		m2_l2			/* BAR size */
! #define   BUSC_PGB_IOFLAG	m2_i1			/* I/O space? */
! #define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
! 							 * a segment of memory
! 							 */
! 
! 
! /*===========================================================================*
!  *                Messages for CHARACTER device drivers			     *
!  *===========================================================================*/
! 
! /* Message types for character device drivers. */
! #define DEV_RQ_BASE   0x400	/* base for character device request types */
! #define DEV_RS_BASE   0x500	/* base for character device response types */
! 
! #define CANCEL       	(DEV_RQ_BASE +  0) /* force a task to cancel */
! #define DEV_OPEN     	(DEV_RQ_BASE +  6) /* open a minor device */
! #define DEV_CLOSE    	(DEV_RQ_BASE +  7) /* close a minor device */
! #define DEV_SELECT	(DEV_RQ_BASE + 12) /* request select() attention */
! #define DEV_STATUS   	(DEV_RQ_BASE + 13) /* request driver status */
! #define DEV_REOPEN     	(DEV_RQ_BASE + 14) /* reopen a minor device */
! 
! #define DEV_READ_S	(DEV_RQ_BASE + 20) /* (safecopy) read from minor */
! #define DEV_WRITE_S   	(DEV_RQ_BASE + 21) /* (safecopy) write to minor */
! #define DEV_SCATTER_S  	(DEV_RQ_BASE + 22) /* (safecopy) write from a vector */
! #define DEV_GATHER_S   	(DEV_RQ_BASE + 23) /* (safecopy) read into a vector */
! #define DEV_IOCTL_S    	(DEV_RQ_BASE + 24) /* (safecopy) I/O control code */
! 
! #define IS_DEV_RQ(type) (((type) & ~0xff) == DEV_RQ_BASE)
! 
! #define DEV_REVIVE      (DEV_RS_BASE + 2) /* driver revives process */
! #define DEV_IO_READY    (DEV_RS_BASE + 3) /* selected device ready */
! #define DEV_NO_STATUS   (DEV_RS_BASE + 4) /* empty status reply */
! #define DEV_REOPEN_REPL (DEV_RS_BASE + 5) /* reply to DEV_REOPEN */
! #define DEV_CLOSE_REPL	(DEV_RS_BASE + 6) /* reply to DEV_CLOSE */
! #define DEV_SEL_REPL1	(DEV_RS_BASE + 7) /* first reply to DEV_SELECT */
! #define DEV_SEL_REPL2	(DEV_RS_BASE + 8) /* (opt) second reply to DEV_SELECT */
! #define DEV_OPEN_REPL	(DEV_RS_BASE + 9) /* reply to DEV_OPEN */
! 
! #define IS_DEV_RS(type) (((type) & ~0xff) == DEV_RS_BASE)
! 
! /* Field names for messages to character device drivers. */
! #define DEVICE    	m2_i1	/* major-minor device */
! #define USER_ENDPT	m2_i2	/* which endpoint initiated this call? */
! #define COUNT   	m2_i3	/* how many bytes to transfer */
! #define REQUEST 	m2_i3 	/* ioctl request code */
! #define POSITION	m2_l1	/* file offset (low 4 bytes) */
! #define HIGHPOS		m2_l2	/* file offset (high 4 bytes) */
! #define ADDRESS 	m2_p1	/* core buffer address */
! #define IO_GRANT 	m2_p1	/* grant id (for DEV_*_S variants) */
! #define FLAGS		m2_s1   /* operation flags */
! 
! #define FLG_OP_NONBLOCK	0x1 /* operation is non blocking */
! 
! /* Field names for DEV_SELECT messages to character device drivers. */
! #define DEV_MINOR	m2_i1	/* minor device */
! #define DEV_SEL_OPS	m2_i2	/* which select operations are requested */
! 
! /* Field names used in reply messages from tasks. */
! #define REP_ENDPT	m2_i1	/* # of proc on whose behalf I/O was done */
! #define REP_STATUS	m2_i2	/* bytes transferred or error number */
! #define REP_IO_GRANT	m2_i3	/* DEV_REVIVE: grant by which I/O was done */
! #  define SUSPEND 	 -998 	/* status to suspend caller, reply later */
! 
! /* Field names for messages to TTY driver. */
! #define TTY_LINE	DEVICE	/* message parameter: terminal line */
! #define TTY_REQUEST	COUNT	/* message parameter: ioctl request code */
! #define TTY_SPEK	POSITION/* message parameter: ioctl speed, erasing */
! #define TTY_PGRP 	m2_i3	/* message parameter: process group */	
! 
! /*===========================================================================*
!  *                  	   Messages for networking layer		     *
!  *===========================================================================*/
! 
! /* Base type for data link layer requests and responses. */
! #define DL_RQ_BASE	0x200		
! #define DL_RS_BASE	0x280		
! 
! /* Message types for data link layer requests. */
! #define DL_CONF		(DL_RQ_BASE + 0)
! #define DL_GETSTAT_S	(DL_RQ_BASE + 1)
! #define DL_WRITEV_S	(DL_RQ_BASE + 2)
! #define DL_READV_S	(DL_RQ_BASE + 3)
! 
! /* Message type for data link layer replies. */
! #define DL_CONF_REPLY	(DL_RS_BASE + 0)
! #define DL_STAT_REPLY	(DL_RS_BASE + 1)
! #define DL_TASK_REPLY	(DL_RS_BASE + 2)
! 
! /* Field names for data link layer messages. */
! #define DL_COUNT	m2_i3
! #define DL_MODE		m2_l1
! #define DL_FLAGS	m2_l1
! #define DL_GRANT	m2_l2
! #define DL_STAT		m3_i1
! #define DL_HWADDR	m3_ca1
! 
! /* Bits in 'DL_FLAGS' field of DL replies. */
! #  define DL_NOFLAGS		0x00
! #  define DL_PACK_SEND		0x01
! #  define DL_PACK_RECV		0x02
! 
! /* Bits in 'DL_MODE' field of DL requests. */
! #  define DL_NOMODE		0x0
! #  define DL_PROMISC_REQ	0x1
! #  define DL_MULTI_REQ		0x2
! #  define DL_BROAD_REQ		0x4
! 
! /*===========================================================================*
!  *                  SYSTASK request types and field names                    *
!  *===========================================================================*/
! 
! /* System library calls are dispatched via a call vector, so be careful when 
!  * modifying the system call numbers. The numbers here determine which call
!  * is made from the call vector.
!  */ 
! #define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
! 
! #  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
! #  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
! #  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
! #  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
! #  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
! #  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
! #  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
! 
! #  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
! #  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
! #  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
! #  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
! 
! #  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
! 
! #  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
! #  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
! #  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
! #  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
! #  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
! 
! #  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
! #  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
! #  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
! #  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
! #  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
! 
! #  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
! #  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
! #  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
! #  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
! #  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
! #  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
! #  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
! #  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
! #  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
! #  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
! 
! #  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
! #  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
! #  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
! 
! #  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
! 
! #  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
! #  define SYS_SYSCTL     (KERNEL_CALL + 44)	/* sys_sysctl() */
! 
! #  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
! #  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
! #  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
! #  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
! 
! #  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
! #  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
! 
! #  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
! #  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
! 
! #  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
! 
! /* Total */
! #define NR_SYS_CALLS	57	/* number of kernel calls */
! 
! #define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
! 
! /* Basic kernel calls allowed to every system process. */
! #define SYS_BASIC_CALLS \
!     SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
!     SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
!     SYS_PROFBUF, SYS_SYSCTL, SYS_STATECTL, SYS_SAFEMEMSET
! 
! /* Field names for SYS_MEMSET. */
! #define MEM_PTR		m2_p1	/* base */
! #define MEM_COUNT	m2_l1	/* count */
! #define MEM_PATTERN	m2_l2   /* pattern to write */
! #define MEM_PROCESS	m2_i1	/* NONE (phys) or process id (vir) */
! 
! /* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
! #define DIO_REQUEST	m2_i3	/* device in or output */
! #   define _DIO_INPUT		0x001
! #   define _DIO_OUTPUT		0x002
! #   define _DIO_DIRMASK		0x00f
! #   define _DIO_BYTE		0x010
! #   define _DIO_WORD		0x020
! #   define _DIO_LONG		0x030
! #   define _DIO_TYPEMASK	0x0f0
! #   define _DIO_SAFE		0x100
! #   define _DIO_SAFEMASK	0xf00
! #   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
! #   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
! #   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
! #   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
! #   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
! #   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
! #   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
! #   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
! #   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
! #define DIO_PORT	m2_l1	/* single port address */
! #define DIO_VALUE	m2_l2	/* single I/O value */
! #define DIO_VEC_ADDR	m2_p1   /* address of buffer or (p,v)-pairs */
! #define DIO_VEC_SIZE	m2_l2   /* number of elements in vector */
! #define DIO_VEC_ENDPT	m2_i2   /* number of process where vector is */
! #define DIO_OFFSET	m2_i1	/* offset from grant */
! 
! /* Field names for SYS_SETALARM. */
! #define ALRM_EXP_TIME   m2_l1	/* expire time for the alarm call */
! #define ALRM_ABS_TIME   m2_i2	/* set to 1 to use absolute alarm time */
! #define ALRM_TIME_LEFT  m2_l1	/* how many ticks were remaining */
! 
! /* Field names for SYS_IRQCTL. */
! #define IRQ_REQUEST     m5_s1	/* what to do? */
! #  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
! #  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
! #  define IRQ_ENABLE        3	/* enable interrupts */
! #  define IRQ_DISABLE       4	/* disable interrupts */
! #define IRQ_VECTOR	m5_s2   /* irq vector */
! #define IRQ_POLICY	m5_i1   /* options for IRQCTL request */
! #  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
! #  define IRQ_BYTE      0x100	/* byte values */      
! #  define IRQ_WORD      0x200	/* word values */
! #  define IRQ_LONG      0x400	/* long values */
! #define IRQ_HOOK_ID	m5_l3   /* id of irq hook at kernel */
! 
! /* Field names for SYS_ABORT. */
! #define ABRT_HOW	m1_i1	/* RBT_REBOOT, RBT_HALT, etc. */
! 
! /* Field names for SYS_IOPENABLE. */
! #define IOP_ENDPT	m2_l1	/* target endpoint */
! 
! /* Field names for _UMAP, _VIRCOPY, _PHYSCOPY. */
! #define CP_SRC_ENDPT	m5_i1	/* process to copy from */
! #define CP_SRC_ADDR	m5_l1	/* address where data come from */
! #define CP_DST_ENDPT	m5_i2	/* process to copy to */
! #define CP_DST_ADDR	m5_l2	/* address where data go to */
! #define CP_NR_BYTES	m5_l3	/* number of bytes to copy */
! 
! #define UMAP_SEG 	m5_s1
! 
! /* only used for backwards compatability */
! #define CP_SRC_SPACE_OBSOLETE 	m5_s1	/* T or D space (stack is also D) */
! #define CP_DST_SPACE_OBSOLETE	m5_s2	/* T or D space (stack is also D) */
! 
! /* Field names for SYS_VUMAP. */
! #define VUMAP_ENDPT	m10_i1	/* grant owner, or SELF for local addresses */
! #define VUMAP_VADDR	m10_l1	/* address of virtual (input) vector */
! #define VUMAP_VCOUNT	m10_i2	/* number of elements in virtual vector */
! #define VUMAP_OFFSET	m10_l2	/* offset into first entry of input vector */
! #define VUMAP_ACCESS	m10_i3	/* access requested for input (VUA_ flags) */
! #define VUMAP_PADDR	m10_l3	/* address of physical (output) vector */
! #define VUMAP_PMAX	m10_i4	/* max number of physical vector elements */
! #define VUMAP_PCOUNT	m10_i1	/* upon return: number of elements filled */
! 
! /* Field names for SYS_GETINFO. */
! #define I_REQUEST      m7_i3	/* what info to get */
! #   define GET_KINFO	   0	/* get kernel information structure */
! #   define GET_IMAGE	   1	/* get system image table */
! #   define GET_PROCTAB	   2	/* get kernel process table */
! #   define GET_RANDOMNESS  3	/* get randomness buffer */
! #   define GET_MONPARAMS   4	/* get monitor parameters */
! #   define GET_KENV	   5	/* get kernel environment string */
! #   define GET_IRQHOOKS	   6	/* get the IRQ table */
! #   define GET_PRIVTAB	   8	/* get kernel privileges table */
! #   define GET_KADDRESSES  9	/* get various kernel addresses */
! #   define GET_SCHEDINFO  10	/* get scheduling queues */
! #   define GET_PROC 	  11	/* get process slot if given process */
! #   define GET_MACHINE 	  12	/* get machine information */
! #   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
! #   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
! #   define GET_LOADINFO   15	/* get load average information */
! #   define GET_IRQACTIDS  16	/* get the IRQ masks */
! #   define GET_PRIV	  17	/* get privilege structure */
! #   define GET_HZ	  18	/* get HZ value */
! #   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
! #   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
! #   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
! #   define GET_CPUINFO    23    /* get information about cpus */
! #   define GET_REGS	  24	/* get general process registers */
! #define I_ENDPT        m7_i4	/* calling process (may only be SELF) */
! #define I_VAL_PTR      m7_p1	/* virtual address at caller */ 
! #define I_VAL_LEN      m7_i1	/* max length of value */
! #define I_VAL_PTR2     m7_p2	/* second virtual address */ 
! #define I_VAL_LEN2_E   m7_i2	/* second length, or proc nr */
! 
! /* GET_WHOAMI fields. */
! #define GIWHO_EP	m3_i1
! #define GIWHO_NAME 	m3_ca1
! #define GIWHO_PRIVFLAGS	m3_i2
! 
! /* Field names for SYS_TIMES. */
! #define T_ENDPT		m4_l1	/* process to request time info for */
! #define T_USER_TIME	m4_l1	/* user time consumed by process */
! #define T_SYSTEM_TIME	m4_l2	/* system time consumed by process */
! #define T_BOOTTIME	m4_l3	/* Boottime in seconds (also for SYS_STIME) */
! #define T_BOOT_TICKS	m4_l5	/* number of clock ticks since boot time */
! 
! /* Field names for SYS_TRACE, SYS_PRIVCTL, SYS_STATECTL. */
! #define CTL_ENDPT      m2_i1	/* process number of the caller */
! #define CTL_REQUEST    m2_i2	/* server control request */
! #define CTL_ARG_PTR    m2_p1	/* pointer to argument */
! #define CTL_ADDRESS    m2_l1	/* address at traced process' space */
! #define CTL_DATA       m2_l2	/* data field for tracing */
! 
! /* SYS_PRIVCTL with CTL_REQUEST == SYS_PRIV_QUERY_MEM */
! #define CTL_PHYSSTART  m2_l1	/* physical memory start in bytes*/
! #define CTL_PHYSLEN    m2_l2	/* length in bytes */
! 
! /* Subfunctions for SYS_PRIVCTL */
! #define SYS_PRIV_ALLOW		1	/* Allow process to run */
! #define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
! #define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
! #define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
! #define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
! #define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
! 					 */
! #define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
! #define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
! #define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
! #define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
! 
! /* Field names for SYS_SETGRANT */
! #define SG_ADDR		m2_p1	/* address */
! #define SG_SIZE		m2_i2	/* no. of entries */
! 
! /* Field names for SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
! #define SIG_ENDPT      m2_i1	/* process number for inform */
! #define SIG_NUMBER     m2_i2	/* signal number to send */
! #define SIG_FLAGS      m2_i3	/* signal flags field */
! #define SIG_MAP        m2_l1	/* used by kernel to pass signal bit map */
! #define SIG_CTXT_PTR   m2_p1	/* pointer to info to restore signal context */
! 
! /* Field names for SYS_FORK, _EXEC, _EXIT, GETMCONTEXT, SETMCONTEXT.*/
! #define PR_ENDPT        m1_i1	/* indicates a process */
! #define PR_PRIORITY     m1_i2	/* process priority */
! #define PR_SLOT         m1_i2	/* indicates a process slot */
! #define PR_STACK_PTR    m1_p1	/* used for stack ptr in sys_exec, sys_getsp */
! #define PR_NAME_PTR     m1_p2	/* tells where program name is for dmp */
! #define PR_IP_PTR       m1_p3	/* initial value for ip after exec */
! #define PR_FORK_FLAGS	m1_i3	/* optional flags for fork operation */
! #define PR_FORK_MSGADDR m1_p1	/* reply message address of forked child */
! #define PR_CTX_PTR	m1_p1	/* pointer to mcontext_t structure */
! 
! /* Field names for EXEC sent from userland to PM. */
! #define PMEXEC_FLAGS	m1_i3	/* PMEF_* */
! 
! #define PMEF_AUXVECTORS	20
! #define PMEF_EXECNAMELEN1 256
! #define PMEF_AUXVECTORSPACE 0x01 /* space for PMEF_AUXVECTORS on stack */
! #define PMEF_EXECNAMESPACE1 0x02 /* space for PMEF_EXECNAMELEN1 execname */
! 
! /* Flags for PR_FORK_FLAGS. */
! #define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
! 
! /* Field names for SYS_INT86 */
! #define INT86_REG86    m1_p1	/* pointer to registers */
! 
! /* Field names for SYS_SAFECOPY* */
! #define SCP_FROM_TO	m2_i1	/* from/to whom? */
! #define SCP_SEG_OBSOLETE m2_i2	/* my own segment */
! #define SCP_GID		m2_i3	/* grant id */
! #define SCP_OFFSET	m2_l1	/* offset within grant */
! #define SCP_ADDRESS	m2_p1	/* my own address */
! #define SCP_BYTES	m2_l2	/* bytes from offset */
! 
! /* SYS_SAFEMEMSET */
! #define SMS_DST		m2_i1	/* dst endpoint */
! #define SMS_GID		m2_i3	/* grant id */
! #define SMS_OFFSET	m2_l1	/* offset within grant */
! #define SMS_BYTES	m2_l2	/* bytes from offset */
! #define SMS_PATTERN	m2_i2	/* memset() pattern */
! 
! /* Field names for SYS_VSAFECOPY* */
! #define VSCP_VEC_ADDR	m2_p1	/* start of vector */
! #define VSCP_VEC_SIZE	m2_l2	/* elements in vector */
! 
! #define SMAP_SEG_OBSOLETE	m2_p1
! 
! /* Field names for SYS_SPROF, _CPROF, _PROFBUF. */
! #define PROF_ACTION    m7_i1    /* start/stop/reset/get */
! #define PROF_MEM_SIZE  m7_i2    /* available memory for data */ 
! #define PROF_FREQ      m7_i3    /* sample frequency */
! #define PROF_ENDPT     m7_i4    /* endpoint of caller */
! #define PROF_INTR_TYPE m7_i5    /* interrupt type */
! #define PROF_CTL_PTR   m7_p1    /* location of info struct */
! #define PROF_MEM_PTR   m7_p2    /* location of profiling data */
! 
! /* Field names for SYS_READBIOS. */
! #define RDB_SIZE	m2_i1
! #define RDB_ADDR	m2_l1
! #define RDB_BUF		m2_p1
! 
! /* Field names for SYS_VMCTL. */
! #define SVMCTL_WHO	m1_i1
! #define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
! #define SVMCTL_VALUE	m1_i3
! #define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
! #define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
! #define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
! #define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
! #define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
! #define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
! #define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
! #define SVMCTL_MAP_VIR_ADDR	m1_p1
! #define SVMCTL_PTROOT		m1_i3
! #define SVMCTL_PTROOT_V		m1_p1
! 
! /* Reply message for VMCTL_KERN_PHYSMAP */
! #define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
! #define SVMCTL_MAP_PHYS_ADDR	m2_l1
! #define SVMCTL_MAP_PHYS_LEN	m2_l2
! 
! #define VMMF_UNCACHED		(1L << 0)
! #define VMMF_USER		(1L << 1)
! #define VMMF_WRITE		(1L << 2)
! #define VMMF_GLO		(1L << 3)
! 
! /* Values for SVMCTL_PARAM. */
! #define VMCTL_CLEAR_PAGEFAULT	12
! #define VMCTL_GET_PDBR		13
! #define VMCTL_MEMREQ_GET 	14
! #define VMCTL_MEMREQ_REPLY	15
! #define VMCTL_NOPAGEZERO	18
! #define VMCTL_I386_KERNELLIMIT	19
! #define VMCTL_I386_INVLPG	25
! #define VMCTL_FLUSHTLB		26
! #define VMCTL_KERN_PHYSMAP	27
! #define VMCTL_KERN_MAP_REPLY	28
! #define VMCTL_SETADDRSPACE	29
! #define VMCTL_VMINHIBIT_SET	30
! #define VMCTL_VMINHIBIT_CLEAR	31
! #define VMCTL_CLEARMAPCACHE	32
! #define VMCTL_BOOTINHIBIT_CLEAR	33
! 
! /* Codes and field names for SYS_SYSCTL. */
! #define SYSCTL_CODE		m1_i1	/* SYSCTL_CODE_* below */
! #define SYSCTL_ARG1		m1_p1
! #define SYSCTL_ARG2		m1_i2
! #define SYSCTL_CODE_DIAG	1	/* Print diagnostics. */
! #define SYSCTL_CODE_STACKTRACE	2	/* Print process stack. */
! #define DIAG_BUFSIZE	(80*25)
! 
! /* Field names for SYS_VTIMER. */
! #define VT_WHICH	m2_i1	/* which timer to set/retrieve */
! #  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
! #  define VT_PROF           2	/* the ITIMER_PROF timer */
! #define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
! #define VT_VALUE	m2_l1	/* new/previous value of the timer */
! #define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
! 
! /* Field names for SYS_RUNCTL. */
! #define RC_ENDPT	m1_i1	/* which process to stop or resume */
! #define RC_ACTION	m1_i2	/* set or clear stop flag */
! #  define RC_STOP           0	/* stop the process */
! #  define RC_RESUME         1	/* clear the stop flag */
! #define RC_FLAGS	m1_i3	/* request flags */
! #  define RC_DELAY          1	/* delay stop if process is sending */
! 
! /* Field names for SYS_UPDATE. */
! #define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
! #define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
! 
! /* Subfunctions for SYS_STATECTL */
! #define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
! 
! /* Subfunctions for SYS_SCHEDCTL */
! #define SCHEDCTL_FLAGS		m9_l1	/* flags for setting the scheduler */
! #  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
! 					 * RTS_NO_QUANTUM; otherwise caller is 
! 					 * marked scheduler 
! 					 */
! #define SCHEDCTL_ENDPOINT	m9_l2	/* endpt of process to be scheduled */
! #define SCHEDCTL_QUANTUM	m9_l3   /* current scheduling quantum */
! #define SCHEDCTL_PRIORITY	m9_s4   /* current scheduling priority */
! #define SCHEDCTL_CPU		m9_l5   /* where to place this process */
! 
! /*===========================================================================*
!  *                Messages for the Reincarnation Server 		     *
!  *===========================================================================*/
! 
! #define RS_RQ_BASE		0x700
! 
! #define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
! #define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
! #define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
! #define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
! #define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
! #define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
! #define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
! #define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
! 
! #define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
! 
! #define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
! #define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
! 
! #  define RS_CMD_ADDR		m1_p1		/* command string */
! #  define RS_CMD_LEN		m1_i1		/* length of command */
! #  define RS_PERIOD 	        m1_i2		/* heartbeat period */
! #  define RS_DEV_MAJOR          m1_i3           /* major device number */
! 
! #  define RS_ENDPOINT		m1_i1		/* endpoint number in reply */
! 
! #  define RS_NAME		m1_p1		/* name */
! #  define RS_NAME_LEN		m1_i1		/* namelen */
! 
! #  define RS_INIT_RESULT        m7_i1           /* init result */
! #  define RS_INIT_TYPE          m7_i2           /* init type */
! #  define RS_INIT_RPROCTAB_GID  m7_i3           /* init rproc table gid */
! #  define RS_INIT_OLD_ENDPOINT  m7_i4           /* init old endpoint */
! 
! #  define RS_LU_RESULT          m1_i1           /* live update result */
! #  define RS_LU_STATE           m1_i2           /* state required to update */
! #  define RS_LU_PREPARE_MAXTIME m1_i3           /* the max time to prepare */
! 
! /*===========================================================================*
!  *                Messages for the Data Store Server			     *
!  *===========================================================================*/
! 
! #define DS_RQ_BASE		0x800
! 
! #define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
! #define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
! #define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
! #define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
! #define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
! #define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
! #define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
! 
! /* DS field names */
! #  define DS_KEY_GRANT		m2_i1		/* key for the data */
! #  define DS_KEY_LEN		m2_s1		/* length of key incl. '\0' */
! #  define DS_FLAGS		m2_i2		/* flags provided by caller */
! 
! #  define DS_VAL		m2_l1		/* data (u32, char *, etc.) */
! #  define DS_VAL_LEN		m2_l2		/* data length */
! #  define DS_NR_SNAPSHOT	m2_i3		/* number of snapshot */
! #  define DS_OWNER		m2_i3		/* owner */
! 
! /*===========================================================================*
!  *                Miscellaneous messages used by TTY			     *
!  *===========================================================================*/
! 
! /* Miscellaneous request types and field names, e.g. used by IS server. */
! #define FKEY_CONTROL 		98  	/* control a function key at the TTY */
! #  define FKEY_REQUEST	     m2_i1	/* request to perform at TTY */
! #  define    FKEY_MAP		10	/* observe function key */
! #  define    FKEY_UNMAP		11	/* stop observing function key */
! #  define    FKEY_EVENTS	12	/* request open key presses */
! #  define FKEY_FKEYS	      m2_l1	/* F1-F12 keys pressed */
! #  define FKEY_SFKEYS	      m2_l2	/* Shift-F1-F12 keys pressed */
! 
! /*===========================================================================*
!  *                Messages used between PM and VFS			     *
!  *===========================================================================*/
! 
! #define PM_RQ_BASE	0x900
! #define PM_RS_BASE	0x980
! 
! /* Requests from PM to VFS */
! #define PM_INIT		(PM_RQ_BASE + 0)	/* Process table exchange */
! #define PM_SETUID	(PM_RQ_BASE + 1)	/* Set new user ID */
! #define PM_SETGID	(PM_RQ_BASE + 2)	/* Set group ID */
! #define PM_SETSID	(PM_RQ_BASE + 3)	/* Set session leader */
! #define PM_EXIT		(PM_RQ_BASE + 4)	/* Process exits */
! #define PM_DUMPCORE	(PM_RQ_BASE + 5)	/* Process is to dump core */
! #define PM_EXEC		(PM_RQ_BASE + 6)	/* Forwarded exec call */
! #define PM_FORK		(PM_RQ_BASE + 7)	/* Newly forked process */
! #define PM_SRV_FORK	(PM_RQ_BASE + 8)	/* fork for system services */
! #define PM_UNPAUSE	(PM_RQ_BASE + 9)	/* Interrupt process call */
! #define PM_REBOOT	(PM_RQ_BASE + 10)	/* System reboot */
! #define PM_SETGROUPS	(PM_RQ_BASE + 11)	/* Tell VFS about setgroups */
! 
! /* Replies from VFS to PM */
! #define PM_SETUID_REPLY	(PM_RS_BASE + 1)
! #define PM_SETGID_REPLY	(PM_RS_BASE + 2)
! #define PM_SETSID_REPLY	(PM_RS_BASE + 3)
! #define PM_EXIT_REPLY	(PM_RS_BASE + 4)
! #define PM_CORE_REPLY	(PM_RS_BASE + 5)
! #define PM_EXEC_REPLY	(PM_RS_BASE + 6)
! #define PM_FORK_REPLY	(PM_RS_BASE + 7)
! #define PM_SRV_FORK_REPLY	(PM_RS_BASE + 8)
! #define PM_UNPAUSE_REPLY	(PM_RS_BASE + 9)
! #define PM_REBOOT_REPLY	(PM_RS_BASE + 10)
! #define PM_SETGROUPS_REPLY	(PM_RS_BASE + 11)
! 
! /* Standard parameters for all requests and replies, except PM_REBOOT */
! #  define PM_PROC		m7_i1	/* process endpoint */
! 
! /* Additional parameters for PM_INIT */
! #  define PM_SLOT		m7_i2	/* process slot number */
! #  define PM_PID		m7_i3	/* process pid */
! 
! /* Additional parameters for PM_SETUID and PM_SETGID */
! #  define PM_EID		m7_i2	/* effective user/group id */
! #  define PM_RID		m7_i3	/* real user/group id */
! 
! /* Additional parameter for PM_SETGROUPS */
! #  define PM_GROUP_NO		m7_i2	/* number of groups */
! #  define PM_GROUP_ADDR		m7_p1	/* struct holding group data */
! 
! /* Additional parameters for PM_EXEC */
! #  define PM_PATH		m7_p1	/* executable */
! #  define PM_PATH_LEN		m7_i2	/* length of path including
! 					 * terminating null character
! 					 */
! #  define PM_FRAME		m7_p2	/* arguments and environment */
! #  define PM_FRAME_LEN		m7_i3	/* size of frame */
! #  define PM_EXECFLAGS		m7_i4	/* PMEXEC_FLAGS */
! 
! /* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
! #  define PM_STATUS		m7_i2	/* OK or failure */
! #  define PM_PC			m7_p1	/* program counter */
! #  define PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
! 
! /* Additional parameters for PM_FORK and PM_SRV_FORK */
! #  define PM_PPROC		m7_i2	/* parent process endpoint */
! #  define PM_CPID		m7_i3	/* child pid */
! #  define PM_REUID		m7_i4	/* real and effective uid */
! #  define PM_REGID		m7_i5	/* real and effective gid */
! 
! /* Additional parameters for PM_DUMPCORE */
! #  define PM_TERM_SIG		m7_i2	/* process's termination signal */
! #  define PM_TRACED_PROC	m7_i3	/* required for T_DUMPCORE */
! 
! /* Parameters for the EXEC_NEWMEM call */
! #define EXC_NM_PROC	m1_i1		/* process that needs new map */
! #define EXC_NM_PTR	m1_p1		/* parameters in struct exec_info */
! /* Results:
!  * the status will be in m_type.
!  * the top of the stack will be in m1_i1.
!  * the following flags will be in m1_i2:
!  */
! #define EXC_NM_RF_LOAD_TEXT	1	/* Load text segment (otherwise the
! 					 * text segment is already present)
! 					 */
! #define EXC_NM_RF_ALLOW_SETUID	2	/* Setuid execution is allowed (tells
! 					 * FS to update its uid and gid 
! 					 * fields.
! 					 */
! #define EXC_NM_RF_FULLVM	4	
! 
! /* Parameters for the EXEC_RESTART call */
! #define EXC_RS_PROC	m1_i1		/* process that needs to be restarted */
! #define EXC_RS_RESULT	m1_i2		/* result of the exec */
! #define EXC_RS_PC	m1_p1		/* program counter */
! 
! /*===========================================================================*
!  *                Messages used from VFS to file servers		     *
!  *===========================================================================*/
! 
! #define VFS_BASE	0xA00		/* Requests sent by VFS to filesystem
! 					 * implementations. See <minix/vfsif.h>
! 					 */
! 
! /*===========================================================================*
!  *                Common requests and miscellaneous field names		     *
!  *===========================================================================*/
! 
! #define COMMON_RQ_BASE		0xE00
! 
! /* Field names for system signals (sent by a signal manager). */
! #define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
! #	define SIGS_SIG_NUM      m2_i1
! 
! /* Common request to all processes: gcov data. */
! #define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
! #	define GCOV_GRANT   m1_i2
! #	define GCOV_PID     m1_i3
! #	define GCOV_BUFF_P  m1_p1
! #	define GCOV_BUFF_SZ m1_i1
! 
! /* Common request to several system servers: retrieve system information. */
! #define COMMON_GETSYSINFO	(COMMON_RQ_BASE+2)
! #	define SI_WHAT		m1_i1
! #	define SI_WHERE		m1_p1
! #	define SI_SIZE		m1_i2
! 
! /* PM field names */
! /* BRK */
! #define PMBRK_ADDR				m1_p1
! 
! /* TRACE */
! #define PMTRACE_ADDR				m2_l1
! 
! #define PM_ENDPT				m1_i1
! #define PM_PENDPT				m1_i2
! 
! #define PM_NUID					m2_i1
! #define PM_NGID					m2_i2
! 
! #define PM_GETSID_PID				m1_i1
! 
! /* Field names for SELECT (FS). */
! #define SEL_NFDS       m8_i1
! #define SEL_READFDS    m8_p1
! #define SEL_WRITEFDS   m8_p2
! #define SEL_ERRORFDS   m8_p3
! #define SEL_TIMEOUT    m8_p4
! 
! /* Field names for the fstatvfs call */
! #define FSTATVFS_FD m1_i1
! #define FSTATVFS_BUF m1_p1
! 
! /* Field names for the statvfs call */
! #define STATVFS_LEN m1_i1
! #define STATVFS_NAME m1_p1
! #define STATVFS_BUF m1_p2
! 
! /*===========================================================================*
!  *                Messages for VM server				     *
!  *===========================================================================*/
! #define VM_RQ_BASE		0xC00
! 
! /* Calls from PM */
! #define VM_EXIT			(VM_RQ_BASE+0)
! #	define VME_ENDPOINT		m1_i1
! #define VM_FORK			(VM_RQ_BASE+1)
! #	define VMF_ENDPOINT		m1_i1
! #	define VMF_SLOTNO		m1_i2
! #	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
! #define VM_BRK			(VM_RQ_BASE+2)
! #	define VMB_ENDPOINT		m1_i1
! #	define VMB_ADDR			m1_p1
! #	define VMB_RETADDR		m1_p2	/* result */
! #define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
! #	define VMEN_ENDPOINT		m1_i1
! #	define VMEN_ARGSPTR		m1_p1
! #	define VMEN_ARGSSIZE		m1_i2
! #	define VMEN_FLAGS		m1_i3	/* result */
! #	define VMEN_STACK_TOP		m1_p2	/* result */
! #define VM_WILLEXIT		(VM_RQ_BASE+5)
! #	define VMWE_ENDPOINT		m1_i1
! 
! /* General calls. */
! #define VM_MMAP			(VM_RQ_BASE+10)
! #	define VMM_ADDR			m5_l1
! #	define VMM_LEN			m5_l2
! #	define VMM_PROT			m5_s1
! #	define VMM_FLAGS		m5_s2
! #	define VMM_FD			m5_i1
! #	define VMM_OFFSET		m5_i2
! #	define VMM_FORWHOM		m5_l3
! #	define VMM_RETADDR		m5_l1	/* result */
! #define VM_UMAP			(VM_RQ_BASE+11)
! #	define VMU_SEG			m1_i1
! #	define VMU_OFFSET		m1_p1
! #	define VMU_LENGTH		m1_p2
! #	define VMU_RETADDR		m1_p3
! 
! /* to VM: inform VM about a region of memory that is used for
!  * bus-master DMA
!  */
! #define VM_ADDDMA	(VM_RQ_BASE+12)
! #	define VMAD_EP			m2_i1
! #	define VMAD_START		m2_l1
! #	define VMAD_SIZE		m2_l2
! 
! /* to VM: inform VM that a region of memory that is no longer
!  * used for bus-master DMA
!  */
! #define VM_DELDMA       (VM_RQ_BASE+13)
! #	define VMDD_EP			m2_i1
! #	define VMDD_START		m2_l1
! #	define VMDD_SIZE		m2_l2
! 
! /* to VM: ask VM for a region of memory that should not
!  * be used for bus-master DMA any longer
!  */
! #define VM_GETDMA       (VM_RQ_BASE+14)
! #	define VMGD_PROCP		m2_i1
! #	define VMGD_BASEP		m2_l1
! #	define VMGD_SIZEP		m2_l2
! 
! #define VM_MAP_PHYS		(VM_RQ_BASE+15)
! #	define VMMP_EP			m1_i1
! #	define VMMP_PHADDR		m1_p2
! #	define VMMP_LEN			m1_i2
! #	define VMMP_VADDR_REPLY		m1_p3
! 
! #define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
! #	define VMUP_EP			m1_i1
! #	define VMUP_VADDR		m1_p1
! 
! #define VM_MUNMAP		(VM_RQ_BASE+17)
! #	define VMUM_ADDR		m1_p1
! #	define VMUM_LEN			m1_i1
! 
! /* To VM: forget all my yielded blocks. */
! #define VM_FORGETBLOCKS		(VM_RQ_BASE+22)
! 
! /* To VM: forget this block. */
! #define VM_FORGETBLOCK		(VM_RQ_BASE+23)
! #define VMFB_IDHI			m1_i1
! #define VMFB_IDLO			m1_i2
! 
! /* To VM: combined yield+get call. */
! #define VM_YIELDBLOCKGETBLOCK	(VM_RQ_BASE+25)
! #define VMYBGB_VADDR			m2_p1
! #define VMYBGB_GETIDHI			m2_i1
! #define VMYBGB_GETIDLO			m2_i2
! #define VMYBGB_LEN			m2_i3
! #define VMYBGB_YIELDIDHI		m2_l1
! #define VMYBGB_YIELDIDLO		m2_l2
! 
! /* Calls from VFS. */
! #	define VMV_ENDPOINT		m1_i1	/* for all VM_VFS_REPLY_* */
! #define VM_VFS_REPLY_OPEN	(VM_RQ_BASE+30)
! #	define VMVRO_FD			m1_i2
! #define VM_VFS_REPLY_MMAP	(VM_RQ_BASE+31)
! #define VM_VFS_REPLY_CLOSE	(VM_RQ_BASE+32)
! 
! #define VM_REMAP		(VM_RQ_BASE+33)
! #	define VMRE_D			m1_i1
! #	define VMRE_S			m1_i2
! #	define VMRE_DA			m1_p1
! #	define VMRE_SA			m1_p2
! #	define VMRE_RETA		m1_p3
! #	define VMRE_SIZE		m1_i3
! #	define VMRE_FLAGS		m1_i3
! 
! #define VM_SHM_UNMAP		(VM_RQ_BASE+34)
! #	define VMUN_ENDPT		m2_i1
! #	define VMUN_ADDR		m2_l1
! 
! #define VM_GETPHYS		(VM_RQ_BASE+35)
! #	define VMPHYS_ENDPT		m2_i1
! #	define VMPHYS_ADDR		m2_l1
! #	define VMPHYS_RETA		m2_l2
! 
! #define VM_GETREF		(VM_RQ_BASE+36)
! #	define VMREFCNT_ENDPT		m2_i1
! #	define VMREFCNT_ADDR		m2_l1
! #	define VMREFCNT_RETC		m2_i2
! 
! #define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
! #	define VM_RS_NR			m2_i1
! #	define VM_RS_BUF		m2_l1
! 
! #define VM_QUERY_EXIT		(VM_RQ_BASE+38)
! #	define VM_QUERY_RET_PT	m2_i1
! #	define VM_QUERY_IS_MORE	m2_i2
! 
! #define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
! #	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
! #	define VM_NOTIFY_SIG_IPC	m1_i2
! 
! #define VM_INFO			(VM_RQ_BASE+40)
! #	define VMI_WHAT			m2_i1
! #	define VMI_EP			m2_i2
! #	define VMI_COUNT		m2_i3
! #	define VMI_PTR			m2_p1
! #	define VMI_NEXT			m2_l1
! 
! /* VMI_WHAT values. */
! #define VMIW_STATS			1
! #define VMIW_USAGE			2
! #define VMIW_REGION			3
! 
! #define VM_RS_UPDATE		(VM_RQ_BASE+41)
! #	define VM_RS_SRC_ENDPT		m1_i1
! #	define VM_RS_DST_ENDPT		m1_i2
! 
! #define VM_RS_MEMCTL		(VM_RQ_BASE+42)
! #	define VM_RS_CTL_ENDPT		m1_i1
! #	define VM_RS_CTL_REQ		m1_i2
! #		define VM_RS_MEM_PIN	    0	/* pin memory */
! #		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
! 
! #define VM_WATCH_EXIT		(VM_RQ_BASE+43)
! #	define VM_WE_EP		m1_i1
! 
! #define VM_REMAP_RO		(VM_RQ_BASE+44)
! /* same args as VM_REMAP */
! 
! #define VM_PROCCTL		(VM_RQ_BASE+45)
! #define VMPCTL_PARAM		m1_i1
! #define VMPCTL_WHO		m1_i2
! 
! #define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
! 
! /* Total. */
! #define NR_VM_CALLS				46
! #define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
! 
! /* not handled as a normal VM call, thus at the end of the reserved rage */
! #define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
! #	define VPF_ADDR		m1_i1
! #	define VPF_FLAGS	m1_i2
! 
! /* Basic vm calls allowed to every process. */
! #define VM_BASIC_CALLS \
!     VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, \
!     VM_FORGETBLOCKS, VM_FORGETBLOCK, VM_YIELDBLOCKGETBLOCK, VM_INFO
! 
! /*===========================================================================*
!  *                Messages for IPC server				     *
!  *===========================================================================*/
! #define IPC_BASE	0xD00
! 
! /* Shared Memory */
! #define IPC_SHMGET	(IPC_BASE+1)
! #	define SHMGET_KEY	m2_l1
! #	define SHMGET_SIZE	m2_l2
! #	define SHMGET_FLAG	m2_i1
! #	define SHMGET_RETID	m2_i2
! #define IPC_SHMAT	(IPC_BASE+2)
! #	define SHMAT_ID		m2_i1
! #	define SHMAT_ADDR	m2_l1
! #	define SHMAT_FLAG	m2_i2
! #	define SHMAT_RETADDR	m2_l2
! #define IPC_SHMDT	(IPC_BASE+3)
! #	define SHMDT_ADDR	m2_l1
! #define IPC_SHMCTL	(IPC_BASE+4)
! #	define SHMCTL_ID	m2_i1
! #	define SHMCTL_CMD	m2_i2
! #	define SHMCTL_BUF	m2_l1
! #	define SHMCTL_RET	m2_i3
! 
! /* Semaphore */
! #define IPC_SEMGET	(IPC_BASE+5)
! #	define SEMGET_KEY	m2_l1
! #	define SEMGET_NR	m2_i1
! #	define SEMGET_FLAG	m2_i2
! #	define SEMGET_RETID	m2_i3
! #define IPC_SEMCTL	(IPC_BASE+6)
! #	define SEMCTL_ID	m2_i1
! #	define SEMCTL_NUM	m2_i2
! #	define SEMCTL_CMD	m2_i3
! #	define SEMCTL_OPT	m2_l1
! #define IPC_SEMOP	(IPC_BASE+7)
! #	define SEMOP_ID		m2_i1
! #	define SEMOP_OPS	m2_l1
! #	define SEMOP_SIZE	m2_i2
! 
! /*===========================================================================*
!  *                Messages for Scheduling				     *
!  *===========================================================================*/
! #define SCHEDULING_BASE	0xF00
! 
! #define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
! #	define SCHEDULING_ACNT_DEQS		m9_l1
! #	define SCHEDULING_ACNT_IPC_SYNC		m9_l2
! #	define SCHEDULING_ACNT_IPC_ASYNC	m9_l3
! #	define SCHEDULING_ACNT_PREEMPT		m9_l4
! #	define SCHEDULING_ACNT_QUEUE		m9_l5
! #	define SCHEDULING_ACNT_CPU		m9_s1
! #	define SCHEDULING_ACNT_CPU_LOAD		m9_s2
! /* These are used for SYS_SCHEDULE, a reply to SCHEDULING_NO_QUANTUM */
! #	define SCHEDULING_ENDPOINT	m9_l1
! #	define SCHEDULING_QUANTUM	m9_l2
! #	define SCHEDULING_PRIORITY	m9_s1
! #	define SCHEDULING_CPU		m9_l4
! 
! /*
!  * SCHEDULING_START uses _ENDPOINT, _PRIORITY and _QUANTUM from
!  * SCHEDULING_NO_QUANTUM/SYS_SCHEDULE
!  */
! #define SCHEDULING_START	(SCHEDULING_BASE+2)
! #	define SCHEDULING_SCHEDULER	m9_l1 /* Overrides _ENDPOINT on return*/
! #	define SCHEDULING_PARENT	m9_l3
! #	define SCHEDULING_MAXPRIO	m9_l4
! 
! #define SCHEDULING_STOP		(SCHEDULING_BASE+3)
! 
! #define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
! 
! /* SCHEDULING_INHERIT is like SCHEDULING_START, but without _QUANTUM field */
! #define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
! 
! /*===========================================================================*
!  *              Messages for USB                                             *
!  *===========================================================================*/
! 
! #define USB_BASE 0x1100
! 
! /* those are from driver to USBD */
! #define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
! #define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
! #define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
! #define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
! #define USB_REPLY            (USB_BASE +  4) 
! 
! 
! /* those are from USBD to driver */
! #define USB_COMPLETE_URB    (USB_BASE +  6)
! #define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
! #define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
!                                               USB device*/
! #   define USB_GRANT_ID     m4_l1
! #   define USB_GRANT_SIZE   m4_l2
! 
! #   define USB_URB_ID       m4_l1
! #   define USB_RESULT       m4_l2
! #   define USB_DEV_ID       m4_l1
! #   define USB_DRIVER_EP    m4_l2
! #   define USB_INTERFACES   m4_l3
! #   define USB_RB_INIT_NAME m3_ca1
! 
! /*===========================================================================*
!  *              Messages for DeviceManager (s/t like SysFS)                  *
!  *===========================================================================*/
! 
! #define DEVMAN_BASE 0x1200
! 
! #define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
! #define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
! #define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
! #define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
! #define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
! #define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
! 
! #define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
! #define DEVMAN_REPLY       (DEVMAN_BASE + 7)
! 
! #define DEVMAN_BIND        (DEVMAN_BASE + 8)
! #define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
! 
! #   define DEVMAN_GRANT_ID       m4_l1
! #   define DEVMAN_GRANT_SIZE     m4_l2
! 
! #   define DEVMAN_ENDPOINT       m4_l3
! #   define DEVMAN_DEVICE_ID      m4_l2
! #   define DEVMAN_RESULT         m4_l1
! 
! /*===========================================================================*
!  *              TTY INPUT INJECTION                                          *
!  *===========================================================================*/
! 
! #define INPUT_BASE 0x1300
! 
! #define INPUT_EVENT      (INPUT_BASE + 0)
! 
! #	define INPUT_TYPE        m4_l1
! #	define INPUT_CODE        m4_l2
! #	define INPUT_VALUE       m4_l3
! 
! #endif
! 
! /*===========================================================================*
!  *			VFS-FS TRANSACTION IDs				     *
!  *===========================================================================*/
! 
! #define VFS_TRANSACTION_BASE 0x1400
! 
! #define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
! #define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
! 
! /*===========================================================================*
!  *			Messages for block devices			     *
!  *===========================================================================*/
! 
! /* Base type for block device requests and responses. */
! #define BDEV_RQ_BASE	0x1500
! #define BDEV_RS_BASE	0x1580
! 
! #define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
! #define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
! 
! /* Message types for block device requests. */
! #define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
! #define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
! #define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
! #define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
! #define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
! #define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
! #define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
! 
! /* Message types for block device responses. */
! #define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
! 
! /* Field names for block device messages. */
! #define BDEV_MINOR	m10_i1	/* minor device number */
! #define BDEV_STATUS	m10_i1	/* OK or error code */
! #define BDEV_ACCESS	m10_i2	/* access bits for open requests */
! #define BDEV_REQUEST	m10_i2	/* I/O control request */
! #define BDEV_COUNT	m10_i2	/* number of bytes or elements in transfer */
! #define BDEV_GRANT	m10_i3	/* grant ID of buffer or vector */
! #define BDEV_FLAGS	m10_i4	/* transfer flags */
! #define BDEV_ID		m10_l1	/* opaque request ID */
! #define BDEV_POS_LO	m10_l2	/* transfer position (low bits) */
! #define BDEV_POS_HI	m10_l3	/* transfer position (high bits) */
! 
! /* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
! #  define BDEV_NOFLAGS		0x00	/* no flags are set */
! #  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
! 
! /* _MINIX_COM_H */
--- 1,1285 ----
! /* This file defines constants for use in message communication (mostly)
!  * between system processes.
!  *
!  * A number of protocol message request and response types are defined. For
!  * debugging purposes, each protocol is assigned its own unique number range.
!  * The following such message type ranges have been allocated:
!  *
!  *        1 -   0xFF	POSIX requests (see callnr.h)
!  *    0x200 -  0x2FF	Data link layer requests and responses
!  *    0x300 -  0x3FF	Bus controller requests and responses
!  *    0x400 -  0x4FF	Character device requests
!  *    0x500 -  0x5FF	Character device responses
!  *    0x600 -  0x6FF	Kernel calls to SYSTEM task
!  *    0x700 -  0x7FF	Reincarnation Server (RS) requests
!  *    0x800 -  0x8FF	Data Store (DS) requests
!  *    0x900 -  0x9FF	Requests from PM to VFS, and responses
!  *    0xA00 -  0xAFF	Requests from VFS to file systems (see vfsif.h)
!  *    0xB00 -  0xBFF	Requests from VM to VFS
!  *    0xC00 -  0xCFF	Virtual Memory (VM) requests
!  *    0xD00 -  0xDFF	IPC server requests
!  *    0xE00 -  0xEFF	Common system messages (e.g. system signals)
!  *    0xF00 -  0xFFF    Scheduling messages
!  *   0x1000 - 0x10FF	Notify messages
!  *   0x1100 - 0x11FF	USB  
!  *   0x1200 - 0x12FF    Devman
!  *   0x1300 - 0x13FF    TTY Input
!  *   0x1400 - 0x14FF	VFS-FS transaction IDs
!  *   0x1500 - 0x15FF	Block device requests and responses
!  *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
!  *
!  * Zero and negative values are widely used for OK and error responses.
!  */
! 
! #ifndef _MINIX_COM_H
! #define _MINIX_COM_H 
! 
! /*===========================================================================*
!  *          	    		Magic process numbers			     *
!  *===========================================================================*/
! 
! /* These may not be any valid endpoint (see <minix/endpoint.h>). */
! #define ANY	((endpoint_t) 0x7ace)	/* used to indicate 'any process' */
! #define NONE 	((endpoint_t) 0x6ace)   /* used to indicate 'no process at all' */
! #define SELF	((endpoint_t) 0x8ace) 	/* used to indicate 'own process' */
! #define _MAX_MAGIC_PROC (SELF)	/* used by <minix/endpoint.h> 
! 				   to determine generation size */
! 
! /*===========================================================================*
!  *            	Process numbers of processes in the system image	     *
!  *===========================================================================*/
! 
! /* The values of several task numbers depend on whether they or other tasks
!  * are enabled. They are defined as (PREVIOUS_TASK - ENABLE_TASK) in general.
!  * ENABLE_TASK is either 0 or 1, so a task either gets a new number, or gets
!  * the same number as the previous task and is further unused. Note that the
!  * order should correspond to the order in the task table defined in table.c. 
!  */
! 
! /* Kernel tasks. These all run in the same address space. */
! #define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
! #define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
! #define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
! #define SYSTEM  ((endpoint_t) -2) /* request system functionality */
! #define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
! #define HARDWARE     KERNEL	/* for hardware interrupt handlers */
! 
! /* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
! #define MAX_NR_TASKS	1023
! #define NR_TASKS	  5 
! 
! /* User-space processes, that is, device drivers, servers, and INIT. */
! #define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
! #define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
! #define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
! #define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
! #define LOG_PROC_NR  ((endpoint_t) 4)	/* log device driver */
! #define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
! #define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
! #define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
! #define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
! #define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
! #define SCHED_PROC_NR ((endpoint_t) 10)	/* scheduler */
! #define LAST_SPECIAL_PROC_NR	11	/* An untyped version for
!                                            computation in macros.*/
! #define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
!                                                         -- goes multiuser */
! #define NR_BOOT_MODULES (INIT_PROC_NR+1)
! 
! /* Root system process and root user process. */
! #define ROOT_SYS_PROC_NR  RS_PROC_NR
! #define ROOT_USR_PROC_NR  INIT_PROC_NR
! 
! /*===========================================================================*
!  *                	   Kernel notification types                         *
!  *===========================================================================*/
! 
! /* Kernel notification types. In principle, these can be sent to any process,
!  * so make sure that these types do not interfere with other message types.
!  * Notifications are prioritized because of the way they are unhold() and
!  * blocking notifications are delivered. The lowest numbers go first. The
!  * offset are used for the per-process notification bit maps. 
!  */
! #define NOTIFY_MESSAGE		  0x1000
! /* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
! #define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
! #define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
! #define is_ipc_asynch(ipc_status) \
!     (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
! 
! /* Shorthands for message parameters passed with notifications. */
! #define NOTIFY_ARG		m2_l1
! #define NOTIFY_TIMESTAMP	m2_l2
! 
! /*===========================================================================*
!  *                Messages for BUS controller drivers 			     *
!  *===========================================================================*/
! #define BUSC_RQ_BASE	0x300	/* base for request types */
! #define BUSC_RS_BASE	0x380	/* base for response types */
! 
! #define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
! 							 * PCI driver
! 							 */
! #define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
! 							 * vid/did) of the
! 							 * first PCI device
! 							 */
! #define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
! 							 * vid/did) of the
! 							 * next PCI device
! 							 */
! #define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
! 							 * PCI device based on
! 							 * bus/dev/function
! 							 */
! #define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
! 							 * index
! 							 */
! #define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
! #define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
! 							 * attribute value
! 							 */
! #define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
! #define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
! 							 * PCI device
! 							 * (safecopy)
! 							 */
! #define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
! 							 * PCI slot (safecopy)
! 							 */
! #define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
! 							 * driver (safecopy)
! 							 */
! #define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
! 							 * driver 
! 							 */
! #define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
! 							 * Register properties
! 							 */
! #define   BUSC_PGB_DEVIND	m2_i1			/* device index */
! #define   BUSC_PGB_PORT		m2_i2			/* port (BAR offset) */
! #define   BUSC_PGB_BASE		m2_l1			/* BAR base address */
! #define   BUSC_PGB_SIZE		m2_l2			/* BAR size */
! #define   BUSC_PGB_IOFLAG	m2_i1			/* I/O space? */
! #define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
! 							 * a segment of memory
! 							 */
! 
! 
! /*===========================================================================*
!  *                Messages for CHARACTER device drivers			     *
!  *===========================================================================*/
! 
! /* Message types for character device drivers. */
! #define DEV_RQ_BASE   0x400	/* base for character device request types */
! #define DEV_RS_BASE   0x500	/* base for character device response types */
! 
! #define CANCEL       	(DEV_RQ_BASE +  0) /* force a task to cancel */
! #define DEV_OPEN     	(DEV_RQ_BASE +  6) /* open a minor device */
! #define DEV_CLOSE    	(DEV_RQ_BASE +  7) /* close a minor device */
! #define DEV_SELECT	(DEV_RQ_BASE + 12) /* request select() attention */
! #define DEV_STATUS   	(DEV_RQ_BASE + 13) /* request driver status */
! #define DEV_REOPEN     	(DEV_RQ_BASE + 14) /* reopen a minor device */
! 
! #define DEV_READ_S	(DEV_RQ_BASE + 20) /* (safecopy) read from minor */
! #define DEV_WRITE_S   	(DEV_RQ_BASE + 21) /* (safecopy) write to minor */
! #define DEV_SCATTER_S  	(DEV_RQ_BASE + 22) /* (safecopy) write from a vector */
! #define DEV_GATHER_S   	(DEV_RQ_BASE + 23) /* (safecopy) read into a vector */
! #define DEV_IOCTL_S    	(DEV_RQ_BASE + 24) /* (safecopy) I/O control code */
! 
! #define IS_DEV_RQ(type) (((type) & ~0xff) == DEV_RQ_BASE)
! 
! #define DEV_REVIVE      (DEV_RS_BASE + 2) /* driver revives process */
! #define DEV_IO_READY    (DEV_RS_BASE + 3) /* selected device ready */
! #define DEV_NO_STATUS   (DEV_RS_BASE + 4) /* empty status reply */
! #define DEV_REOPEN_REPL (DEV_RS_BASE + 5) /* reply to DEV_REOPEN */
! #define DEV_CLOSE_REPL	(DEV_RS_BASE + 6) /* reply to DEV_CLOSE */
! #define DEV_SEL_REPL1	(DEV_RS_BASE + 7) /* first reply to DEV_SELECT */
! #define DEV_SEL_REPL2	(DEV_RS_BASE + 8) /* (opt) second reply to DEV_SELECT */
! #define DEV_OPEN_REPL	(DEV_RS_BASE + 9) /* reply to DEV_OPEN */
! 
! #define IS_DEV_RS(type) (((type) & ~0xff) == DEV_RS_BASE)
! 
! /* Field names for messages to character device drivers. */
! #define DEVICE    	m2_i1	/* major-minor device */
! #define USER_ENDPT	m2_i2	/* which endpoint initiated this call? */
! #define COUNT   	m2_i3	/* how many bytes to transfer */
! #define REQUEST 	m2_i3 	/* ioctl request code */
! #define POSITION	m2_l1	/* file offset (low 4 bytes) */
! #define HIGHPOS		m2_l2	/* file offset (high 4 bytes) */
! #define ADDRESS 	m2_p1	/* core buffer address */
! #define IO_GRANT 	m2_p1	/* grant id (for DEV_*_S variants) */
! #define FLAGS		m2_s1   /* operation flags */
! 
! #define FLG_OP_NONBLOCK	0x1 /* operation is non blocking */
! 
! /* Field names for DEV_SELECT messages to character device drivers. */
! #define DEV_MINOR	m2_i1	/* minor device */
! #define DEV_SEL_OPS	m2_i2	/* which select operations are requested */
! 
! /* Field names used in reply messages from tasks. */
! #define REP_ENDPT	m2_i1	/* # of proc on whose behalf I/O was done */
! #define REP_STATUS	m2_i2	/* bytes transferred or error number */
! #define REP_IO_GRANT	m2_i3	/* DEV_REVIVE: grant by which I/O was done */
! #  define SUSPEND 	 -998 	/* status to suspend caller, reply later */
! 
! /* Field names for messages to TTY driver. */
! #define TTY_LINE	DEVICE	/* message parameter: terminal line */
! #define TTY_REQUEST	COUNT	/* message parameter: ioctl request code */
! #define TTY_SPEK	POSITION/* message parameter: ioctl speed, erasing */
! #define TTY_PGRP 	m2_i3	/* message parameter: process group */	
! 
! /*===========================================================================*
!  *                  	   Messages for networking layer		     *
!  *===========================================================================*/
! 
! /* Base type for data link layer requests and responses. */
! #define DL_RQ_BASE	0x200		
! #define DL_RS_BASE	0x280		
! 
! /* Message types for data link layer requests. */
! #define DL_CONF		(DL_RQ_BASE + 0)
! #define DL_GETSTAT_S	(DL_RQ_BASE + 1)
! #define DL_WRITEV_S	(DL_RQ_BASE + 2)
! #define DL_READV_S	(DL_RQ_BASE + 3)
! 
! /* Message type for data link layer replies. */
! #define DL_CONF_REPLY	(DL_RS_BASE + 0)
! #define DL_STAT_REPLY	(DL_RS_BASE + 1)
! #define DL_TASK_REPLY	(DL_RS_BASE + 2)
! 
! /* Field names for data link layer messages. */
! #define DL_COUNT	m2_i3
! #define DL_MODE		m2_l1
! #define DL_FLAGS	m2_l1
! #define DL_GRANT	m2_l2
! #define DL_STAT		m3_i1
! #define DL_HWADDR	m3_ca1
! 
! /* Bits in 'DL_FLAGS' field of DL replies. */
! #  define DL_NOFLAGS		0x00
! #  define DL_PACK_SEND		0x01
! #  define DL_PACK_RECV		0x02
! 
! /* Bits in 'DL_MODE' field of DL requests. */
! #  define DL_NOMODE		0x0
! #  define DL_PROMISC_REQ	0x1
! #  define DL_MULTI_REQ		0x2
! #  define DL_BROAD_REQ		0x4
! 
! /*===========================================================================*
!  *                  SYSTASK request types and field names                    *
!  *===========================================================================*/
! 
! /* System library calls are dispatched via a call vector, so be careful when 
!  * modifying the system call numbers. The numbers here determine which call
!  * is made from the call vector.
!  */ 
! #define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
! 
! #  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
! #  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
! #  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
! #  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
! #  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
! #  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
! #  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
! 
! #  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
! #  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
! #  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
! #  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
! 
! #  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
! 
! #  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
! #  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
! #  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
! #  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
! #  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
! 
! #  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
! #  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
! #  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
! #  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
! #  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
! 
! #  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
! #  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
! #  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
! #  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
! #  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
! #  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
! #  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
! #  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
! #  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
! #  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
! 
! #  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
! #  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
! #  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
! 
! #  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
! 
! #  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
! #  define SYS_SYSCTL     (KERNEL_CALL + 44)	/* sys_sysctl() */
! 
! #  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
! #  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
! #  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
! #  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
! 
! #  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
! #  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
! 
! #  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
! #  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
! 
! #  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
! 
! #define  SYS_CHREALTIME (KERNEL_CALL+57) //sys_chrealtime, new kernel call no. 2016.12.3
! 
! /* Total */
! #define NR_SYS_CALLS	58	/* number of kernel calls */    //modified 2016.12.3    57->58
! 
! #define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
! 
! /* Basic kernel calls allowed to every system process. */
! #define SYS_BASIC_CALLS \
!     SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
!     SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
!     SYS_PROFBUF, SYS_SYSCTL, SYS_STATECTL, SYS_SAFEMEMSET
! 
! /* Field names for SYS_MEMSET. */
! #define MEM_PTR		m2_p1	/* base */
! #define MEM_COUNT	m2_l1	/* count */
! #define MEM_PATTERN	m2_l2   /* pattern to write */
! #define MEM_PROCESS	m2_i1	/* NONE (phys) or process id (vir) */
! 
! /* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
! #define DIO_REQUEST	m2_i3	/* device in or output */
! #   define _DIO_INPUT		0x001
! #   define _DIO_OUTPUT		0x002
! #   define _DIO_DIRMASK		0x00f
! #   define _DIO_BYTE		0x010
! #   define _DIO_WORD		0x020
! #   define _DIO_LONG		0x030
! #   define _DIO_TYPEMASK	0x0f0
! #   define _DIO_SAFE		0x100
! #   define _DIO_SAFEMASK	0xf00
! #   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
! #   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
! #   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
! #   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
! #   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
! #   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
! #   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
! #   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
! #   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
! #   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
! #define DIO_PORT	m2_l1	/* single port address */
! #define DIO_VALUE	m2_l2	/* single I/O value */
! #define DIO_VEC_ADDR	m2_p1   /* address of buffer or (p,v)-pairs */
! #define DIO_VEC_SIZE	m2_l2   /* number of elements in vector */
! #define DIO_VEC_ENDPT	m2_i2   /* number of process where vector is */
! #define DIO_OFFSET	m2_i1	/* offset from grant */
! 
! /* Field names for SYS_SETALARM. */
! #define ALRM_EXP_TIME   m2_l1	/* expire time for the alarm call */
! #define ALRM_ABS_TIME   m2_i2	/* set to 1 to use absolute alarm time */
! #define ALRM_TIME_LEFT  m2_l1	/* how many ticks were remaining */
! 
! /* Field names for SYS_IRQCTL. */
! #define IRQ_REQUEST     m5_s1	/* what to do? */
! #  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
! #  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
! #  define IRQ_ENABLE        3	/* enable interrupts */
! #  define IRQ_DISABLE       4	/* disable interrupts */
! #define IRQ_VECTOR	m5_s2   /* irq vector */
! #define IRQ_POLICY	m5_i1   /* options for IRQCTL request */
! #  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
! #  define IRQ_BYTE      0x100	/* byte values */      
! #  define IRQ_WORD      0x200	/* word values */
! #  define IRQ_LONG      0x400	/* long values */
! #define IRQ_HOOK_ID	m5_l3   /* id of irq hook at kernel */
! 
! /* Field names for SYS_ABORT. */
! #define ABRT_HOW	m1_i1	/* RBT_REBOOT, RBT_HALT, etc. */
! 
! /* Field names for SYS_IOPENABLE. */
! #define IOP_ENDPT	m2_l1	/* target endpoint */
! 
! /* Field names for _UMAP, _VIRCOPY, _PHYSCOPY. */
! #define CP_SRC_ENDPT	m5_i1	/* process to copy from */
! #define CP_SRC_ADDR	m5_l1	/* address where data come from */
! #define CP_DST_ENDPT	m5_i2	/* process to copy to */
! #define CP_DST_ADDR	m5_l2	/* address where data go to */
! #define CP_NR_BYTES	m5_l3	/* number of bytes to copy */
! 
! #define UMAP_SEG 	m5_s1
! 
! /* only used for backwards compatability */
! #define CP_SRC_SPACE_OBSOLETE 	m5_s1	/* T or D space (stack is also D) */
! #define CP_DST_SPACE_OBSOLETE	m5_s2	/* T or D space (stack is also D) */
! 
! /* Field names for SYS_VUMAP. */
! #define VUMAP_ENDPT	m10_i1	/* grant owner, or SELF for local addresses */
! #define VUMAP_VADDR	m10_l1	/* address of virtual (input) vector */
! #define VUMAP_VCOUNT	m10_i2	/* number of elements in virtual vector */
! #define VUMAP_OFFSET	m10_l2	/* offset into first entry of input vector */
! #define VUMAP_ACCESS	m10_i3	/* access requested for input (VUA_ flags) */
! #define VUMAP_PADDR	m10_l3	/* address of physical (output) vector */
! #define VUMAP_PMAX	m10_i4	/* max number of physical vector elements */
! #define VUMAP_PCOUNT	m10_i1	/* upon return: number of elements filled */
! 
! /* Field names for SYS_GETINFO. */
! #define I_REQUEST      m7_i3	/* what info to get */
! #   define GET_KINFO	   0	/* get kernel information structure */
! #   define GET_IMAGE	   1	/* get system image table */
! #   define GET_PROCTAB	   2	/* get kernel process table */
! #   define GET_RANDOMNESS  3	/* get randomness buffer */
! #   define GET_MONPARAMS   4	/* get monitor parameters */
! #   define GET_KENV	   5	/* get kernel environment string */
! #   define GET_IRQHOOKS	   6	/* get the IRQ table */
! #   define GET_PRIVTAB	   8	/* get kernel privileges table */
! #   define GET_KADDRESSES  9	/* get various kernel addresses */
! #   define GET_SCHEDINFO  10	/* get scheduling queues */
! #   define GET_PROC 	  11	/* get process slot if given process */
! #   define GET_MACHINE 	  12	/* get machine information */
! #   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
! #   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
! #   define GET_LOADINFO   15	/* get load average information */
! #   define GET_IRQACTIDS  16	/* get the IRQ masks */
! #   define GET_PRIV	  17	/* get privilege structure */
! #   define GET_HZ	  18	/* get HZ value */
! #   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
! #   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
! #   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
! #   define GET_CPUINFO    23    /* get information about cpus */
! #   define GET_REGS	  24	/* get general process registers */
! #define I_ENDPT        m7_i4	/* calling process (may only be SELF) */
! #define I_VAL_PTR      m7_p1	/* virtual address at caller */ 
! #define I_VAL_LEN      m7_i1	/* max length of value */
! #define I_VAL_PTR2     m7_p2	/* second virtual address */ 
! #define I_VAL_LEN2_E   m7_i2	/* second length, or proc nr */
! 
! /* GET_WHOAMI fields. */
! #define GIWHO_EP	m3_i1
! #define GIWHO_NAME 	m3_ca1
! #define GIWHO_PRIVFLAGS	m3_i2
! 
! /* Field names for SYS_TIMES. */
! #define T_ENDPT		m4_l1	/* process to request time info for */
! #define T_USER_TIME	m4_l1	/* user time consumed by process */
! #define T_SYSTEM_TIME	m4_l2	/* system time consumed by process */
! #define T_BOOTTIME	m4_l3	/* Boottime in seconds (also for SYS_STIME) */
! #define T_BOOT_TICKS	m4_l5	/* number of clock ticks since boot time */
! 
! /* Field names for SYS_TRACE, SYS_PRIVCTL, SYS_STATECTL. */
! #define CTL_ENDPT      m2_i1	/* process number of the caller */
! #define CTL_REQUEST    m2_i2	/* server control request */
! #define CTL_ARG_PTR    m2_p1	/* pointer to argument */
! #define CTL_ADDRESS    m2_l1	/* address at traced process' space */
! #define CTL_DATA       m2_l2	/* data field for tracing */
! 
! /* SYS_PRIVCTL with CTL_REQUEST == SYS_PRIV_QUERY_MEM */
! #define CTL_PHYSSTART  m2_l1	/* physical memory start in bytes*/
! #define CTL_PHYSLEN    m2_l2	/* length in bytes */
! 
! /* Subfunctions for SYS_PRIVCTL */
! #define SYS_PRIV_ALLOW		1	/* Allow process to run */
! #define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
! #define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
! #define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
! #define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
! #define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
! 					 */
! #define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
! #define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
! #define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
! #define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
! 
! /* Field names for SYS_SETGRANT */
! #define SG_ADDR		m2_p1	/* address */
! #define SG_SIZE		m2_i2	/* no. of entries */
! 
! /* Field names for SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
! #define SIG_ENDPT      m2_i1	/* process number for inform */
! #define SIG_NUMBER     m2_i2	/* signal number to send */
! #define SIG_FLAGS      m2_i3	/* signal flags field */
! #define SIG_MAP        m2_l1	/* used by kernel to pass signal bit map */
! #define SIG_CTXT_PTR   m2_p1	/* pointer to info to restore signal context */
! 
! /* Field names for SYS_FORK, _EXEC, _EXIT, GETMCONTEXT, SETMCONTEXT.*/
! #define PR_ENDPT        m1_i1	/* indicates a process */
! #define PR_PRIORITY     m1_i2	/* process priority */
! #define PR_SLOT         m1_i2	/* indicates a process slot */
! #define PR_STACK_PTR    m1_p1	/* used for stack ptr in sys_exec, sys_getsp */
! #define PR_NAME_PTR     m1_p2	/* tells where program name is for dmp */
! #define PR_IP_PTR       m1_p3	/* initial value for ip after exec */
! #define PR_FORK_FLAGS	m1_i3	/* optional flags for fork operation */
! #define PR_FORK_MSGADDR m1_p1	/* reply message address of forked child */
! #define PR_CTX_PTR	m1_p1	/* pointer to mcontext_t structure */
! 
! /* Field names for EXEC sent from userland to PM. */
! #define PMEXEC_FLAGS	m1_i3	/* PMEF_* */
! 
! #define PMEF_AUXVECTORS	20
! #define PMEF_EXECNAMELEN1 256
! #define PMEF_AUXVECTORSPACE 0x01 /* space for PMEF_AUXVECTORS on stack */
! #define PMEF_EXECNAMESPACE1 0x02 /* space for PMEF_EXECNAMELEN1 execname */
! 
! /* Flags for PR_FORK_FLAGS. */
! #define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
! 
! /* Field names for SYS_INT86 */
! #define INT86_REG86    m1_p1	/* pointer to registers */
! 
! /* Field names for SYS_SAFECOPY* */
! #define SCP_FROM_TO	m2_i1	/* from/to whom? */
! #define SCP_SEG_OBSOLETE m2_i2	/* my own segment */
! #define SCP_GID		m2_i3	/* grant id */
! #define SCP_OFFSET	m2_l1	/* offset within grant */
! #define SCP_ADDRESS	m2_p1	/* my own address */
! #define SCP_BYTES	m2_l2	/* bytes from offset */
! 
! /* SYS_SAFEMEMSET */
! #define SMS_DST		m2_i1	/* dst endpoint */
! #define SMS_GID		m2_i3	/* grant id */
! #define SMS_OFFSET	m2_l1	/* offset within grant */
! #define SMS_BYTES	m2_l2	/* bytes from offset */
! #define SMS_PATTERN	m2_i2	/* memset() pattern */
! 
! /* Field names for SYS_VSAFECOPY* */
! #define VSCP_VEC_ADDR	m2_p1	/* start of vector */
! #define VSCP_VEC_SIZE	m2_l2	/* elements in vector */
! 
! #define SMAP_SEG_OBSOLETE	m2_p1
! 
! /* Field names for SYS_SPROF, _CPROF, _PROFBUF. */
! #define PROF_ACTION    m7_i1    /* start/stop/reset/get */
! #define PROF_MEM_SIZE  m7_i2    /* available memory for data */ 
! #define PROF_FREQ      m7_i3    /* sample frequency */
! #define PROF_ENDPT     m7_i4    /* endpoint of caller */
! #define PROF_INTR_TYPE m7_i5    /* interrupt type */
! #define PROF_CTL_PTR   m7_p1    /* location of info struct */
! #define PROF_MEM_PTR   m7_p2    /* location of profiling data */
! 
! /* Field names for SYS_READBIOS. */
! #define RDB_SIZE	m2_i1
! #define RDB_ADDR	m2_l1
! #define RDB_BUF		m2_p1
! 
! /* Field names for SYS_VMCTL. */
! #define SVMCTL_WHO	m1_i1
! #define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
! #define SVMCTL_VALUE	m1_i3
! #define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
! #define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
! #define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
! #define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
! #define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
! #define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
! #define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
! #define SVMCTL_MAP_VIR_ADDR	m1_p1
! #define SVMCTL_PTROOT		m1_i3
! #define SVMCTL_PTROOT_V		m1_p1
! 
! /* Reply message for VMCTL_KERN_PHYSMAP */
! #define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
! #define SVMCTL_MAP_PHYS_ADDR	m2_l1
! #define SVMCTL_MAP_PHYS_LEN	m2_l2
! 
! #define VMMF_UNCACHED		(1L << 0)
! #define VMMF_USER		(1L << 1)
! #define VMMF_WRITE		(1L << 2)
! #define VMMF_GLO		(1L << 3)
! 
! /* Values for SVMCTL_PARAM. */
! #define VMCTL_CLEAR_PAGEFAULT	12
! #define VMCTL_GET_PDBR		13
! #define VMCTL_MEMREQ_GET 	14
! #define VMCTL_MEMREQ_REPLY	15
! #define VMCTL_NOPAGEZERO	18
! #define VMCTL_I386_KERNELLIMIT	19
! #define VMCTL_I386_INVLPG	25
! #define VMCTL_FLUSHTLB		26
! #define VMCTL_KERN_PHYSMAP	27
! #define VMCTL_KERN_MAP_REPLY	28
! #define VMCTL_SETADDRSPACE	29
! #define VMCTL_VMINHIBIT_SET	30
! #define VMCTL_VMINHIBIT_CLEAR	31
! #define VMCTL_CLEARMAPCACHE	32
! #define VMCTL_BOOTINHIBIT_CLEAR	33
! 
! /* Codes and field names for SYS_SYSCTL. */
! #define SYSCTL_CODE		m1_i1	/* SYSCTL_CODE_* below */
! #define SYSCTL_ARG1		m1_p1
! #define SYSCTL_ARG2		m1_i2
! #define SYSCTL_CODE_DIAG	1	/* Print diagnostics. */
! #define SYSCTL_CODE_STACKTRACE	2	/* Print process stack. */
! #define DIAG_BUFSIZE	(80*25)
! 
! /* Field names for SYS_VTIMER. */
! #define VT_WHICH	m2_i1	/* which timer to set/retrieve */
! #  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
! #  define VT_PROF           2	/* the ITIMER_PROF timer */
! #define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
! #define VT_VALUE	m2_l1	/* new/previous value of the timer */
! #define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
! 
! /* Field names for SYS_RUNCTL. */
! #define RC_ENDPT	m1_i1	/* which process to stop or resume */
! #define RC_ACTION	m1_i2	/* set or clear stop flag */
! #  define RC_STOP           0	/* stop the process */
! #  define RC_RESUME         1	/* clear the stop flag */
! #define RC_FLAGS	m1_i3	/* request flags */
! #  define RC_DELAY          1	/* delay stop if process is sending */
! 
! /* Field names for SYS_UPDATE. */
! #define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
! #define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
! 
! /* Subfunctions for SYS_STATECTL */
! #define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
! 
! /* Subfunctions for SYS_SCHEDCTL */
! #define SCHEDCTL_FLAGS		m9_l1	/* flags for setting the scheduler */
! #  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
! 					 * RTS_NO_QUANTUM; otherwise caller is 
! 					 * marked scheduler 
! 					 */
! #define SCHEDCTL_ENDPOINT	m9_l2	/* endpt of process to be scheduled */
! #define SCHEDCTL_QUANTUM	m9_l3   /* current scheduling quantum */
! #define SCHEDCTL_PRIORITY	m9_s4   /* current scheduling priority */
! #define SCHEDCTL_CPU		m9_l5   /* where to place this process */
! 
! /*===========================================================================*
!  *                Messages for the Reincarnation Server 		     *
!  *===========================================================================*/
! 
! #define RS_RQ_BASE		0x700
! 
! #define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
! #define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
! #define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
! #define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
! #define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
! #define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
! #define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
! #define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
! 
! #define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
! 
! #define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
! #define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
! 
! #  define RS_CMD_ADDR		m1_p1		/* command string */
! #  define RS_CMD_LEN		m1_i1		/* length of command */
! #  define RS_PERIOD 	        m1_i2		/* heartbeat period */
! #  define RS_DEV_MAJOR          m1_i3           /* major device number */
! 
! #  define RS_ENDPOINT		m1_i1		/* endpoint number in reply */
! 
! #  define RS_NAME		m1_p1		/* name */
! #  define RS_NAME_LEN		m1_i1		/* namelen */
! 
! #  define RS_INIT_RESULT        m7_i1           /* init result */
! #  define RS_INIT_TYPE          m7_i2           /* init type */
! #  define RS_INIT_RPROCTAB_GID  m7_i3           /* init rproc table gid */
! #  define RS_INIT_OLD_ENDPOINT  m7_i4           /* init old endpoint */
! 
! #  define RS_LU_RESULT          m1_i1           /* live update result */
! #  define RS_LU_STATE           m1_i2           /* state required to update */
! #  define RS_LU_PREPARE_MAXTIME m1_i3           /* the max time to prepare */
! 
! /*===========================================================================*
!  *                Messages for the Data Store Server			     *
!  *===========================================================================*/
! 
! #define DS_RQ_BASE		0x800
! 
! #define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
! #define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
! #define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
! #define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
! #define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
! #define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
! #define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
! 
! /* DS field names */
! #  define DS_KEY_GRANT		m2_i1		/* key for the data */
! #  define DS_KEY_LEN		m2_s1		/* length of key incl. '\0' */
! #  define DS_FLAGS		m2_i2		/* flags provided by caller */
! 
! #  define DS_VAL		m2_l1		/* data (u32, char *, etc.) */
! #  define DS_VAL_LEN		m2_l2		/* data length */
! #  define DS_NR_SNAPSHOT	m2_i3		/* number of snapshot */
! #  define DS_OWNER		m2_i3		/* owner */
! 
! /*===========================================================================*
!  *                Miscellaneous messages used by TTY			     *
!  *===========================================================================*/
! 
! /* Miscellaneous request types and field names, e.g. used by IS server. */
! #define FKEY_CONTROL 		98  	/* control a function key at the TTY */
! #  define FKEY_REQUEST	     m2_i1	/* request to perform at TTY */
! #  define    FKEY_MAP		10	/* observe function key */
! #  define    FKEY_UNMAP		11	/* stop observing function key */
! #  define    FKEY_EVENTS	12	/* request open key presses */
! #  define FKEY_FKEYS	      m2_l1	/* F1-F12 keys pressed */
! #  define FKEY_SFKEYS	      m2_l2	/* Shift-F1-F12 keys pressed */
! 
! /*===========================================================================*
!  *                Messages used between PM and VFS			     *
!  *===========================================================================*/
! 
! #define PM_RQ_BASE	0x900
! #define PM_RS_BASE	0x980
! 
! /* Requests from PM to VFS */
! #define PM_INIT		(PM_RQ_BASE + 0)	/* Process table exchange */
! #define PM_SETUID	(PM_RQ_BASE + 1)	/* Set new user ID */
! #define PM_SETGID	(PM_RQ_BASE + 2)	/* Set group ID */
! #define PM_SETSID	(PM_RQ_BASE + 3)	/* Set session leader */
! #define PM_EXIT		(PM_RQ_BASE + 4)	/* Process exits */
! #define PM_DUMPCORE	(PM_RQ_BASE + 5)	/* Process is to dump core */
! #define PM_EXEC		(PM_RQ_BASE + 6)	/* Forwarded exec call */
! #define PM_FORK		(PM_RQ_BASE + 7)	/* Newly forked process */
! #define PM_SRV_FORK	(PM_RQ_BASE + 8)	/* fork for system services */
! #define PM_UNPAUSE	(PM_RQ_BASE + 9)	/* Interrupt process call */
! #define PM_REBOOT	(PM_RQ_BASE + 10)	/* System reboot */
! #define PM_SETGROUPS	(PM_RQ_BASE + 11)	/* Tell VFS about setgroups */
! 
! /* Replies from VFS to PM */
! #define PM_SETUID_REPLY	(PM_RS_BASE + 1)
! #define PM_SETGID_REPLY	(PM_RS_BASE + 2)
! #define PM_SETSID_REPLY	(PM_RS_BASE + 3)
! #define PM_EXIT_REPLY	(PM_RS_BASE + 4)
! #define PM_CORE_REPLY	(PM_RS_BASE + 5)
! #define PM_EXEC_REPLY	(PM_RS_BASE + 6)
! #define PM_FORK_REPLY	(PM_RS_BASE + 7)
! #define PM_SRV_FORK_REPLY	(PM_RS_BASE + 8)
! #define PM_UNPAUSE_REPLY	(PM_RS_BASE + 9)
! #define PM_REBOOT_REPLY	(PM_RS_BASE + 10)
! #define PM_SETGROUPS_REPLY	(PM_RS_BASE + 11)
! 
! /* Standard parameters for all requests and replies, except PM_REBOOT */
! #  define PM_PROC		m7_i1	/* process endpoint */
! 
! /* Additional parameters for PM_INIT */
! #  define PM_SLOT		m7_i2	/* process slot number */
! #  define PM_PID		m7_i3	/* process pid */
! 
! /* Additional parameters for PM_SETUID and PM_SETGID */
! #  define PM_EID		m7_i2	/* effective user/group id */
! #  define PM_RID		m7_i3	/* real user/group id */
! 
! /* Additional parameter for PM_SETGROUPS */
! #  define PM_GROUP_NO		m7_i2	/* number of groups */
! #  define PM_GROUP_ADDR		m7_p1	/* struct holding group data */
! 
! /* Additional parameters for PM_EXEC */
! #  define PM_PATH		m7_p1	/* executable */
! #  define PM_PATH_LEN		m7_i2	/* length of path including
! 					 * terminating null character
! 					 */
! #  define PM_FRAME		m7_p2	/* arguments and environment */
! #  define PM_FRAME_LEN		m7_i3	/* size of frame */
! #  define PM_EXECFLAGS		m7_i4	/* PMEXEC_FLAGS */
! 
! /* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
! #  define PM_STATUS		m7_i2	/* OK or failure */
! #  define PM_PC			m7_p1	/* program counter */
! #  define PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
! 
! /* Additional parameters for PM_FORK and PM_SRV_FORK */
! #  define PM_PPROC		m7_i2	/* parent process endpoint */
! #  define PM_CPID		m7_i3	/* child pid */
! #  define PM_REUID		m7_i4	/* real and effective uid */
! #  define PM_REGID		m7_i5	/* real and effective gid */
! 
! /* Additional parameters for PM_DUMPCORE */
! #  define PM_TERM_SIG		m7_i2	/* process's termination signal */
! #  define PM_TRACED_PROC	m7_i3	/* required for T_DUMPCORE */
! 
! /* Parameters for the EXEC_NEWMEM call */
! #define EXC_NM_PROC	m1_i1		/* process that needs new map */
! #define EXC_NM_PTR	m1_p1		/* parameters in struct exec_info */
! /* Results:
!  * the status will be in m_type.
!  * the top of the stack will be in m1_i1.
!  * the following flags will be in m1_i2:
!  */
! #define EXC_NM_RF_LOAD_TEXT	1	/* Load text segment (otherwise the
! 					 * text segment is already present)
! 					 */
! #define EXC_NM_RF_ALLOW_SETUID	2	/* Setuid execution is allowed (tells
! 					 * FS to update its uid and gid 
! 					 * fields.
! 					 */
! #define EXC_NM_RF_FULLVM	4	
! 
! /* Parameters for the EXEC_RESTART call */
! #define EXC_RS_PROC	m1_i1		/* process that needs to be restarted */
! #define EXC_RS_RESULT	m1_i2		/* result of the exec */
! #define EXC_RS_PC	m1_p1		/* program counter */
! 
! /*===========================================================================*
!  *                Messages used from VFS to file servers		     *
!  *===========================================================================*/
! 
! #define VFS_BASE	0xA00		/* Requests sent by VFS to filesystem
! 					 * implementations. See <minix/vfsif.h>
! 					 */
! 
! /*===========================================================================*
!  *                Common requests and miscellaneous field names		     *
!  *===========================================================================*/
! 
! #define COMMON_RQ_BASE		0xE00
! 
! /* Field names for system signals (sent by a signal manager). */
! #define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
! #	define SIGS_SIG_NUM      m2_i1
! 
! /* Common request to all processes: gcov data. */
! #define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
! #	define GCOV_GRANT   m1_i2
! #	define GCOV_PID     m1_i3
! #	define GCOV_BUFF_P  m1_p1
! #	define GCOV_BUFF_SZ m1_i1
! 
! /* Common request to several system servers: retrieve system information. */
! #define COMMON_GETSYSINFO	(COMMON_RQ_BASE+2)
! #	define SI_WHAT		m1_i1
! #	define SI_WHERE		m1_p1
! #	define SI_SIZE		m1_i2
! 
! /* PM field names */
! /* BRK */
! #define PMBRK_ADDR				m1_p1
! 
! /* TRACE */
! #define PMTRACE_ADDR				m2_l1
! 
! #define PM_ENDPT				m1_i1
! #define PM_PENDPT				m1_i2
! 
! #define PM_NUID					m2_i1
! #define PM_NGID					m2_i2
! 
! #define PM_GETSID_PID				m1_i1
! 
! /* Field names for SELECT (FS). */
! #define SEL_NFDS       m8_i1
! #define SEL_READFDS    m8_p1
! #define SEL_WRITEFDS   m8_p2
! #define SEL_ERRORFDS   m8_p3
! #define SEL_TIMEOUT    m8_p4
! 
! /* Field names for the fstatvfs call */
! #define FSTATVFS_FD m1_i1
! #define FSTATVFS_BUF m1_p1
! 
! /* Field names for the statvfs call */
! #define STATVFS_LEN m1_i1
! #define STATVFS_NAME m1_p1
! #define STATVFS_BUF m1_p2
! 
! /*===========================================================================*
!  *                Messages for VM server				     *
!  *===========================================================================*/
! #define VM_RQ_BASE		0xC00
! 
! /* Calls from PM */
! #define VM_EXIT			(VM_RQ_BASE+0)
! #	define VME_ENDPOINT		m1_i1
! #define VM_FORK			(VM_RQ_BASE+1)
! #	define VMF_ENDPOINT		m1_i1
! #	define VMF_SLOTNO		m1_i2
! #	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
! #define VM_BRK			(VM_RQ_BASE+2)
! #	define VMB_ENDPOINT		m1_i1
! #	define VMB_ADDR			m1_p1
! #	define VMB_RETADDR		m1_p2	/* result */
! #define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
! #	define VMEN_ENDPOINT		m1_i1
! #	define VMEN_ARGSPTR		m1_p1
! #	define VMEN_ARGSSIZE		m1_i2
! #	define VMEN_FLAGS		m1_i3	/* result */
! #	define VMEN_STACK_TOP		m1_p2	/* result */
! #define VM_WILLEXIT		(VM_RQ_BASE+5)
! #	define VMWE_ENDPOINT		m1_i1
! 
! /* General calls. */
! #define VM_MMAP			(VM_RQ_BASE+10)
! #	define VMM_ADDR			m5_l1
! #	define VMM_LEN			m5_l2
! #	define VMM_PROT			m5_s1
! #	define VMM_FLAGS		m5_s2
! #	define VMM_FD			m5_i1
! #	define VMM_OFFSET		m5_i2
! #	define VMM_FORWHOM		m5_l3
! #	define VMM_RETADDR		m5_l1	/* result */
! #define VM_UMAP			(VM_RQ_BASE+11)
! #	define VMU_SEG			m1_i1
! #	define VMU_OFFSET		m1_p1
! #	define VMU_LENGTH		m1_p2
! #	define VMU_RETADDR		m1_p3
! 
! /* to VM: inform VM about a region of memory that is used for
!  * bus-master DMA
!  */
! #define VM_ADDDMA	(VM_RQ_BASE+12)
! #	define VMAD_EP			m2_i1
! #	define VMAD_START		m2_l1
! #	define VMAD_SIZE		m2_l2
! 
! /* to VM: inform VM that a region of memory that is no longer
!  * used for bus-master DMA
!  */
! #define VM_DELDMA       (VM_RQ_BASE+13)
! #	define VMDD_EP			m2_i1
! #	define VMDD_START		m2_l1
! #	define VMDD_SIZE		m2_l2
! 
! /* to VM: ask VM for a region of memory that should not
!  * be used for bus-master DMA any longer
!  */
! #define VM_GETDMA       (VM_RQ_BASE+14)
! #	define VMGD_PROCP		m2_i1
! #	define VMGD_BASEP		m2_l1
! #	define VMGD_SIZEP		m2_l2
! 
! #define VM_MAP_PHYS		(VM_RQ_BASE+15)
! #	define VMMP_EP			m1_i1
! #	define VMMP_PHADDR		m1_p2
! #	define VMMP_LEN			m1_i2
! #	define VMMP_VADDR_REPLY		m1_p3
! 
! #define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
! #	define VMUP_EP			m1_i1
! #	define VMUP_VADDR		m1_p1
! 
! #define VM_MUNMAP		(VM_RQ_BASE+17)
! #	define VMUM_ADDR		m1_p1
! #	define VMUM_LEN			m1_i1
! 
! /* To VM: forget all my yielded blocks. */
! #define VM_FORGETBLOCKS		(VM_RQ_BASE+22)
! 
! /* To VM: forget this block. */
! #define VM_FORGETBLOCK		(VM_RQ_BASE+23)
! #define VMFB_IDHI			m1_i1
! #define VMFB_IDLO			m1_i2
! 
! /* To VM: combined yield+get call. */
! #define VM_YIELDBLOCKGETBLOCK	(VM_RQ_BASE+25)
! #define VMYBGB_VADDR			m2_p1
! #define VMYBGB_GETIDHI			m2_i1
! #define VMYBGB_GETIDLO			m2_i2
! #define VMYBGB_LEN			m2_i3
! #define VMYBGB_YIELDIDHI		m2_l1
! #define VMYBGB_YIELDIDLO		m2_l2
! 
! /* Calls from VFS. */
! #	define VMV_ENDPOINT		m1_i1	/* for all VM_VFS_REPLY_* */
! #define VM_VFS_REPLY_OPEN	(VM_RQ_BASE+30)
! #	define VMVRO_FD			m1_i2
! #define VM_VFS_REPLY_MMAP	(VM_RQ_BASE+31)
! #define VM_VFS_REPLY_CLOSE	(VM_RQ_BASE+32)
! 
! #define VM_REMAP		(VM_RQ_BASE+33)
! #	define VMRE_D			m1_i1
! #	define VMRE_S			m1_i2
! #	define VMRE_DA			m1_p1
! #	define VMRE_SA			m1_p2
! #	define VMRE_RETA		m1_p3
! #	define VMRE_SIZE		m1_i3
! #	define VMRE_FLAGS		m1_i3
! 
! #define VM_SHM_UNMAP		(VM_RQ_BASE+34)
! #	define VMUN_ENDPT		m2_i1
! #	define VMUN_ADDR		m2_l1
! 
! #define VM_GETPHYS		(VM_RQ_BASE+35)
! #	define VMPHYS_ENDPT		m2_i1
! #	define VMPHYS_ADDR		m2_l1
! #	define VMPHYS_RETA		m2_l2
! 
! #define VM_GETREF		(VM_RQ_BASE+36)
! #	define VMREFCNT_ENDPT		m2_i1
! #	define VMREFCNT_ADDR		m2_l1
! #	define VMREFCNT_RETC		m2_i2
! 
! #define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
! #	define VM_RS_NR			m2_i1
! #	define VM_RS_BUF		m2_l1
! 
! #define VM_QUERY_EXIT		(VM_RQ_BASE+38)
! #	define VM_QUERY_RET_PT	m2_i1
! #	define VM_QUERY_IS_MORE	m2_i2
! 
! #define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
! #	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
! #	define VM_NOTIFY_SIG_IPC	m1_i2
! 
! #define VM_INFO			(VM_RQ_BASE+40)
! #	define VMI_WHAT			m2_i1
! #	define VMI_EP			m2_i2
! #	define VMI_COUNT		m2_i3
! #	define VMI_PTR			m2_p1
! #	define VMI_NEXT			m2_l1
! 
! /* VMI_WHAT values. */
! #define VMIW_STATS			1
! #define VMIW_USAGE			2
! #define VMIW_REGION			3
! 
! #define VM_RS_UPDATE		(VM_RQ_BASE+41)
! #	define VM_RS_SRC_ENDPT		m1_i1
! #	define VM_RS_DST_ENDPT		m1_i2
! 
! #define VM_RS_MEMCTL		(VM_RQ_BASE+42)
! #	define VM_RS_CTL_ENDPT		m1_i1
! #	define VM_RS_CTL_REQ		m1_i2
! #		define VM_RS_MEM_PIN	    0	/* pin memory */
! #		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
! 
! #define VM_WATCH_EXIT		(VM_RQ_BASE+43)
! #	define VM_WE_EP		m1_i1
! 
! #define VM_REMAP_RO		(VM_RQ_BASE+44)
! /* same args as VM_REMAP */
! 
! #define VM_PROCCTL		(VM_RQ_BASE+45)
! #define VMPCTL_PARAM		m1_i1
! #define VMPCTL_WHO		m1_i2
! 
! #define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
! 
! /* Total. */
! #define NR_VM_CALLS				46
! #define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
! 
! /* not handled as a normal VM call, thus at the end of the reserved rage */
! #define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
! #	define VPF_ADDR		m1_i1
! #	define VPF_FLAGS	m1_i2
! 
! /* Basic vm calls allowed to every process. */
! #define VM_BASIC_CALLS \
!     VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, \
!     VM_FORGETBLOCKS, VM_FORGETBLOCK, VM_YIELDBLOCKGETBLOCK, VM_INFO
! 
! /*===========================================================================*
!  *                Messages for IPC server				     *
!  *===========================================================================*/
! #define IPC_BASE	0xD00
! 
! /* Shared Memory */
! #define IPC_SHMGET	(IPC_BASE+1)
! #	define SHMGET_KEY	m2_l1
! #	define SHMGET_SIZE	m2_l2
! #	define SHMGET_FLAG	m2_i1
! #	define SHMGET_RETID	m2_i2
! #define IPC_SHMAT	(IPC_BASE+2)
! #	define SHMAT_ID		m2_i1
! #	define SHMAT_ADDR	m2_l1
! #	define SHMAT_FLAG	m2_i2
! #	define SHMAT_RETADDR	m2_l2
! #define IPC_SHMDT	(IPC_BASE+3)
! #	define SHMDT_ADDR	m2_l1
! #define IPC_SHMCTL	(IPC_BASE+4)
! #	define SHMCTL_ID	m2_i1
! #	define SHMCTL_CMD	m2_i2
! #	define SHMCTL_BUF	m2_l1
! #	define SHMCTL_RET	m2_i3
! 
! /* Semaphore */
! #define IPC_SEMGET	(IPC_BASE+5)
! #	define SEMGET_KEY	m2_l1
! #	define SEMGET_NR	m2_i1
! #	define SEMGET_FLAG	m2_i2
! #	define SEMGET_RETID	m2_i3
! #define IPC_SEMCTL	(IPC_BASE+6)
! #	define SEMCTL_ID	m2_i1
! #	define SEMCTL_NUM	m2_i2
! #	define SEMCTL_CMD	m2_i3
! #	define SEMCTL_OPT	m2_l1
! #define IPC_SEMOP	(IPC_BASE+7)
! #	define SEMOP_ID		m2_i1
! #	define SEMOP_OPS	m2_l1
! #	define SEMOP_SIZE	m2_i2
! 
! /*===========================================================================*
!  *                Messages for Scheduling				     *
!  *===========================================================================*/
! #define SCHEDULING_BASE	0xF00
! 
! #define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
! #	define SCHEDULING_ACNT_DEQS		m9_l1
! #	define SCHEDULING_ACNT_IPC_SYNC		m9_l2
! #	define SCHEDULING_ACNT_IPC_ASYNC	m9_l3
! #	define SCHEDULING_ACNT_PREEMPT		m9_l4
! #	define SCHEDULING_ACNT_QUEUE		m9_l5
! #	define SCHEDULING_ACNT_CPU		m9_s1
! #	define SCHEDULING_ACNT_CPU_LOAD		m9_s2
! /* These are used for SYS_SCHEDULE, a reply to SCHEDULING_NO_QUANTUM */
! #	define SCHEDULING_ENDPOINT	m9_l1
! #	define SCHEDULING_QUANTUM	m9_l2
! #	define SCHEDULING_PRIORITY	m9_s1
! #	define SCHEDULING_CPU		m9_l4
! 
! /*
!  * SCHEDULING_START uses _ENDPOINT, _PRIORITY and _QUANTUM from
!  * SCHEDULING_NO_QUANTUM/SYS_SCHEDULE
!  */
! #define SCHEDULING_START	(SCHEDULING_BASE+2)
! #	define SCHEDULING_SCHEDULER	m9_l1 /* Overrides _ENDPOINT on return*/
! #	define SCHEDULING_PARENT	m9_l3
! #	define SCHEDULING_MAXPRIO	m9_l4
! 
! #define SCHEDULING_STOP		(SCHEDULING_BASE+3)
! 
! #define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
! 
! /* SCHEDULING_INHERIT is like SCHEDULING_START, but without _QUANTUM field */
! #define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
! 
! /*===========================================================================*
!  *              Messages for USB                                             *
!  *===========================================================================*/
! 
! #define USB_BASE 0x1100
! 
! /* those are from driver to USBD */
! #define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
! #define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
! #define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
! #define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
! #define USB_REPLY            (USB_BASE +  4) 
! 
! 
! /* those are from USBD to driver */
! #define USB_COMPLETE_URB    (USB_BASE +  6)
! #define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
! #define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
!                                               USB device*/
! #   define USB_GRANT_ID     m4_l1
! #   define USB_GRANT_SIZE   m4_l2
! 
! #   define USB_URB_ID       m4_l1
! #   define USB_RESULT       m4_l2
! #   define USB_DEV_ID       m4_l1
! #   define USB_DRIVER_EP    m4_l2
! #   define USB_INTERFACES   m4_l3
! #   define USB_RB_INIT_NAME m3_ca1
! 
! /*===========================================================================*
!  *              Messages for DeviceManager (s/t like SysFS)                  *
!  *===========================================================================*/
! 
! #define DEVMAN_BASE 0x1200
! 
! #define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
! #define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
! #define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
! #define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
! #define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
! #define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
! 
! #define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
! #define DEVMAN_REPLY       (DEVMAN_BASE + 7)
! 
! #define DEVMAN_BIND        (DEVMAN_BASE + 8)
! #define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
! 
! #   define DEVMAN_GRANT_ID       m4_l1
! #   define DEVMAN_GRANT_SIZE     m4_l2
! 
! #   define DEVMAN_ENDPOINT       m4_l3
! #   define DEVMAN_DEVICE_ID      m4_l2
! #   define DEVMAN_RESULT         m4_l1
! 
! /*===========================================================================*
!  *              TTY INPUT INJECTION                                          *
!  *===========================================================================*/
! 
! #define INPUT_BASE 0x1300
! 
! #define INPUT_EVENT      (INPUT_BASE + 0)
! 
! #	define INPUT_TYPE        m4_l1
! #	define INPUT_CODE        m4_l2
! #	define INPUT_VALUE       m4_l3
! 
! #endif
! 
! /*===========================================================================*
!  *			VFS-FS TRANSACTION IDs				     *
!  *===========================================================================*/
! 
! #define VFS_TRANSACTION_BASE 0x1400
! 
! #define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
! #define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
! 
! /*===========================================================================*
!  *			Messages for block devices			     *
!  *===========================================================================*/
! 
! /* Base type for block device requests and responses. */
! #define BDEV_RQ_BASE	0x1500
! #define BDEV_RS_BASE	0x1580
! 
! #define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
! #define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
! 
! /* Message types for block device requests. */
! #define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
! #define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
! #define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
! #define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
! #define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
! #define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
! #define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
! 
! /* Message types for block device responses. */
! #define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
! 
! /* Field names for block device messages. */
! #define BDEV_MINOR	m10_i1	/* minor device number */
! #define BDEV_STATUS	m10_i1	/* OK or error code */
! #define BDEV_ACCESS	m10_i2	/* access bits for open requests */
! #define BDEV_REQUEST	m10_i2	/* I/O control request */
! #define BDEV_COUNT	m10_i2	/* number of bytes or elements in transfer */
! #define BDEV_GRANT	m10_i3	/* grant ID of buffer or vector */
! #define BDEV_FLAGS	m10_i4	/* transfer flags */
! #define BDEV_ID		m10_l1	/* opaque request ID */
! #define BDEV_POS_LO	m10_l2	/* transfer position (low bits) */
! #define BDEV_POS_HI	m10_l3	/* transfer position (high bits) */
! 
! /* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
! #  define BDEV_NOFLAGS		0x00	/* no flags are set */
! #  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
! 
! /* _MINIX_COM_H */
diff -crN usr_orig/src/include/minix/syslib.h EDF/src/include/minix/syslib.h
*** usr_orig/src/include/minix/syslib.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/include/minix/syslib.h	2016-12-08 00:17:19.639910742 +0800
***************
*** 1,249 ****
! /* Prototypes for system library functions. */
! 
! #ifndef _SYSLIB_H
! #define _SYSLIB_H
! 
! #include <sys/types.h>
! #include <sys/sigtypes.h>
! 
! #include <minix/ipc.h>
! #include <minix/u64.h>
! #include <minix/devio.h>
! 
! #include <minix/safecopies.h>
! #include <minix/sef.h>
! #include <machine/mcontext.h>
! 
! /* Forward declaration */
! struct reg86u;
! struct rs_pci;
! 
! #define SYSTASK SYSTEM
! 
! /*==========================================================================* 
!  * Minix system library. 						    *
!  *==========================================================================*/ 
! int _taskcall(endpoint_t who, int syscallnr, message *msgptr);
! int _kernel_call(int syscallnr, message *msgptr);
! 
! int sys_abort(int how);
! int sys_enable_iop(endpoint_t proc_ep);
! int sys_exec(endpoint_t proc_ep, char *ptr, char *aout, vir_bytes
! 	initpc);
! int sys_fork(endpoint_t parent, endpoint_t child, endpoint_t *, 
! 	u32_t vm, vir_bytes *);
! int sys_clear(endpoint_t proc_ep);
! int sys_exit(void);
! int sys_trace(int req, endpoint_t proc_ep, long addr, long *data_p);
! 
! int sys_schedule(endpoint_t proc_ep, int priority, int quantum, int
! 	cpu);
! int sys_schedctl(unsigned flags, endpoint_t proc_ep, int priority, int
! 	quantum, int cpu);
! 
! /* Shorthands for sys_runctl() system call. */
! #define sys_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, 0)
! #define sys_delay_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, RC_DELAY)
! #define sys_resume(proc_ep) sys_runctl(proc_ep, RC_RESUME, 0)
! int sys_runctl(endpoint_t proc_ep, int action, int flags);
! 
! int sys_update(endpoint_t src_ep, endpoint_t dst_ep);
! int sys_statectl(int request);
! int sys_privctl(endpoint_t proc_ep, int req, void *p);
! int sys_privquery_mem(endpoint_t proc_ep, phys_bytes physstart,
! 	phys_bytes physlen);
! int sys_setgrant(cp_grant_t *grants, int ngrants);
! 
! int sys_int86(struct reg86u *reg86p);
! int sys_vm_setbuf(phys_bytes base, phys_bytes size, phys_bytes high);
! int sys_vm_map(endpoint_t proc_ep, int do_map, phys_bytes base,
! 	phys_bytes size, phys_bytes offset);
! int sys_vmctl(endpoint_t who, int param, u32_t value);
! int sys_vmctl_get_pdbr(endpoint_t who, u32_t *pdbr);
! int sys_vmctl_get_memreq(endpoint_t *who, vir_bytes *mem, vir_bytes
! 	*len, int *wrflag, endpoint_t *who_s, vir_bytes *mem_s, endpoint_t *);
! int sys_vmctl_enable_paging(void * data);
! 
! int sys_readbios(phys_bytes address, void *buf, size_t size);
! int sys_stime(time_t boottime);
! int sys_sysctl(int ctl, char *arg1, int arg2);
! int sys_sysctl_stacktrace(endpoint_t who);
! int sys_vmctl_get_mapping(int index, phys_bytes *addr, phys_bytes *len,
! 	int *flags);
! int sys_vmctl_reply_mapping(int index, vir_bytes addr);
! int sys_vmctl_set_addrspace(endpoint_t who, phys_bytes ptroot, void
! 	*ptroot_v);
! 
! 
! /* Shorthands for sys_sdevio() system call. */
! #define sys_insb(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_INPUT_BYTE, port, proc_ep, buffer, count, 0)
! #define sys_insw(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_INPUT_WORD, port, proc_ep, buffer, count, 0)
! #define sys_outsb(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_OUTPUT_BYTE, port, proc_ep, buffer, count, 0)
! #define sys_outsw(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_OUTPUT_WORD, port, proc_ep, buffer, count, 0)
! #define sys_safe_insb(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_INPUT_BYTE, port, ept, (void*)grant, count, offset)
! #define sys_safe_outsb(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_OUTPUT_BYTE, port, ept, (void*)grant, count, offset)
! #define sys_safe_insw(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_INPUT_WORD, port, ept, (void*)grant, count, offset)
! #define sys_safe_outsw(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_OUTPUT_WORD, port, ept, (void*)grant, count, offset)
! int sys_sdevio(int req, long port, endpoint_t proc_ep, void *buffer, int
! 	count, vir_bytes offset);
! void *alloc_contig(size_t len, int flags, phys_bytes *phys);
! int free_contig(void *addr, size_t len);
! 
! #define AC_ALIGN4K	0x01
! #define AC_LOWER16M	0x02
! #define AC_ALIGN64K	0x04
! #define AC_LOWER1M	0x08
! 
! /* Clock functionality: get system times, (un)schedule an alarm call, or
!  * retrieve/set a process-virtual timer.
!  */
! int sys_times(endpoint_t proc_ep, clock_t *user_time, clock_t *sys_time,
! 	clock_t *uptime, time_t *boottime);
! int sys_setalarm(clock_t exp_time, int abs_time);
! int sys_vtimer(endpoint_t proc_nr, int which, clock_t *newval, clock_t
! 	*oldval);
! 
! /* Shorthands for sys_irqctl() system call. */
! #define sys_irqdisable(hook_id) \
!     sys_irqctl(IRQ_DISABLE, 0, 0, hook_id) 
! #define sys_irqenable(hook_id) \
!     sys_irqctl(IRQ_ENABLE, 0, 0, hook_id) 
! #define sys_irqsetpolicy(irq_vec, policy, hook_id) \
!     sys_irqctl(IRQ_SETPOLICY, irq_vec, policy, hook_id)
! #define sys_irqrmpolicy(hook_id) \
!     sys_irqctl(IRQ_RMPOLICY, 0, 0, hook_id)
! int sys_irqctl(int request, int irq_vec, int policy, int *irq_hook_id);
! 
! /* Shorthands for sys_vircopy() and sys_physcopy() system calls. */
! #define sys_datacopy sys_vircopy
! int sys_vircopy(endpoint_t src_proc, vir_bytes src_v,
! 	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes);
! 
! #define sys_abscopy(src_phys, dst_phys, bytes) \
! 	sys_physcopy(NONE, src_phys, NONE, dst_phys, bytes)
! int sys_physcopy(endpoint_t src_proc, vir_bytes src_vir,
! 	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes);
! 
! 
! /* Grant-based copy functions. */
! int sys_safecopyfrom(endpoint_t source, cp_grant_id_t grant, vir_bytes
! 	grant_offset, vir_bytes my_address, size_t bytes);
! int sys_safecopyto(endpoint_t dest, cp_grant_id_t grant, vir_bytes
! 	grant_offset, vir_bytes my_address, size_t bytes);
! int sys_vsafecopy(struct vscp_vec *copyvec, int elements);
! 
! int sys_safememset(endpoint_t source, cp_grant_id_t grant, vir_bytes
! 	grant_offset, int pattern, size_t bytes);
! 
! int sys_memset(endpoint_t who, unsigned long pattern,
! 	phys_bytes base, phys_bytes bytes);
! 
! int sys_vumap(endpoint_t endpt, struct vumap_vir *vvec,
! 	int vcount, size_t offset, int access, struct vumap_phys *pvec,
! 	int *pcount);
! int sys_umap(endpoint_t proc_ep, int seg, vir_bytes vir_addr, vir_bytes
! 	bytes, phys_bytes *phys_addr);
! int sys_umap_data_fb(endpoint_t proc_ep, vir_bytes vir_addr, vir_bytes
! 	bytes, phys_bytes *phys_addr);
! int sys_umap_remote(endpoint_t proc_ep, endpoint_t grantee, int seg,
! 	vir_bytes vir_addr, vir_bytes bytes, phys_bytes *phys_addr);
! 
! /* Shorthands for sys_getinfo() system call. */
! #define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
! #define sys_getloadinfo(dst)	sys_getinfo(GET_LOADINFO, dst, 0,0,0)
! #define sys_getmachine(dst)	sys_getinfo(GET_MACHINE, dst, 0,0,0)
! #define sys_getcpuinfo(dst)     sys_getinfo(GET_CPUINFO, dst, 0,0,0)
! #define sys_getproctab(dst)	sys_getinfo(GET_PROCTAB, dst, 0,0,0)
! #define sys_getprivtab(dst)	sys_getinfo(GET_PRIVTAB, dst, 0,0,0)
! #define sys_getproc(dst,nr)	sys_getinfo(GET_PROC, dst, 0,0, nr)
! #define sys_getrandomness(dst)	sys_getinfo(GET_RANDOMNESS, dst, 0,0,0)
! #define sys_getrandom_bin(d,b)	sys_getinfo(GET_RANDOMNESS_BIN, d, 0,0,b)
! #define sys_getimage(dst)	sys_getinfo(GET_IMAGE, dst, 0,0,0)
! #define sys_getirqhooks(dst)	sys_getinfo(GET_IRQHOOKS, dst, 0,0,0)
! #define sys_getirqactids(dst)	sys_getinfo(GET_IRQACTIDS, dst, 0,0,0)
! #define sys_getmonparams(v,vl)	sys_getinfo(GET_MONPARAMS, v,vl, 0,0)
! #define sys_getschedinfo(v1,v2)	sys_getinfo(GET_SCHEDINFO, v1,0, v2,0)
! #define sys_getpriv(dst, nr)	sys_getinfo(GET_PRIV, dst, 0,0, nr)
! #define sys_getidletsc(dst)	sys_getinfo(GET_IDLETSC, dst, 0,0,0)
! #define sys_getregs(dst,nr)	sys_getinfo(GET_REGS, dst, 0,0, nr)
! int sys_getinfo(int request, void *val_ptr, int val_len, void *val_ptr2,
! 	int val_len2);
! int sys_whoami(endpoint_t *ep, char *name, int namelen, int
! 	*priv_flags);
! 
! /* Signal control. */
! int sys_kill(endpoint_t proc_ep, int sig);
! int sys_sigsend(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
! int sys_sigreturn(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
! int sys_getksig(endpoint_t *proc_ep, sigset_t *k_sig_map);
! int sys_endksig(endpoint_t proc_ep);
! 
! /* NOTE: two different approaches were used to distinguish the device I/O
!  * types 'byte', 'word', 'long': the latter uses #define and results in a
!  * smaller implementation, but looses the static type checking.
!  */
! int sys_voutb(pvb_pair_t *pvb_pairs, int nr_ports);
! int sys_voutw(pvw_pair_t *pvw_pairs, int nr_ports);
! int sys_voutl(pvl_pair_t *pvl_pairs, int nr_ports);
! int sys_vinb(pvb_pair_t *pvb_pairs, int nr_ports);
! int sys_vinw(pvw_pair_t *pvw_pairs, int nr_ports);
! int sys_vinl(pvl_pair_t *pvl_pairs, int nr_ports);
! 
! /* Shorthands for sys_out() system call. */
! #define sys_outb(p,v)	sys_out((p), (u32_t) (v), _DIO_BYTE)
! #define sys_outw(p,v)	sys_out((p), (u32_t) (v), _DIO_WORD)
! #define sys_outl(p,v)	sys_out((p), (u32_t) (v), _DIO_LONG)
! int sys_out(int port, u32_t value, int type);
! 
! /* Shorthands for sys_in() system call. */
! #define sys_inb(p,v)	sys_in((p), (v), _DIO_BYTE)
! #define sys_inw(p,v)	sys_in((p), (v), _DIO_WORD)
! #define sys_inl(p,v)	sys_in((p), (v), _DIO_LONG)
! int sys_in(int port, u32_t *value, int type);
! 
! /* pci.c */
! void pci_init(void);
! int pci_first_dev(int *devindp, u16_t *vidp, u16_t *didp);
! int pci_next_dev(int *devindp, u16_t *vidp, u16_t *didp);
! int pci_find_dev(u8_t bus, u8_t dev, u8_t func, int *devindp);
! void pci_reserve(int devind);
! int pci_reserve_ok(int devind);
! void pci_ids(int devind, u16_t *vidp, u16_t *didp);
! void pci_rescan_bus(u8_t busnr);
! u8_t pci_attr_r8(int devind, int port);
! u16_t pci_attr_r16(int devind, int port);
! u32_t pci_attr_r32(int devind, int port);
! void pci_attr_w8(int devind, int port, u8_t value);
! void pci_attr_w16(int devind, int port, u16_t value);
! void pci_attr_w32(int devind, int port, u32_t value);
! char *pci_dev_name(u16_t vid, u16_t did);
! char *pci_slot_name(int devind);
! int pci_set_acl(struct rs_pci *rs_pci);
! int pci_del_acl(endpoint_t proc_ep);
! int pci_get_bar(int devind, int port, u32_t *base, u32_t *size, int
! 	*ioflag);
! 
! /* Profiling. */
! int sys_sprof(int action, int size, int freq, int type, endpoint_t
! 	endpt, void *ctl_ptr, void *mem_ptr);
! int sys_cprof(int action, int size, endpoint_t endpt, void *ctl_ptr,
! 	void *mem_ptr);
! int sys_profbuf(void *ctl_ptr, void *mem_ptr);
! 
! /* machine context */
! int sys_getmcontext(endpoint_t proc, mcontext_t *mcp);
! int sys_setmcontext(endpoint_t proc, mcontext_t *mcp);
! 
! /* input */
! int tty_input_inject(int type, int code, int val);
! 
! #endif /* _SYSLIB_H */
! 
--- 1,251 ----
! /* Prototypes for system library functions. */
! 
! #ifndef _SYSLIB_H
! #define _SYSLIB_H
! 
! #include <sys/types.h>
! #include <sys/sigtypes.h>
! 
! #include <minix/ipc.h>
! #include <minix/u64.h>
! #include <minix/devio.h>
! 
! #include <minix/safecopies.h>
! #include <minix/sef.h>
! #include <machine/mcontext.h>
! 
! /* Forward declaration */
! struct reg86u;
! struct rs_pci;
! 
! #define SYSTASK SYSTEM
! 
! /*==========================================================================* 
!  * Minix system library. 						    *
!  *==========================================================================*/ 
! int _taskcall(endpoint_t who, int syscallnr, message *msgptr);
! int _kernel_call(int syscallnr, message *msgptr);
! 
! int sys_chrealtime(endpoint_t proc_ep, long deadline);//new added.2016.12.3 kernel call for change real time
! 
! int sys_abort(int how);
! int sys_enable_iop(endpoint_t proc_ep);
! int sys_exec(endpoint_t proc_ep, char *ptr, char *aout, vir_bytes
! 	initpc);
! int sys_fork(endpoint_t parent, endpoint_t child, endpoint_t *, 
! 	u32_t vm, vir_bytes *);
! int sys_clear(endpoint_t proc_ep);
! int sys_exit(void);
! int sys_trace(int req, endpoint_t proc_ep, long addr, long *data_p);
! 
! int sys_schedule(endpoint_t proc_ep, int priority, int quantum, int
! 	cpu);
! int sys_schedctl(unsigned flags, endpoint_t proc_ep, int priority, int
! 	quantum, int cpu);
! 
! /* Shorthands for sys_runctl() system call. */
! #define sys_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, 0)
! #define sys_delay_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, RC_DELAY)
! #define sys_resume(proc_ep) sys_runctl(proc_ep, RC_RESUME, 0)
! int sys_runctl(endpoint_t proc_ep, int action, int flags);
! 
! int sys_update(endpoint_t src_ep, endpoint_t dst_ep);
! int sys_statectl(int request);
! int sys_privctl(endpoint_t proc_ep, int req, void *p);
! int sys_privquery_mem(endpoint_t proc_ep, phys_bytes physstart,
! 	phys_bytes physlen);
! int sys_setgrant(cp_grant_t *grants, int ngrants);
! 
! int sys_int86(struct reg86u *reg86p);
! int sys_vm_setbuf(phys_bytes base, phys_bytes size, phys_bytes high);
! int sys_vm_map(endpoint_t proc_ep, int do_map, phys_bytes base,
! 	phys_bytes size, phys_bytes offset);
! int sys_vmctl(endpoint_t who, int param, u32_t value);
! int sys_vmctl_get_pdbr(endpoint_t who, u32_t *pdbr);
! int sys_vmctl_get_memreq(endpoint_t *who, vir_bytes *mem, vir_bytes
! 	*len, int *wrflag, endpoint_t *who_s, vir_bytes *mem_s, endpoint_t *);
! int sys_vmctl_enable_paging(void * data);
! 
! int sys_readbios(phys_bytes address, void *buf, size_t size);
! int sys_stime(time_t boottime);
! int sys_sysctl(int ctl, char *arg1, int arg2);
! int sys_sysctl_stacktrace(endpoint_t who);
! int sys_vmctl_get_mapping(int index, phys_bytes *addr, phys_bytes *len,
! 	int *flags);
! int sys_vmctl_reply_mapping(int index, vir_bytes addr);
! int sys_vmctl_set_addrspace(endpoint_t who, phys_bytes ptroot, void
! 	*ptroot_v);
! 
! 
! /* Shorthands for sys_sdevio() system call. */
! #define sys_insb(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_INPUT_BYTE, port, proc_ep, buffer, count, 0)
! #define sys_insw(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_INPUT_WORD, port, proc_ep, buffer, count, 0)
! #define sys_outsb(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_OUTPUT_BYTE, port, proc_ep, buffer, count, 0)
! #define sys_outsw(port, proc_ep, buffer, count) \
!   sys_sdevio(DIO_OUTPUT_WORD, port, proc_ep, buffer, count, 0)
! #define sys_safe_insb(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_INPUT_BYTE, port, ept, (void*)grant, count, offset)
! #define sys_safe_outsb(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_OUTPUT_BYTE, port, ept, (void*)grant, count, offset)
! #define sys_safe_insw(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_INPUT_WORD, port, ept, (void*)grant, count, offset)
! #define sys_safe_outsw(port, ept, grant, offset, count) \
!   sys_sdevio(DIO_SAFE_OUTPUT_WORD, port, ept, (void*)grant, count, offset)
! int sys_sdevio(int req, long port, endpoint_t proc_ep, void *buffer, int
! 	count, vir_bytes offset);
! void *alloc_contig(size_t len, int flags, phys_bytes *phys);
! int free_contig(void *addr, size_t len);
! 
! #define AC_ALIGN4K	0x01
! #define AC_LOWER16M	0x02
! #define AC_ALIGN64K	0x04
! #define AC_LOWER1M	0x08
! 
! /* Clock functionality: get system times, (un)schedule an alarm call, or
!  * retrieve/set a process-virtual timer.
!  */
! int sys_times(endpoint_t proc_ep, clock_t *user_time, clock_t *sys_time,
! 	clock_t *uptime, time_t *boottime);
! int sys_setalarm(clock_t exp_time, int abs_time);
! int sys_vtimer(endpoint_t proc_nr, int which, clock_t *newval, clock_t
! 	*oldval);
! 
! /* Shorthands for sys_irqctl() system call. */
! #define sys_irqdisable(hook_id) \
!     sys_irqctl(IRQ_DISABLE, 0, 0, hook_id) 
! #define sys_irqenable(hook_id) \
!     sys_irqctl(IRQ_ENABLE, 0, 0, hook_id) 
! #define sys_irqsetpolicy(irq_vec, policy, hook_id) \
!     sys_irqctl(IRQ_SETPOLICY, irq_vec, policy, hook_id)
! #define sys_irqrmpolicy(hook_id) \
!     sys_irqctl(IRQ_RMPOLICY, 0, 0, hook_id)
! int sys_irqctl(int request, int irq_vec, int policy, int *irq_hook_id);
! 
! /* Shorthands for sys_vircopy() and sys_physcopy() system calls. */
! #define sys_datacopy sys_vircopy
! int sys_vircopy(endpoint_t src_proc, vir_bytes src_v,
! 	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes);
! 
! #define sys_abscopy(src_phys, dst_phys, bytes) \
! 	sys_physcopy(NONE, src_phys, NONE, dst_phys, bytes)
! int sys_physcopy(endpoint_t src_proc, vir_bytes src_vir,
! 	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes);
! 
! 
! /* Grant-based copy functions. */
! int sys_safecopyfrom(endpoint_t source, cp_grant_id_t grant, vir_bytes
! 	grant_offset, vir_bytes my_address, size_t bytes);
! int sys_safecopyto(endpoint_t dest, cp_grant_id_t grant, vir_bytes
! 	grant_offset, vir_bytes my_address, size_t bytes);
! int sys_vsafecopy(struct vscp_vec *copyvec, int elements);
! 
! int sys_safememset(endpoint_t source, cp_grant_id_t grant, vir_bytes
! 	grant_offset, int pattern, size_t bytes);
! 
! int sys_memset(endpoint_t who, unsigned long pattern,
! 	phys_bytes base, phys_bytes bytes);
! 
! int sys_vumap(endpoint_t endpt, struct vumap_vir *vvec,
! 	int vcount, size_t offset, int access, struct vumap_phys *pvec,
! 	int *pcount);
! int sys_umap(endpoint_t proc_ep, int seg, vir_bytes vir_addr, vir_bytes
! 	bytes, phys_bytes *phys_addr);
! int sys_umap_data_fb(endpoint_t proc_ep, vir_bytes vir_addr, vir_bytes
! 	bytes, phys_bytes *phys_addr);
! int sys_umap_remote(endpoint_t proc_ep, endpoint_t grantee, int seg,
! 	vir_bytes vir_addr, vir_bytes bytes, phys_bytes *phys_addr);
! 
! /* Shorthands for sys_getinfo() system call. */
! #define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
! #define sys_getloadinfo(dst)	sys_getinfo(GET_LOADINFO, dst, 0,0,0)
! #define sys_getmachine(dst)	sys_getinfo(GET_MACHINE, dst, 0,0,0)
! #define sys_getcpuinfo(dst)     sys_getinfo(GET_CPUINFO, dst, 0,0,0)
! #define sys_getproctab(dst)	sys_getinfo(GET_PROCTAB, dst, 0,0,0)
! #define sys_getprivtab(dst)	sys_getinfo(GET_PRIVTAB, dst, 0,0,0)
! #define sys_getproc(dst,nr)	sys_getinfo(GET_PROC, dst, 0,0, nr)
! #define sys_getrandomness(dst)	sys_getinfo(GET_RANDOMNESS, dst, 0,0,0)
! #define sys_getrandom_bin(d,b)	sys_getinfo(GET_RANDOMNESS_BIN, d, 0,0,b)
! #define sys_getimage(dst)	sys_getinfo(GET_IMAGE, dst, 0,0,0)
! #define sys_getirqhooks(dst)	sys_getinfo(GET_IRQHOOKS, dst, 0,0,0)
! #define sys_getirqactids(dst)	sys_getinfo(GET_IRQACTIDS, dst, 0,0,0)
! #define sys_getmonparams(v,vl)	sys_getinfo(GET_MONPARAMS, v,vl, 0,0)
! #define sys_getschedinfo(v1,v2)	sys_getinfo(GET_SCHEDINFO, v1,0, v2,0)
! #define sys_getpriv(dst, nr)	sys_getinfo(GET_PRIV, dst, 0,0, nr)
! #define sys_getidletsc(dst)	sys_getinfo(GET_IDLETSC, dst, 0,0,0)
! #define sys_getregs(dst,nr)	sys_getinfo(GET_REGS, dst, 0,0, nr)
! int sys_getinfo(int request, void *val_ptr, int val_len, void *val_ptr2,
! 	int val_len2);
! int sys_whoami(endpoint_t *ep, char *name, int namelen, int
! 	*priv_flags);
! 
! /* Signal control. */
! int sys_kill(endpoint_t proc_ep, int sig);
! int sys_sigsend(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
! int sys_sigreturn(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
! int sys_getksig(endpoint_t *proc_ep, sigset_t *k_sig_map);
! int sys_endksig(endpoint_t proc_ep);
! 
! /* NOTE: two different approaches were used to distinguish the device I/O
!  * types 'byte', 'word', 'long': the latter uses #define and results in a
!  * smaller implementation, but looses the static type checking.
!  */
! int sys_voutb(pvb_pair_t *pvb_pairs, int nr_ports);
! int sys_voutw(pvw_pair_t *pvw_pairs, int nr_ports);
! int sys_voutl(pvl_pair_t *pvl_pairs, int nr_ports);
! int sys_vinb(pvb_pair_t *pvb_pairs, int nr_ports);
! int sys_vinw(pvw_pair_t *pvw_pairs, int nr_ports);
! int sys_vinl(pvl_pair_t *pvl_pairs, int nr_ports);
! 
! /* Shorthands for sys_out() system call. */
! #define sys_outb(p,v)	sys_out((p), (u32_t) (v), _DIO_BYTE)
! #define sys_outw(p,v)	sys_out((p), (u32_t) (v), _DIO_WORD)
! #define sys_outl(p,v)	sys_out((p), (u32_t) (v), _DIO_LONG)
! int sys_out(int port, u32_t value, int type);
! 
! /* Shorthands for sys_in() system call. */
! #define sys_inb(p,v)	sys_in((p), (v), _DIO_BYTE)
! #define sys_inw(p,v)	sys_in((p), (v), _DIO_WORD)
! #define sys_inl(p,v)	sys_in((p), (v), _DIO_LONG)
! int sys_in(int port, u32_t *value, int type);
! 
! /* pci.c */
! void pci_init(void);
! int pci_first_dev(int *devindp, u16_t *vidp, u16_t *didp);
! int pci_next_dev(int *devindp, u16_t *vidp, u16_t *didp);
! int pci_find_dev(u8_t bus, u8_t dev, u8_t func, int *devindp);
! void pci_reserve(int devind);
! int pci_reserve_ok(int devind);
! void pci_ids(int devind, u16_t *vidp, u16_t *didp);
! void pci_rescan_bus(u8_t busnr);
! u8_t pci_attr_r8(int devind, int port);
! u16_t pci_attr_r16(int devind, int port);
! u32_t pci_attr_r32(int devind, int port);
! void pci_attr_w8(int devind, int port, u8_t value);
! void pci_attr_w16(int devind, int port, u16_t value);
! void pci_attr_w32(int devind, int port, u32_t value);
! char *pci_dev_name(u16_t vid, u16_t did);
! char *pci_slot_name(int devind);
! int pci_set_acl(struct rs_pci *rs_pci);
! int pci_del_acl(endpoint_t proc_ep);
! int pci_get_bar(int devind, int port, u32_t *base, u32_t *size, int
! 	*ioflag);
! 
! /* Profiling. */
! int sys_sprof(int action, int size, int freq, int type, endpoint_t
! 	endpt, void *ctl_ptr, void *mem_ptr);
! int sys_cprof(int action, int size, endpoint_t endpt, void *ctl_ptr,
! 	void *mem_ptr);
! int sys_profbuf(void *ctl_ptr, void *mem_ptr);
! 
! /* machine context */
! int sys_getmcontext(endpoint_t proc, mcontext_t *mcp);
! int sys_setmcontext(endpoint_t proc, mcontext_t *mcp);
! 
! /* input */
! int tty_input_inject(int type, int code, int val);
! 
! #endif /* _SYSLIB_H */
! 
diff -crN usr_orig/src/include/unistd.h EDF/src/include/unistd.h
*** usr_orig/src/include/unistd.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/include/unistd.h	2016-12-08 00:17:19.587910743 +0800
***************
*** 1,447 ****
! /*	$NetBSD: unistd.h,v 1.135 2012/07/14 15:06:26 darrenr Exp $	*/
! 
! /*-
!  * Copyright (c) 1998, 1999, 2008 The NetBSD Foundation, Inc.
!  * All rights reserved.
!  *
!  * This code is derived from software contributed to The NetBSD Foundation
!  * by Klaus Klein.
!  *
!  * Redistribution and use in source and binary forms, with or without
!  * modification, are permitted provided that the following conditions
!  * are met:
!  * 1. Redistributions of source code must retain the above copyright
!  *    notice, this list of conditions and the following disclaimer.
!  * 2. Redistributions in binary form must reproduce the above copyright
!  *    notice, this list of conditions and the following disclaimer in the
!  *    documentation and/or other materials provided with the distribution.
!  *
!  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
!  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
!  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
!  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
!  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
!  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
!  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
!  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
!  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
!  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
!  * POSSIBILITY OF SUCH DAMAGE.
!  */
! 
! /*
!  * Copyright (c) 1991, 1993, 1994
!  *	The Regents of the University of California.  All rights reserved.
!  *
!  * Redistribution and use in source and binary forms, with or without
!  * modification, are permitted provided that the following conditions
!  * are met:
!  * 1. Redistributions of source code must retain the above copyright
!  *    notice, this list of conditions and the following disclaimer.
!  * 2. Redistributions in binary form must reproduce the above copyright
!  *    notice, this list of conditions and the following disclaimer in the
!  *    documentation and/or other materials provided with the distribution.
!  * 3. Neither the name of the University nor the names of its contributors
!  *    may be used to endorse or promote products derived from this software
!  *    without specific prior written permission.
!  *
!  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
!  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
!  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
!  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
!  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
!  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
!  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
!  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
!  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
!  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
!  * SUCH DAMAGE.
!  *
!  *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
!  */
! 
! #ifndef _UNISTD_H_
! #define	_UNISTD_H_
! 
! #include <machine/ansi.h>
! #include <machine/int_types.h>
! #include <sys/cdefs.h>
! #include <sys/featuretest.h>
! #include <sys/types.h>
! #include <sys/unistd.h>
! 
! #if _FORTIFY_SOURCE > 0
! #include <ssp/unistd.h>
! #endif
! 
! /*
!  * IEEE Std 1003.1-90
!  */
! #define	STDIN_FILENO	0	/* standard input file descriptor */
! #define	STDOUT_FILENO	1	/* standard output file descriptor */
! #define	STDERR_FILENO	2	/* standard error file descriptor */
! 
! #include <sys/null.h>
! 
! __BEGIN_DECLS
! __dead	 void _exit(int);
! int	 access(const char *, int);
! unsigned int alarm(unsigned int);
! int	 chdir(const char *);
! #if !defined(__minix) && (defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE))
! int	chown(const char *, uid_t, gid_t) __RENAME(__posix_chown);
! #else
! int	chown(const char *, uid_t, gid_t);
! #endif /* defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) */
! int	 close(int);
! size_t	 confstr(int, char *, size_t);
! #ifndef __CUSERID_DECLARED
! #define __CUSERID_DECLARED
! /* also declared in stdio.h */
! char	*cuserid(char *);	/* obsolete */
! #endif /* __CUSERID_DECLARED */
! int	 dup(int);
! int	 dup2(int, int);
! int	 execl(const char *, const char *, ...);
! int	 execle(const char *, const char *, ...);
! int	 execlp(const char *, const char *, ...);
! int	 execv(const char *, char * const *);
! int	 execve(const char *, char * const *, char * const *);
! int	 execvp(const char *, char * const *);
! pid_t	 fork(void);
! long	 fpathconf(int, int);
! #if __SSP_FORTIFY_LEVEL == 0
! char	*getcwd(char *, size_t);
! #endif
! gid_t	 getegid(void);
! uid_t	 geteuid(void);
! gid_t	 getgid(void);
! int	 getgroups(int, gid_t []);
! __aconst char *getlogin(void);
! int	 getlogin_r(char *, size_t);
! pid_t	 getpgrp(void);
! pid_t	 getpid(void);
! pid_t	 getppid(void);
! uid_t	 getuid(void);
! int	 isatty(int);
! int	 link(const char *, const char *);
! long	 pathconf(const char *, int);
! int	 pause(void);
! int	 pipe(int *);
! #if __SSP_FORTIFY_LEVEL == 0
! ssize_t	 read(int, void *, size_t);
! #endif
! int	 rmdir(const char *);
! int	 setgid(gid_t);
! #ifndef __minix
! int	 setpgid(pid_t, pid_t);
! #endif /* !__minix */
! pid_t	 setsid(void);
! int	 setuid(uid_t);
! unsigned int	 sleep(unsigned int);
! long	 sysconf(int);
! pid_t	 tcgetpgrp(int);
! int	 tcsetpgrp(int, pid_t);
! __aconst char *ttyname(int);
! int	 unlink(const char *);
! ssize_t	 write(int, const void *, size_t);
! 
! 
! /*
!  * IEEE Std 1003.2-92, adopted in X/Open Portability Guide Issue 4 and later
!  */
! #if (_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE) || \
!     defined(_NETBSD_SOURCE)
! int	 getopt(int, char * const [], const char *);
! 
! extern	 char *optarg;			/* getopt(3) external variables */
! extern	 int opterr;
! extern	 int optind;
! extern	 int optopt;
! #endif
! 
! /*
!  * The Open Group Base Specifications, Issue 6; IEEE Std 1003.1-2001 (POSIX)
!  */
! #if (_POSIX_C_SOURCE - 0) >= 200112L || (_XOPEN_SOURCE - 0) >= 600 || \
!     defined(_NETBSD_SOURCE)
! int	 setegid(gid_t);
! int	 seteuid(uid_t);
! #endif
! 
! /*
!  * The following three syscalls are also defined in <sys/types.h>
!  * We protect them against double declarations.
!  */
! #ifndef __OFF_T_SYSCALLS_DECLARED
! #define __OFF_T_SYSCALLS_DECLARED
! off_t	 lseek(int, off_t, int);
! int	 truncate(const char *, off_t);
! /*
!  * IEEE Std 1003.1b-93,
!  * also found in X/Open Portability Guide >= Issue 4 Verion 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199309L || \
!     (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
!     (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! int	 ftruncate(int, off_t);
! #endif
! #endif /* __OFF_T_SYSCALLS_DECLARED */
! 
! 
! /*
!  * IEEE Std 1003.1b-93, adopted in X/Open CAE Specification Issue 5 Version 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199309L || (_XOPEN_SOURCE - 0) >= 500 || \
!     defined(_NETBSD_SOURCE)
! #ifndef __minix 
! int	 fdatasync(int);
! #endif /* !__minix */
! int	 fsync(int);
! #endif
! 
! 
! /*
!  * IEEE Std 1003.1c-95, also adopted by X/Open CAE Spec Issue 5 Version 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199506L || (_XOPEN_SOURCE - 0) >= 500 || \
!     defined(_REENTRANT) || defined(_NETBSD_SOURCE)
! int	 ttyname_r(int, char *, size_t);
! int	 pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
! #endif
! 
! /*
!  * X/Open Portability Guide, all issues
!  */
! #if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
! int	 chroot(const char *);
! int	 nice(int);
! #endif
! 
! 
! /*
!  * X/Open Portability Guide >= Issue 4
!  */
! #if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
! __aconst char *crypt(const char *, const char *);
! int	 encrypt(char *, int);
! char	*getpass(const char *);
! pid_t	 getsid(pid_t);
! #endif
! 
! 
! /*
!  * X/Open Portability Guide >= Issue 4 Version 2
!  */
! #if (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
!     (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! #ifndef	intptr_t
! typedef	__intptr_t	intptr_t;
! #define	intptr_t	__intptr_t
! #endif
! 
! #define F_ULOCK		0
! #define F_LOCK		1
! #define F_TLOCK		2
! #define F_TEST		3
! 
! int	 brk(void *);
! int	 fchdir(int);
! #if !defined(__minix) && defined(_XOPEN_SOURCE)
! int	 fchown(int, uid_t, gid_t) __RENAME(__posix_fchown);
! #else
! int	 fchown(int, uid_t, gid_t);
! #endif
! int	 getdtablesize(void);
! long	 gethostid(void);
! int	 gethostname(char *, size_t);
! __pure int
! 	 getpagesize(void);		/* legacy */
! #ifndef __minix
! pid_t	 getpgid(pid_t);
! #if defined(_XOPEN_SOURCE)
! int	 lchown(const char *, uid_t, gid_t) __RENAME(__posix_lchown);
! #else
! int	 lchown(const char *, uid_t, gid_t);
! #endif
! #endif /* !__minix */
! int	 lockf(int, int, off_t);
! #if __SSP_FORTIFY_LEVEL == 0
! ssize_t	 readlink(const char * __restrict, char * __restrict, size_t);
! #endif
! void	*sbrk(intptr_t);
! #ifndef __minix
! /* XXX prototype wrong! */
! int	 setpgrp(pid_t, pid_t);			/* obsoleted by setpgid() */
! int	 setregid(gid_t, gid_t);
! int	 setreuid(uid_t, uid_t);
! #endif /* !__minix */
! void	 swab(const void * __restrict, void * __restrict, ssize_t);
! int	 symlink(const char *, const char *);
! void	 sync(void);
! useconds_t ualarm(useconds_t, useconds_t);
! int	 usleep(useconds_t);
! #ifndef __LIBC12_SOURCE__
! pid_t	 vfork(void) __RENAME(__vfork14) __returns_twice;
! #endif
! 
! #ifndef __AUDIT__
! char	*getwd(char *);				/* obsoleted by getcwd() */
! #endif
! #endif /* _XOPEN_SOURCE_EXTENDED || _XOPEN_SOURCE >= 500 || _NETBSD_SOURCE */
! 
! 
! /*
!  * X/Open CAE Specification Issue 5 Version 2
!  */
! #if (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! ssize_t	 pread(int, void *, size_t, off_t);
! ssize_t	 pwrite(int, const void *, size_t, off_t);
! #endif
! 
! /*
!  * X/Open Extended API set 2 (a.k.a. C063)
!  */
! #if defined(_INCOMPLETE_XOPEN_C063)
! int	linkat(int, const char *, int, const char *, int);
! int	renameat(int, const char *, int, const char *);
! int	mkfifoat(int, const char *, mode_t);
! int	mknodat(int, const char *, mode_t, uint32_t);
! int	mkdirat(int, const char *, mode_t);
! int	faccessat(int, const char *, int, int);
! int	fchmodat(int, const char *, mode_t, int);
! int	fchownat(int, const char *, uid_t, gid_t, int);
! int	fexecve(int, char * const *, char * const *);
! int	readlinkat(int, const char *, char *, size_t);
! int	symlinkat(const char *, int, const char *);
! int	unlinkat(int, const char *, int);
! #endif
! 
! 
! /*
!  * Implementation-defined extensions
!  */
! #ifdef __minix
! int lseek64(int fd, u64_t _offset, int _whence, u64_t *_newpos);
! #if defined(_MINIX)
! #include <minix/type.h>
! 
! int getprocnr(void);
! int getnprocnr(pid_t pid);
! int getpprocnr(void);
! int _pm_findproc(char *proc_name, int *proc_nr);
! int mapdriver(char *label, int major, int style, int flags);
! pid_t getnpid(endpoint_t proc_ep);
! uid_t getnuid(endpoint_t proc_ep);
! gid_t getngid(endpoint_t proc_ep);
! int getnucred(endpoint_t proc_ep, struct ucred *ucred);
! ssize_t pread64(int fd, void *buf, size_t count, u64_t where);
! ssize_t pwrite64(int fd, const void *buf, size_t count, u64_t where);
! #endif /* __MINIX */
! #endif /* __minix */
! 
! #if defined(_NETBSD_SOURCE)
! #ifndef __minix
! int	 acct(const char *);
! #endif /* !__minix */
! int	 closefrom(int);
! int	 des_cipher(const char *, char *, long, int);
! int	 des_setkey(const char *);
! int	 dup3(int, int, int);
! void	 endusershell(void);
! int	 exect(const char *, char * const *, char * const *);
! int	 fchroot(int);
! int	 fsync_range(int, int, off_t, off_t);
! int	 getdomainname(char *, size_t);
! int	 getgrouplist(const char *, gid_t, gid_t *, int *);
! int	 getgroupmembership(const char *, gid_t, gid_t *, int, int *);
! mode_t	 getmode(const void *, mode_t);
! char	*getpassfd(const char *, char *, size_t, int *, int, int);
! #define	GETPASS_NEED_TTY	0x001	/* Fail if we cannot set tty */
! #define	GETPASS_FAIL_EOF	0x002	/* Fail on EOF */
! #define	GETPASS_BUF_LIMIT	0x004	/* beep on buffer limit */
! #define	GETPASS_NO_SIGNAL	0x008	/* don't make ttychars send signals */
! #define	GETPASS_NO_BEEP		0x010	/* don't beep */
! #define	GETPASS_ECHO		0x020	/* echo characters as they are typed */
! #define	GETPASS_ECHO_STAR	0x040	/* echo '*' for each character */
! #define	GETPASS_7BIT		0x080	/* mask the high bit each char */
! #define	GETPASS_FORCE_LOWER	0x100	/* lowercase each char */
! #define	GETPASS_FORCE_UPPER	0x200	/* uppercase each char */
! #define	GETPASS_ECHO_NL		0x400	/* echo a newline if successful */
! 
! char	*getpass_r(const char *, char *, size_t);
! int	 getpeereid(int, uid_t *, gid_t *);
! int	 getsubopt(char **, char * const *, char **);
! __aconst char *getusershell(void);
! int	 initgroups(const char *, gid_t);
! int	 iruserok(uint32_t, int, const char *, const char *);
! int      issetugid(void);
! int	 nfssvc(int, void *);
! #ifndef __minix
! int	 pipe2(int *, int);
! int	 profil(char *, size_t, u_long, u_int);
! #endif /* !__minix */
! #ifndef __PSIGNAL_DECLARED
! #define __PSIGNAL_DECLARED
! /* also in signal.h */
! void	 psignal(int, const char *);
! #endif /* __PSIGNAL_DECLARED */
! int	 rcmd(char **, int, const char *, const char *, const char *, int *);
! #ifdef __minix
! int	 reboot(int);
! #else
! int	 reboot(int, char *);
! #endif
! #ifndef __minix
! int	 revoke(const char *);
! #endif
! int	 rresvport(int *);
! int	 ruserok(const char *, int, const char *, const char *);
! int	 setdomainname(const char *, size_t);
! int	 setgroups(int, const gid_t *);
! int	 sethostid(long);
! int	 sethostname(const char *, size_t);
! int	 setlogin(const char *);
! void	*setmode(const char *);
! int	 setrgid(gid_t);
! int	 setruid(uid_t);
! void	 setusershell(void);
! void	 strmode(mode_t, char *);
! #ifndef __STRSIGNAL_DECLARED
! #define __STRSIGNAL_DECLARED
! /* backwards-compatibility; also in string.h */
! __aconst char *strsignal(int);
! #endif /* __STRSIGNAL_DECLARED */
! #ifndef __minix
! int	 swapctl(int, void *, int);
! int	 swapon(const char *);			/* obsoleted by swapctl() */
! #endif /* !__minix */
! int	 syscall(int, ...);
! quad_t	 __syscall(quad_t, ...);
! int	 undelete(const char *);
! 
! #if 1 /*INET6*/
! int	 rcmd_af(char **, int, const char *,
! 	    const char *, const char *, int *, int);
! int	 rresvport_af(int *, int);
! int	 rresvport_af_addr(int *, int, void *);
! int	 iruserok_sa(const void *, int, int, const char *, const char *);
! #endif
! 
! #ifndef __SYS_SIGLIST_DECLARED
! #define __SYS_SIGLIST_DECLARED
! /* also in signal.h */
! extern const char *const *sys_siglist __RENAME(__sys_siglist14);
! #endif /* __SYS_SIGLIST_DECLARED */
! extern	 int optreset;		/* getopt(3) external variable */
! extern	 char *suboptarg;	/* getsubopt(3) external variable */
! #endif
! 
! __END_DECLS
! 
! #ifdef __minix
! /* Minix expects RBT_* flags to be included with <unistd.h> */
! #include <sys/reboot.h>
! #endif
! 
! #endif /* !_UNISTD_H_ */
--- 1,449 ----
! /*	$NetBSD: unistd.h,v 1.135 2012/07/14 15:06:26 darrenr Exp $	*/
! 
! /*-
!  * Copyright (c) 1998, 1999, 2008 The NetBSD Foundation, Inc.
!  * All rights reserved.
!  *
!  * This code is derived from software contributed to The NetBSD Foundation
!  * by Klaus Klein.
!  *
!  * Redistribution and use in source and binary forms, with or without
!  * modification, are permitted provided that the following conditions
!  * are met:
!  * 1. Redistributions of source code must retain the above copyright
!  *    notice, this list of conditions and the following disclaimer.
!  * 2. Redistributions in binary form must reproduce the above copyright
!  *    notice, this list of conditions and the following disclaimer in the
!  *    documentation and/or other materials provided with the distribution.
!  *
!  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
!  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
!  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
!  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
!  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
!  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
!  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
!  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
!  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
!  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
!  * POSSIBILITY OF SUCH DAMAGE.
!  */
! 
! /*
!  * Copyright (c) 1991, 1993, 1994
!  *	The Regents of the University of California.  All rights reserved.
!  *
!  * Redistribution and use in source and binary forms, with or without
!  * modification, are permitted provided that the following conditions
!  * are met:
!  * 1. Redistributions of source code must retain the above copyright
!  *    notice, this list of conditions and the following disclaimer.
!  * 2. Redistributions in binary form must reproduce the above copyright
!  *    notice, this list of conditions and the following disclaimer in the
!  *    documentation and/or other materials provided with the distribution.
!  * 3. Neither the name of the University nor the names of its contributors
!  *    may be used to endorse or promote products derived from this software
!  *    without specific prior written permission.
!  *
!  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
!  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
!  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
!  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
!  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
!  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
!  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
!  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
!  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
!  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
!  * SUCH DAMAGE.
!  *
!  *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
!  */
! 
! #ifndef _UNISTD_H_
! #define	_UNISTD_H_
! 
! #include <machine/ansi.h>
! #include <machine/int_types.h>
! #include <sys/cdefs.h>
! #include <sys/featuretest.h>
! #include <sys/types.h>
! #include <sys/unistd.h>
! 
! #if _FORTIFY_SOURCE > 0
! #include <ssp/unistd.h>
! #endif
! 
! /*
!  * IEEE Std 1003.1-90
!  */
! #define	STDIN_FILENO	0	/* standard input file descriptor */
! #define	STDOUT_FILENO	1	/* standard output file descriptor */
! #define	STDERR_FILENO	2	/* standard error file descriptor */
! 
! #include <sys/null.h>
! 
! __BEGIN_DECLS
! __dead	 void _exit(int);
! int	 access(const char *, int);
! unsigned int alarm(unsigned int);
! int	 chdir(const char *);
! #if !defined(__minix) && (defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE))
! int	chown(const char *, uid_t, gid_t) __RENAME(__posix_chown);
! #else
! int	chown(const char *, uid_t, gid_t);
! #endif /* defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) */
! int	 close(int);
! size_t	 confstr(int, char *, size_t);
! #ifndef __CUSERID_DECLARED
! #define __CUSERID_DECLARED
! /* also declared in stdio.h */
! char	*cuserid(char *);	/* obsolete */
! #endif /* __CUSERID_DECLARED */
! int	 dup(int);
! int	 dup2(int, int);
! int	 execl(const char *, const char *, ...);
! int	 execle(const char *, const char *, ...);
! int	 execlp(const char *, const char *, ...);
! int	 execv(const char *, char * const *);
! int	 execve(const char *, char * const *, char * const *);
! int	 execvp(const char *, char * const *);
! pid_t	 fork(void);
! long	 fpathconf(int, int);
! #if __SSP_FORTIFY_LEVEL == 0
! char	*getcwd(char *, size_t);
! #endif
! gid_t	 getegid(void);
! uid_t	 geteuid(void);
! gid_t	 getgid(void);
! int	 getgroups(int, gid_t []);
! __aconst char *getlogin(void);
! int	 getlogin_r(char *, size_t);
! pid_t	 getpgrp(void);
! pid_t	 getpid(void);
! pid_t	 getppid(void);
! uid_t	 getuid(void);
! int	 isatty(int);
! int	 link(const char *, const char *);
! long	 pathconf(const char *, int);
! int	 pause(void);
! int	 pipe(int *);
! #if __SSP_FORTIFY_LEVEL == 0
! ssize_t	 read(int, void *, size_t);
! #endif
! int	 rmdir(const char *);
! int	 setgid(gid_t);
! #ifndef __minix
! int	 setpgid(pid_t, pid_t);
! #endif /* !__minix */
! pid_t	 setsid(void);
! int	 setuid(uid_t);
! unsigned int	 sleep(unsigned int);
! long	 sysconf(int);
! pid_t	 tcgetpgrp(int);
! int	 tcsetpgrp(int, pid_t);
! __aconst char *ttyname(int);
! int	 unlink(const char *);
! ssize_t	 write(int, const void *, size_t);
! 
! 
! /*
!  * IEEE Std 1003.2-92, adopted in X/Open Portability Guide Issue 4 and later
!  */
! #if (_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE) || \
!     defined(_NETBSD_SOURCE)
! int	 getopt(int, char * const [], const char *);
! 
! extern	 char *optarg;			/* getopt(3) external variables */
! extern	 int opterr;
! extern	 int optind;
! extern	 int optopt;
! #endif
! 
! /*
!  * The Open Group Base Specifications, Issue 6; IEEE Std 1003.1-2001 (POSIX)
!  */
! #if (_POSIX_C_SOURCE - 0) >= 200112L || (_XOPEN_SOURCE - 0) >= 600 || \
!     defined(_NETBSD_SOURCE)
! int	 setegid(gid_t);
! int	 seteuid(uid_t);
! #endif
! 
! /*
!  * The following three syscalls are also defined in <sys/types.h>
!  * We protect them against double declarations.
!  */
! #ifndef __OFF_T_SYSCALLS_DECLARED
! #define __OFF_T_SYSCALLS_DECLARED
! off_t	 lseek(int, off_t, int);
! int	 truncate(const char *, off_t);
! /*
!  * IEEE Std 1003.1b-93,
!  * also found in X/Open Portability Guide >= Issue 4 Verion 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199309L || \
!     (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
!     (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! int	 ftruncate(int, off_t);
! #endif
! #endif /* __OFF_T_SYSCALLS_DECLARED */
! 
! 
! /*
!  * IEEE Std 1003.1b-93, adopted in X/Open CAE Specification Issue 5 Version 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199309L || (_XOPEN_SOURCE - 0) >= 500 || \
!     defined(_NETBSD_SOURCE)
! #ifndef __minix 
! int	 fdatasync(int);
! #endif /* !__minix */
! int	 fsync(int);
! #endif
! 
! 
! /*
!  * IEEE Std 1003.1c-95, also adopted by X/Open CAE Spec Issue 5 Version 2
!  */
! #if (_POSIX_C_SOURCE - 0) >= 199506L || (_XOPEN_SOURCE - 0) >= 500 || \
!     defined(_REENTRANT) || defined(_NETBSD_SOURCE)
! int	 ttyname_r(int, char *, size_t);
! int	 pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
! #endif
! 
! /*
!  * X/Open Portability Guide, all issues
!  */
! #if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
! int	 chroot(const char *);
! int	 nice(int);
! #endif
! 
! 
! /*
!  * X/Open Portability Guide >= Issue 4
!  */
! #if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
! __aconst char *crypt(const char *, const char *);
! int	 encrypt(char *, int);
! char	*getpass(const char *);
! pid_t	 getsid(pid_t);
! #endif
! 
! 
! /*
!  * X/Open Portability Guide >= Issue 4 Version 2
!  */
! #if (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
!     (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! #ifndef	intptr_t
! typedef	__intptr_t	intptr_t;
! #define	intptr_t	__intptr_t
! #endif
! 
! #define F_ULOCK		0
! #define F_LOCK		1
! #define F_TLOCK		2
! #define F_TEST		3
! 
! int	 brk(void *);
! int	 fchdir(int);
! #if !defined(__minix) && defined(_XOPEN_SOURCE)
! int	 fchown(int, uid_t, gid_t) __RENAME(__posix_fchown);
! #else
! int	 fchown(int, uid_t, gid_t);
! #endif
! int	 getdtablesize(void);
! long	 gethostid(void);
! int	 gethostname(char *, size_t);
! __pure int
! 	 getpagesize(void);		/* legacy */
! #ifndef __minix
! pid_t	 getpgid(pid_t);
! #if defined(_XOPEN_SOURCE)
! int	 lchown(const char *, uid_t, gid_t) __RENAME(__posix_lchown);
! #else
! int	 lchown(const char *, uid_t, gid_t);
! #endif
! #endif /* !__minix */
! int	 lockf(int, int, off_t);
! #if __SSP_FORTIFY_LEVEL == 0
! ssize_t	 readlink(const char * __restrict, char * __restrict, size_t);
! #endif
! void	*sbrk(intptr_t);
! #ifndef __minix
! /* XXX prototype wrong! */
! int	 setpgrp(pid_t, pid_t);			/* obsoleted by setpgid() */
! int	 setregid(gid_t, gid_t);
! int	 setreuid(uid_t, uid_t);
! #endif /* !__minix */
! void	 swab(const void * __restrict, void * __restrict, ssize_t);
! int	 symlink(const char *, const char *);
! void	 sync(void);
! useconds_t ualarm(useconds_t, useconds_t);
! int	 usleep(useconds_t);
! #ifndef __LIBC12_SOURCE__
! pid_t	 vfork(void) __RENAME(__vfork14) __returns_twice;
! #endif
! 
! #ifndef __AUDIT__
! char	*getwd(char *);				/* obsoleted by getcwd() */
! #endif
! #endif /* _XOPEN_SOURCE_EXTENDED || _XOPEN_SOURCE >= 500 || _NETBSD_SOURCE */
! 
! 
! /*
!  * X/Open CAE Specification Issue 5 Version 2
!  */
! #if (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
! ssize_t	 pread(int, void *, size_t, off_t);
! ssize_t	 pwrite(int, const void *, size_t, off_t);
! #endif
! 
! /*
!  * X/Open Extended API set 2 (a.k.a. C063)
!  */
! #if defined(_INCOMPLETE_XOPEN_C063)
! int	linkat(int, const char *, int, const char *, int);
! int	renameat(int, const char *, int, const char *);
! int	mkfifoat(int, const char *, mode_t);
! int	mknodat(int, const char *, mode_t, uint32_t);
! int	mkdirat(int, const char *, mode_t);
! int	faccessat(int, const char *, int, int);
! int	fchmodat(int, const char *, mode_t, int);
! int	fchownat(int, const char *, uid_t, gid_t, int);
! int	fexecve(int, char * const *, char * const *);
! int	readlinkat(int, const char *, char *, size_t);
! int	symlinkat(const char *, int, const char *);
! int	unlinkat(int, const char *, int);
! #endif
! 
! 
! /*
!  * Implementation-defined extensions
!  */
! #ifdef __minix
! int lseek64(int fd, u64_t _offset, int _whence, u64_t *_newpos);
! #if defined(_MINIX)
! #include <minix/type.h>
! 
! int getprocnr(void);
! int getnprocnr(pid_t pid);
! int getpprocnr(void);
! int _pm_findproc(char *proc_name, int *proc_nr);
! int mapdriver(char *label, int major, int style, int flags);
! pid_t getnpid(endpoint_t proc_ep);
! uid_t getnuid(endpoint_t proc_ep);
! gid_t getngid(endpoint_t proc_ep);
! int getnucred(endpoint_t proc_ep, struct ucred *ucred);
! ssize_t pread64(int fd, void *buf, size_t count, u64_t where);
! ssize_t pwrite64(int fd, const void *buf, size_t count, u64_t where);
! #endif /* __MINIX */
! #endif /* __minix */
! 
! #if defined(_NETBSD_SOURCE)
! #ifndef __minix
! int	 acct(const char *);
! #endif /* !__minix */
! int	 closefrom(int);
! int	 des_cipher(const char *, char *, long, int);
! int	 des_setkey(const char *);
! int	 dup3(int, int, int);
! void	 endusershell(void);
! int	 exect(const char *, char * const *, char * const *);
! int	 fchroot(int);
! int	 fsync_range(int, int, off_t, off_t);
! int	 getdomainname(char *, size_t);
! int	 getgrouplist(const char *, gid_t, gid_t *, int *);
! int	 getgroupmembership(const char *, gid_t, gid_t *, int, int *);
! mode_t	 getmode(const void *, mode_t);
! char	*getpassfd(const char *, char *, size_t, int *, int, int);
! #define	GETPASS_NEED_TTY	0x001	/* Fail if we cannot set tty */
! #define	GETPASS_FAIL_EOF	0x002	/* Fail on EOF */
! #define	GETPASS_BUF_LIMIT	0x004	/* beep on buffer limit */
! #define	GETPASS_NO_SIGNAL	0x008	/* don't make ttychars send signals */
! #define	GETPASS_NO_BEEP		0x010	/* don't beep */
! #define	GETPASS_ECHO		0x020	/* echo characters as they are typed */
! #define	GETPASS_ECHO_STAR	0x040	/* echo '*' for each character */
! #define	GETPASS_7BIT		0x080	/* mask the high bit each char */
! #define	GETPASS_FORCE_LOWER	0x100	/* lowercase each char */
! #define	GETPASS_FORCE_UPPER	0x200	/* uppercase each char */
! #define	GETPASS_ECHO_NL		0x400	/* echo a newline if successful */
! 
! char	*getpass_r(const char *, char *, size_t);
! int	 getpeereid(int, uid_t *, gid_t *);
! int	 getsubopt(char **, char * const *, char **);
! __aconst char *getusershell(void);
! int	 initgroups(const char *, gid_t);
! int	 iruserok(uint32_t, int, const char *, const char *);
! int      issetugid(void);
! int	 nfssvc(int, void *);
! #ifndef __minix
! int	 pipe2(int *, int);
! int	 profil(char *, size_t, u_long, u_int);
! #endif /* !__minix */
! #ifndef __PSIGNAL_DECLARED
! #define __PSIGNAL_DECLARED
! /* also in signal.h */
! void	 psignal(int, const char *);
! #endif /* __PSIGNAL_DECLARED */
! int	 rcmd(char **, int, const char *, const char *, const char *, int *);
! #ifdef __minix
! int	 reboot(int);
! #else
! int	 reboot(int, char *);
! #endif
! #ifndef __minix
! int	 revoke(const char *);
! #endif
! int	 rresvport(int *);
! int	 ruserok(const char *, int, const char *, const char *);
! int	 setdomainname(const char *, size_t);
! int	 setgroups(int, const gid_t *);
! int	 sethostid(long);
! int	 sethostname(const char *, size_t);
! int	 setlogin(const char *);
! void	*setmode(const char *);
! int	 setrgid(gid_t);
! int	 setruid(uid_t);
! void	 setusershell(void);
! void	 strmode(mode_t, char *);
! #ifndef __STRSIGNAL_DECLARED
! #define __STRSIGNAL_DECLARED
! /* backwards-compatibility; also in string.h */
! __aconst char *strsignal(int);
! #endif /* __STRSIGNAL_DECLARED */
! #ifndef __minix
! int	 swapctl(int, void *, int);
! int	 swapon(const char *);			/* obsoleted by swapctl() */
! #endif /* !__minix */
! int	 syscall(int, ...);
! quad_t	 __syscall(quad_t, ...);
! int	 undelete(const char *);
! 
! #if 1 /*INET6*/
! int	 rcmd_af(char **, int, const char *,
! 	    const char *, const char *, int *, int);
! int	 rresvport_af(int *, int);
! int	 rresvport_af_addr(int *, int, void *);
! int	 iruserok_sa(const void *, int, int, const char *, const char *);
! #endif
! 
! #ifndef __SYS_SIGLIST_DECLARED
! #define __SYS_SIGLIST_DECLARED
! /* also in signal.h */
! extern const char *const *sys_siglist __RENAME(__sys_siglist14);
! #endif /* __SYS_SIGLIST_DECLARED */
! extern	 int optreset;		/* getopt(3) external variable */
! extern	 char *suboptarg;	/* getsubopt(3) external variable */
! #endif
! 
! int chrealtime(long deadline);
! 
! __END_DECLS
! 
! #ifdef __minix
! /* Minix expects RBT_* flags to be included with <unistd.h> */
! #include <sys/reboot.h>
! #endif
! 
! #endif /* !_UNISTD_H_ */
diff -crN usr_orig/src/kernel/config.h EDF/src/kernel/config.h
*** usr_orig/src/kernel/config.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/config.h	2016-12-08 00:17:19.587910743 +0800
***************
*** 1,61 ****
! #ifndef CONFIG_H
! #define CONFIG_H
! 
! /* This file defines the kernel configuration. It allows to set sizes of some
!  * kernel buffers and to enable or disable debugging code, timing features, 
!  * and individual kernel calls.
!  *
!  * Changes:
!  *   Jul 11, 2005	Created.  (Jorrit N. Herder)
!  */
! 
! /* In embedded and sensor applications, not all the kernel calls may be
!  * needed. In this section you can specify which kernel calls are needed
!  * and which are not. The code for unneeded kernel calls is not included in
!  * the system binary, making it smaller. If you are not sure, it is best
!  * to keep all kernel calls enabled.
!  */
! #define USE_FORK       	   1	/* fork a new process */
! #define USE_NEWMAP     	   1	/* set a new memory map */
! #define USE_EXEC       	   1	/* update process after execute */
! #define USE_CLEAR	   1	/* clean up after process exit */
! #define USE_EXIT	   1	/* a system process wants to exit */
! #define USE_GETKSIG    	   1	/* retrieve pending kernel signals */
! #define USE_ENDKSIG    	   1	/* finish pending kernel signals */
! #define USE_KILL       	   1 	/* send a signal to a process */
! #define USE_SIGSEND    	   1	/* send POSIX-style signal */
! #define USE_SIGRETURN  	   1	/* sys_sigreturn(proc_nr, ctxt_ptr, flags) */
! #define USE_ABORT      	   1	/* shut down MINIX */
! #define USE_GETINFO    	   1 	/* retrieve a copy of kernel data */
! #define USE_TIMES 	   1	/* get process and system time info */
! #define USE_SETALARM	   1	/* schedule a synchronous alarm */
! #define USE_VTIMER         1	/* set or retrieve a process-virtual timer */
! #define USE_DEVIO      	   1	/* read or write a single I/O port */
! #define USE_VDEVIO     	   1	/* process vector with I/O requests */
! #define USE_SDEVIO     	   1	/* perform I/O request on a buffer */
! #define USE_IRQCTL     	   1	/* set an interrupt policy */
! #define USE_PRIVCTL    	   1	/* system privileges control */
! #define USE_UMAP       	   1	/* map virtual to physical address */
! #define USE_UMAP_REMOTE	   1	/* sys_umap on behalf of another process */
! #define USE_VUMAP      	   1	/* vectored virtual to physical mapping */
! #define USE_VIRCOPY   	   1	/* copy using virtual addressing */ 
! #define USE_PHYSCOPY  	   1 	/* copy using physical addressing */
! #define USE_MEMSET  	   1	/* write char to a given memory area */
! #define USE_RUNCTL         1	/* control stop flags of a process */
! 
! /* This section contains defines for valuable system resources that are used
!  * by device drivers. The number of elements of the vectors is determined by 
!  * the maximum needed by any given driver. The number of interrupt hooks may
!  * be incremented on systems with many device drivers. 
!  */
! #ifndef USE_APIC
! #define NR_IRQ_HOOKS	  16		/* number of interrupt hooks */
! #else
! #define NR_IRQ_HOOKS	  64		/* number of interrupt hooks */
! #endif
! #define VDEVIO_BUF_SIZE   64		/* max elements per VDEVIO request */
! 
! #define K_PARAM_SIZE     512
! 
! #endif /* CONFIG_H */
! 
--- 1,62 ----
! #ifndef CONFIG_H
! #define CONFIG_H
! 
! /* This file defines the kernel configuration. It allows to set sizes of some
!  * kernel buffers and to enable or disable debugging code, timing features, 
!  * and individual kernel calls.
!  *
!  * Changes:
!  *   Jul 11, 2005	Created.  (Jorrit N. Herder)
!  */
! 
! /* In embedded and sensor applications, not all the kernel calls may be
!  * needed. In this section you can specify which kernel calls are needed
!  * and which are not. The code for unneeded kernel calls is not included in
!  * the system binary, making it smaller. If you are not sure, it is best
!  * to keep all kernel calls enabled.
!  */
! #define USE_FORK       	   1	/* fork a new process */
! #define USE_NEWMAP     	   1	/* set a new memory map */
! #define USE_EXEC       	   1	/* update process after execute */
! #define USE_CLEAR	   1	/* clean up after process exit */
! #define USE_EXIT	   1	/* a system process wants to exit */
! #define USE_GETKSIG    	   1	/* retrieve pending kernel signals */
! #define USE_ENDKSIG    	   1	/* finish pending kernel signals */
! #define USE_KILL       	   1 	/* send a signal to a process */
! #define USE_SIGSEND    	   1	/* send POSIX-style signal */
! #define USE_SIGRETURN  	   1	/* sys_sigreturn(proc_nr, ctxt_ptr, flags) */
! #define USE_ABORT      	   1	/* shut down MINIX */
! #define USE_GETINFO    	   1 	/* retrieve a copy of kernel data */
! #define USE_TIMES 	   1	/* get process and system time info */
! #define USE_SETALARM	   1	/* schedule a synchronous alarm */
! #define USE_VTIMER         1	/* set or retrieve a process-virtual timer */
! #define USE_DEVIO      	   1	/* read or write a single I/O port */
! #define USE_VDEVIO     	   1	/* process vector with I/O requests */
! #define USE_SDEVIO     	   1	/* perform I/O request on a buffer */
! #define USE_IRQCTL     	   1	/* set an interrupt policy */
! #define USE_PRIVCTL    	   1	/* system privileges control */
! #define USE_UMAP       	   1	/* map virtual to physical address */
! #define USE_UMAP_REMOTE	   1	/* sys_umap on behalf of another process */
! #define USE_VUMAP      	   1	/* vectored virtual to physical mapping */
! #define USE_VIRCOPY   	   1	/* copy using virtual addressing */ 
! #define USE_PHYSCOPY  	   1 	/* copy using physical addressing */
! #define USE_MEMSET  	   1	/* write char to a given memory area */
! #define USE_RUNCTL         1	/* control stop flags of a process */
! #define USE_CHREALTIME	   1 	//use kernel call do_chrealtime
! 
! /* This section contains defines for valuable system resources that are used
!  * by device drivers. The number of elements of the vectors is determined by 
!  * the maximum needed by any given driver. The number of interrupt hooks may
!  * be incremented on systems with many device drivers. 
!  */
! #ifndef USE_APIC
! #define NR_IRQ_HOOKS	  16		/* number of interrupt hooks */
! #else
! #define NR_IRQ_HOOKS	  64		/* number of interrupt hooks */
! #endif
! #define VDEVIO_BUF_SIZE   64		/* max elements per VDEVIO request */
! 
! #define K_PARAM_SIZE     512
! 
! #endif /* CONFIG_H */
! 
diff -crN usr_orig/src/kernel/proc.c EDF/src/kernel/proc.c
*** usr_orig/src/kernel/proc.c	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/proc.c	2016-12-08 00:17:19.599910743 +0800
***************
*** 1,1890 ****
! /* This file contains essentially all of the process and message handling.
!  * Together with "mpx.s" it forms the lowest layer of the MINIX kernel.
!  * There is one entry point from the outside:
!  *
!  *   sys_call: 	      a system call, i.e., the kernel is trapped with an INT
!  *
!  * Changes:
!  *   Aug 19, 2005     rewrote scheduling code  (Jorrit N. Herder)
!  *   Jul 25, 2005     rewrote system call handling  (Jorrit N. Herder)
!  *   May 26, 2005     rewrote message passing functions  (Jorrit N. Herder)
!  *   May 24, 2005     new notification system call  (Jorrit N. Herder)
!  *   Oct 28, 2004     nonblocking send and receive calls  (Jorrit N. Herder)
!  *
!  * The code here is critical to make everything work and is important for the
!  * overall performance of the system. A large fraction of the code deals with
!  * list manipulation. To make this both easy to understand and fast to execute 
!  * pointer pointers are used throughout the code. Pointer pointers prevent
!  * exceptions for the head or tail of a linked list. 
!  *
!  *  node_t *queue, *new_node;	// assume these as global variables
!  *  node_t **xpp = &queue; 	// get pointer pointer to head of queue 
!  *  while (*xpp != NULL) 	// find last pointer of the linked list
!  *      xpp = &(*xpp)->next;	// get pointer to next pointer 
!  *  *xpp = new_node;		// now replace the end (the NULL pointer) 
!  *  new_node->next = NULL;	// and mark the new end of the list
!  * 
!  * For example, when adding a new node to the end of the list, one normally 
!  * makes an exception for an empty list and looks up the end of the list for 
!  * nonempty lists. As shown above, this is not required with pointer pointers.
!  */
! 
! #include <minix/com.h>
! #include <minix/ipcconst.h>
! #include <stddef.h>
! #include <signal.h>
! #include <assert.h>
! 
! #include "kernel/kernel.h"
! #include "vm.h"
! #include "clock.h"
! #include "spinlock.h"
! #include "arch_proto.h"
! 
! #include <minix/syslib.h>
! 
! /* Scheduling and message passing functions */
! static void idle(void);
! /**
!  * Made public for use in clock.c (for user-space scheduling)
! static int mini_send(struct proc *caller_ptr, endpoint_t dst_e, message
! 	*m_ptr, int flags);
! */
! static int mini_receive(struct proc *caller_ptr, endpoint_t src,
! 	message *m_ptr, int flags);
! static int mini_senda(struct proc *caller_ptr, asynmsg_t *table, size_t
! 	size);
! static int deadlock(int function, register struct proc *caller,
! 	endpoint_t src_dst_e);
! static int try_async(struct proc *caller_ptr);
! static int try_one(struct proc *src_ptr, struct proc *dst_ptr);
! static struct proc * pick_proc(void);
! static void enqueue_head(struct proc *rp);
! 
! /* all idles share the same idle_priv structure */
! static struct priv idle_priv;
! 
! static void set_idle_name(char * name, int n)
! {
!         int i, c;
!         int p_z = 0;
! 
!         if (n > 999) 
!                 n = 999; 
! 
!         name[0] = 'i'; 
!         name[1] = 'd'; 
!         name[2] = 'l'; 
!         name[3] = 'e'; 
! 
!         for (i = 4, c = 100; c > 0; c /= 10) {
!                 int digit;
! 
!                 digit = n / c;  
!                 n -= digit * c;  
! 
!                 if (p_z || digit != 0 || c == 1) {
!                         p_z = 1;
!                         name[i++] = '0' + digit;
!                 }   
!         }    
! 
!         name[i] = '\0';
! 
! }
! 
! 
! #define PICK_ANY	1
! #define PICK_HIGHERONLY	2
! 
! #define BuildNotifyMessage(m_ptr, src, dst_ptr) \
! 	(m_ptr)->m_type = NOTIFY_MESSAGE;				\
! 	(m_ptr)->NOTIFY_TIMESTAMP = get_uptime();			\
! 	switch (src) {							\
! 	case HARDWARE:							\
! 		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_int_pending;	\
! 		priv(dst_ptr)->s_int_pending = 0;			\
! 		break;							\
! 	case SYSTEM:							\
! 		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_sig_pending;	\
! 		priv(dst_ptr)->s_sig_pending = 0;			\
! 		break;							\
! 	}
! 
! void proc_init(void)
! {
! 	struct proc * rp;
! 	struct priv *sp;
! 	int i;
! 
! 	/* Clear the process table. Anounce each slot as empty and set up
! 	 * mappings for proc_addr() and proc_nr() macros. Do the same for the
! 	 * table with privilege structures for the system processes. 
! 	 */
! 	for (rp = BEG_PROC_ADDR, i = -NR_TASKS; rp < END_PROC_ADDR; ++rp, ++i) {
! 		rp->p_rts_flags = RTS_SLOT_FREE;/* initialize free slot */
! 		rp->p_magic = PMAGIC;
! 		rp->p_nr = i;			/* proc number from ptr */
! 		rp->p_endpoint = _ENDPOINT(0, rp->p_nr); /* generation no. 0 */
! 		rp->p_scheduler = NULL;		/* no user space scheduler */
! 		rp->p_priority = 0;		/* no priority */
! 		rp->p_quantum_size_ms = 0;	/* no quantum size */
! 
! 		/* arch-specific initialization */
! 		arch_proc_reset(rp);
! 	}
! 	for (sp = BEG_PRIV_ADDR, i = 0; sp < END_PRIV_ADDR; ++sp, ++i) {
! 		sp->s_proc_nr = NONE;		/* initialize as free */
! 		sp->s_id = (sys_id_t) i;	/* priv structure index */
! 		ppriv_addr[i] = sp;		/* priv ptr from number */
! 		sp->s_sig_mgr = NONE;		/* clear signal managers */
! 		sp->s_bak_sig_mgr = NONE;
! 	}
! 
! 	idle_priv.s_flags = IDL_F;
! 	/* initialize IDLE structures for every CPU */
! 	for (i = 0; i < CONFIG_MAX_CPUS; i++) {
! 		struct proc * ip = get_cpu_var_ptr(i, idle_proc);
! 		ip->p_endpoint = IDLE;
! 		ip->p_priv = &idle_priv;
! 		/* must not let idle ever get scheduled */
! 		ip->p_rts_flags |= RTS_PROC_STOP;
! 		set_idle_name(ip->p_name, i);
! 	}
! }
! 
! static void switch_address_space_idle(void)
! {
! #ifdef CONFIG_SMP
! 	/*
! 	 * currently we bet that VM is always alive and its pages available so
! 	 * when the CPU wakes up the kernel is mapped and no surprises happen.
! 	 * This is only a problem if more than 1 cpus are available
! 	 */
! 	switch_address_space(proc_addr(VM_PROC_NR));
! #endif
! }
! 
! /*===========================================================================*
!  *				idle					     * 
!  *===========================================================================*/
! static void idle(void)
! {
! 	struct proc * p;
! 
! 	/* This function is called whenever there is no work to do.
! 	 * Halt the CPU, and measure how many timestamp counter ticks are
! 	 * spent not doing anything. This allows test setups to measure
! 	 * the CPU utiliziation of certain workloads with high precision.
! 	 */
! 
! 	p = get_cpulocal_var(proc_ptr) = get_cpulocal_var_ptr(idle_proc);
! 	if (priv(p)->s_flags & BILLABLE)
! 		get_cpulocal_var(bill_ptr) = p;
! 
! 	switch_address_space_idle();
! 
! #ifdef CONFIG_SMP
! 	get_cpulocal_var(cpu_is_idle) = 1;
! 	/* we don't need to keep time on APs as it is handled on the BSP */
! 	if (cpuid != bsp_cpu_id)
! 		stop_local_timer();
! 	else
! #endif
! 	{
! 		/*
! 		 * If the timer has expired while in kernel we must
! 		 * rearm it before we go to sleep
! 		 */
! 		restart_local_timer();
! 	}
! 
! 	/* start accounting for the idle time */
! 	context_stop(proc_addr(KERNEL));
! #if !SPROFILE
! 	halt_cpu();
! #else
! 	if (!sprofiling)
! 		halt_cpu();
! 	else {
! 		volatile int * v;
! 
! 		v = get_cpulocal_var_ptr(idle_interrupted);
! 		interrupts_enable();
! 		while (!*v)
! 			arch_pause();
! 		interrupts_disable();
! 		*v = 0;
! 	}
! #endif
! 	/*
! 	 * end of accounting for the idle task does not happen here, the kernel
! 	 * is handling stuff for quite a while before it gets back here!
! 	 */
! }
! 
! /*===========================================================================*
!  *				switch_to_user				     * 
!  *===========================================================================*/
! void switch_to_user(void)
! {
! 	/* This function is called an instant before proc_ptr is
! 	 * to be scheduled again.
! 	 */
! 	struct proc * p;
! #ifdef CONFIG_SMP
! 	int tlb_must_refresh = 0;
! #endif
! 
! 	p = get_cpulocal_var(proc_ptr);
! 	/*
! 	 * if the current process is still runnable check the misc flags and let
! 	 * it run unless it becomes not runnable in the meantime
! 	 */
! 	if (proc_is_runnable(p))
! 		goto check_misc_flags;
! 	/*
! 	 * if a process becomes not runnable while handling the misc flags, we
! 	 * need to pick a new one here and start from scratch. Also if the
! 	 * current process wasn' runnable, we pick a new one here
! 	 */
! not_runnable_pick_new:
! 	if (proc_is_preempted(p)) {
! 		p->p_rts_flags &= ~RTS_PREEMPTED;
! 		if (proc_is_runnable(p)) {
! 			if (!is_zero64(p->p_cpu_time_left))
! 				enqueue_head(p);
! 			else
! 				enqueue(p);
! 		}
! 	}
! 
! 	/*
! 	 * if we have no process to run, set IDLE as the current process for
! 	 * time accounting and put the cpu in and idle state. After the next
! 	 * timer interrupt the execution resumes here and we can pick another
! 	 * process. If there is still nothing runnable we "schedule" IDLE again
! 	 */
! 	while (!(p = pick_proc())) {
! 		idle();
! 	}
! 
! 	/* update the global variable */
! 	get_cpulocal_var(proc_ptr) = p;
! 
! #ifdef CONFIG_SMP
! 	if (p->p_misc_flags & MF_FLUSH_TLB && get_cpulocal_var(ptproc) == p)
! 		tlb_must_refresh = 1;
! #endif
! 	switch_address_space(p);
! 
! check_misc_flags:
! 
! 	assert(p);
! 	assert(proc_is_runnable(p));
! 	while (p->p_misc_flags &
! 		(MF_KCALL_RESUME | MF_DELIVERMSG |
! 		 MF_SC_DEFER | MF_SC_TRACE | MF_SC_ACTIVE)) {
! 
! 		assert(proc_is_runnable(p));
! 		if (p->p_misc_flags & MF_KCALL_RESUME) {
! 			kernel_call_resume(p);
! 		}
! 		else if (p->p_misc_flags & MF_DELIVERMSG) {
! 			TRACE(VF_SCHEDULING, printf("delivering to %s / %d\n",
! 				p->p_name, p->p_endpoint););
! 			delivermsg(p);
! 		}
! 		else if (p->p_misc_flags & MF_SC_DEFER) {
! 			/* Perform the system call that we deferred earlier. */
! 
! 			assert (!(p->p_misc_flags & MF_SC_ACTIVE));
! 
! 			arch_do_syscall(p);
! 
! 			/* If the process is stopped for signal delivery, and
! 			 * not blocked sending a message after the system call,
! 			 * inform PM.
! 			 */
! 			if ((p->p_misc_flags & MF_SIG_DELAY) &&
! 					!RTS_ISSET(p, RTS_SENDING))
! 				sig_delay_done(p);
! 		}
! 		else if (p->p_misc_flags & MF_SC_TRACE) {
! 			/* Trigger a system call leave event if this was a
! 			 * system call. We must do this after processing the
! 			 * other flags above, both for tracing correctness and
! 			 * to be able to use 'break'.
! 			 */
! 			if (!(p->p_misc_flags & MF_SC_ACTIVE))
! 				break;
! 
! 			p->p_misc_flags &=
! 				~(MF_SC_TRACE | MF_SC_ACTIVE);
! 
! 			/* Signal the "leave system call" event.
! 			 * Block the process.
! 			 */
! 			cause_sig(proc_nr(p), SIGTRAP);
! 		}
! 		else if (p->p_misc_flags & MF_SC_ACTIVE) {
! 			/* If MF_SC_ACTIVE was set, remove it now:
! 			 * we're leaving the system call.
! 			 */
! 			p->p_misc_flags &= ~MF_SC_ACTIVE;
! 
! 			break;
! 		}
! 
! 		/*
! 		 * the selected process might not be runnable anymore. We have
! 		 * to checkit and schedule another one
! 		 */
! 		if (!proc_is_runnable(p))
! 			goto not_runnable_pick_new;
! 	}
! 	/*
! 	 * check the quantum left before it runs again. We must do it only here
! 	 * as we are sure that a possible out-of-quantum message to the
! 	 * scheduler will not collide with the regular ipc
! 	 */
! 	if (is_zero64(p->p_cpu_time_left))
! 		proc_no_time(p);
! 	/*
! 	 * After handling the misc flags the selected process might not be
! 	 * runnable anymore. We have to checkit and schedule another one
! 	 */
! 	if (!proc_is_runnable(p))
! 		goto not_runnable_pick_new;
! 
! 	TRACE(VF_SCHEDULING, printf("cpu %d starting %s / %d "
! 				"pc 0x%08x\n",
! 		cpuid, p->p_name, p->p_endpoint, p->p_reg.pc););
! #if DEBUG_TRACE
! 	p->p_schedules++;
! #endif
! 
! 	p = arch_finish_switch_to_user();
! 	assert(!is_zero64(p->p_cpu_time_left));
! 
! 	context_stop(proc_addr(KERNEL));
! 
! 	/* If the process isn't the owner of FPU, enable the FPU exception */
! 	if(get_cpulocal_var(fpu_owner) != p)
! 		enable_fpu_exception();
! 	else
! 		disable_fpu_exception();
! 
! 	/* If MF_CONTEXT_SET is set, don't clobber process state within
! 	 * the kernel. The next kernel entry is OK again though.
! 	 */
! 	p->p_misc_flags &= ~MF_CONTEXT_SET;
! 
! #if defined(__i386__)
!   	assert(p->p_seg.p_cr3 != 0);
! #elif defined(__arm__)
! 	assert(p->p_seg.p_ttbr != 0);
! #endif
! #ifdef CONFIG_SMP
! 	if (p->p_misc_flags & MF_FLUSH_TLB) {
! 		if (tlb_must_refresh)
! 			refresh_tlb();
! 		p->p_misc_flags &= ~MF_FLUSH_TLB;
! 	}
! #endif
! 	
! 	restart_local_timer();
! 	
! 	/*
! 	 * restore_user_context() carries out the actual mode switch from kernel
! 	 * to userspace. This function does not return
! 	 */
! 	restore_user_context(p);
! 	NOT_REACHABLE;
! }
! 
! /*
!  * handler for all synchronous IPC calls
!  */
! static int do_sync_ipc(struct proc * caller_ptr, /* who made the call */
! 			int call_nr,	/* system call number and flags */
! 			endpoint_t src_dst_e,	/* src or dst of the call */
! 			message *m_ptr)	/* users pointer to a message */
! {
!   int result;					/* the system call's result */
!   int src_dst_p;				/* Process slot number */
!   char *callname;
! 
!   /* Check destination. RECEIVE is the only call that accepts ANY (in addition
!    * to a real endpoint). The other calls (SEND, SENDREC, and NOTIFY) require an
!    * endpoint to corresponds to a process. In addition, it is necessary to check
!    * whether a process is allowed to send to a given destination.
!    */
!   assert(call_nr != SENDA);
! 
!   /* Only allow non-negative call_nr values less than 32 */
!   if (call_nr < 0 || call_nr > IPCNO_HIGHEST || call_nr >= 32
!       || !(callname = ipc_call_names[call_nr])) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: trap %d not allowed, caller %d, src_dst %d\n", 
!           call_nr, proc_nr(caller_ptr), src_dst_e);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   if (src_dst_e == ANY)
!   {
! 	if (call_nr != RECEIVE)
! 	{
! #if 0
! 		printf("sys_call: %s by %d with bad endpoint %d\n", 
! 			callname,
! 			proc_nr(caller_ptr), src_dst_e);
! #endif
! 		return EINVAL;
! 	}
! 	src_dst_p = (int) src_dst_e;
!   }
!   else
!   {
! 	/* Require a valid source and/or destination process. */
! 	if(!isokendpt(src_dst_e, &src_dst_p)) {
! #if 0
! 		printf("sys_call: %s by %d with bad endpoint %d\n", 
! 			callname,
! 			proc_nr(caller_ptr), src_dst_e);
! #endif
! 		return EDEADSRCDST;
! 	}
! 
! 	/* If the call is to send to a process, i.e., for SEND, SENDNB,
! 	 * SENDREC or NOTIFY, verify that the caller is allowed to send to
! 	 * the given destination. 
! 	 */
! 	if (call_nr != RECEIVE)
! 	{
! 		if (!may_send_to(caller_ptr, src_dst_p)) {
! #if DEBUG_ENABLE_IPC_WARNINGS
! 			printf(
! 			"sys_call: ipc mask denied %s from %d to %d\n",
! 				callname,
! 				caller_ptr->p_endpoint, src_dst_e);
! #endif
! 			return(ECALLDENIED);	/* call denied by ipc mask */
! 		}
! 	}
!   }
! 
!   /* Check if the process has privileges for the requested call. Calls to the 
!    * kernel may only be SENDREC, because tasks always reply and may not block 
!    * if the caller doesn't do receive(). 
!    */
!   if (!(priv(caller_ptr)->s_trap_mask & (1 << call_nr))) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: %s not allowed, caller %d, src_dst %d\n", 
!           callname, proc_nr(caller_ptr), src_dst_p);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   if (call_nr != SENDREC && call_nr != RECEIVE && iskerneln(src_dst_p)) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: trap %s not allowed, caller %d, src_dst %d\n",
!            callname, proc_nr(caller_ptr), src_dst_e);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   switch(call_nr) {
!   case SENDREC:
! 	/* A flag is set so that notifications cannot interrupt SENDREC. */
! 	caller_ptr->p_misc_flags |= MF_REPLY_PEND;
! 	/* fall through */
!   case SEND:			
! 	result = mini_send(caller_ptr, src_dst_e, m_ptr, 0);
! 	if (call_nr == SEND || result != OK)
! 		break;				/* done, or SEND failed */
! 	/* fall through for SENDREC */
!   case RECEIVE:			
! 	if (call_nr == RECEIVE) {
! 		caller_ptr->p_misc_flags &= ~MF_REPLY_PEND;
! 		IPC_STATUS_CLEAR(caller_ptr);  /* clear IPC status code */
! 	}
! 	result = mini_receive(caller_ptr, src_dst_e, m_ptr, 0);
! 	break;
!   case NOTIFY:
! 	result = mini_notify(caller_ptr, src_dst_e);
! 	break;
!   case SENDNB:
!         result = mini_send(caller_ptr, src_dst_e, m_ptr, NON_BLOCKING);
!         break;
!   default:
! 	result = EBADCALL;			/* illegal system call */
!   }
! 
!   /* Now, return the result of the system call to the caller. */
!   return(result);
! }
! 
! int do_ipc(reg_t r1, reg_t r2, reg_t r3)
! {
!   struct proc *const caller_ptr = get_cpulocal_var(proc_ptr);	/* get pointer to caller */
!   int call_nr = (int) r1;
! 
!   assert(!RTS_ISSET(caller_ptr, RTS_SLOT_FREE));
! 
!   /* bill kernel time to this process. */
!   kbill_ipc = caller_ptr;
! 
!   /* If this process is subject to system call tracing, handle that first. */
!   if (caller_ptr->p_misc_flags & (MF_SC_TRACE | MF_SC_DEFER)) {
! 	/* Are we tracing this process, and is it the first sys_call entry? */
! 	if ((caller_ptr->p_misc_flags & (MF_SC_TRACE | MF_SC_DEFER)) ==
! 							MF_SC_TRACE) {
! 		/* We must notify the tracer before processing the actual
! 		 * system call. If we don't, the tracer could not obtain the
! 		 * input message. Postpone the entire system call.
! 		 */
! 		caller_ptr->p_misc_flags &= ~MF_SC_TRACE;
! 		assert(!(caller_ptr->p_misc_flags & MF_SC_DEFER));
! 		caller_ptr->p_misc_flags |= MF_SC_DEFER;
! 		caller_ptr->p_defer.r1 = r1;
! 		caller_ptr->p_defer.r2 = r2;
! 		caller_ptr->p_defer.r3 = r3;
! 
! 		/* Signal the "enter system call" event. Block the process. */
! 		cause_sig(proc_nr(caller_ptr), SIGTRAP);
! 
! 		/* Preserve the return register's value. */
! 		return caller_ptr->p_reg.retreg;
! 	}
! 
! 	/* If the MF_SC_DEFER flag is set, the syscall is now being resumed. */
! 	caller_ptr->p_misc_flags &= ~MF_SC_DEFER;
! 
! 	assert (!(caller_ptr->p_misc_flags & MF_SC_ACTIVE));
! 
! 	/* Set a flag to allow reliable tracing of leaving the system call. */
! 	caller_ptr->p_misc_flags |= MF_SC_ACTIVE;
!   }
! 
!   if(caller_ptr->p_misc_flags & MF_DELIVERMSG) {
! 	panic("sys_call: MF_DELIVERMSG on for %s / %d\n",
! 		caller_ptr->p_name, caller_ptr->p_endpoint);
!   }
! 
!   /* Now check if the call is known and try to perform the request. The only
!    * system calls that exist in MINIX are sending and receiving messages.
!    *   - SENDREC: combines SEND and RECEIVE in a single system call
!    *   - SEND:    sender blocks until its message has been delivered
!    *   - RECEIVE: receiver blocks until an acceptable message has arrived
!    *   - NOTIFY:  asynchronous call; deliver notification or mark pending
!    *   - SENDA:   list of asynchronous send requests
!    */
!   switch(call_nr) {
!   	case SENDREC:
!   	case SEND:			
!   	case RECEIVE:			
!   	case NOTIFY:
!   	case SENDNB:
!   	{
!   	    /* Process accounting for scheduling */
! 	    caller_ptr->p_accounting.ipc_sync++;
! 
!   	    return do_sync_ipc(caller_ptr, call_nr, (endpoint_t) r2,
! 			    (message *) r3);
!   	}
!   	case SENDA:
!   	{
!  	    /*
!   	     * Get and check the size of the argument in bytes as it is a
!   	     * table
!   	     */
!   	    size_t msg_size = (size_t) r2;
!   
!   	    /* Process accounting for scheduling */
! 	    caller_ptr->p_accounting.ipc_async++;
!  
!   	    /* Limit size to something reasonable. An arbitrary choice is 16
!   	     * times the number of process table entries.
!   	     */
!   	    if (msg_size > 16*(NR_TASKS + NR_PROCS))
! 	        return EDOM;
!   	    return mini_senda(caller_ptr, (asynmsg_t *) r3, msg_size);
!   	}
!   	case MINIX_KERNINFO:
! 	{
! 		/* It might not be initialized yet. */
! 	  	if(!minix_kerninfo_user) {
! 			return EBADCALL;
! 		}
! 
!   		arch_set_secondary_ipc_return(caller_ptr, minix_kerninfo_user);
!   		return OK;
! 	}
!   	default:
! 	return EBADCALL;		/* illegal system call */
!   }
! }
! 
! /*===========================================================================*
!  *				deadlock				     * 
!  *===========================================================================*/
! static int deadlock(function, cp, src_dst_e) 
! int function;					/* trap number */
! register struct proc *cp;			/* pointer to caller */
! endpoint_t src_dst_e;				/* src or dst process */
! {
! /* Check for deadlock. This can happen if 'caller_ptr' and 'src_dst' have
!  * a cyclic dependency of blocking send and receive calls. The only cyclic 
!  * depency that is not fatal is if the caller and target directly SEND(REC)
!  * and RECEIVE to each other. If a deadlock is found, the group size is 
!  * returned. Otherwise zero is returned. 
!  */
!   register struct proc *xp;			/* process pointer */
!   int group_size = 1;				/* start with only caller */
! #if DEBUG_ENABLE_IPC_WARNINGS
!   static struct proc *processes[NR_PROCS + NR_TASKS];
!   processes[0] = cp;
! #endif
! 
!   while (src_dst_e != ANY) { 			/* check while process nr */
!       int src_dst_slot;
!       okendpt(src_dst_e, &src_dst_slot);
!       xp = proc_addr(src_dst_slot);		/* follow chain of processes */
!       assert(proc_ptr_ok(xp));
!       assert(!RTS_ISSET(xp, RTS_SLOT_FREE));
! #if DEBUG_ENABLE_IPC_WARNINGS
!       processes[group_size] = xp;
! #endif
!       group_size ++;				/* extra process in group */
! 
!       /* Check whether the last process in the chain has a dependency. If it 
!        * has not, the cycle cannot be closed and we are done.
!        */
!       if((src_dst_e = P_BLOCKEDON(xp)) == NONE)
! 	return 0;
! 
!       /* Now check if there is a cyclic dependency. For group sizes of two,  
!        * a combination of SEND(REC) and RECEIVE is not fatal. Larger groups
!        * or other combinations indicate a deadlock.  
!        */
!       if (src_dst_e == cp->p_endpoint) {	/* possible deadlock */
! 	  if (group_size == 2) {		/* caller and src_dst */
! 	      /* The function number is magically converted to flags. */
! 	      if ((xp->p_rts_flags ^ (function << 2)) & RTS_SENDING) { 
! 	          return(0);			/* not a deadlock */
! 	      }
! 	  }
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	  {
! 		int i;
! 		printf("deadlock between these processes:\n");
! 		for(i = 0; i < group_size; i++) {
! 			printf(" %10s ", processes[i]->p_name);
! 		}
! 		printf("\n\n");
! 		for(i = 0; i < group_size; i++) {
! 			print_proc(processes[i]);
! 			proc_stacktrace(processes[i]);
! 		}
! 	  }
! #endif
!           return(group_size);			/* deadlock found */
!       }
!   }
!   return(0);					/* not a deadlock */
! }
! 
! /*===========================================================================*
!  *				has_pending				     * 
!  *===========================================================================*/
! static int has_pending(sys_map_t *map, int src_p, int asynm)
! {
! /* Check to see if there is a pending message from the desired source
!  * available.
!  */
! 
!   int src_id;
!   sys_id_t id = NULL_PRIV_ID;
! #ifdef CONFIG_SMP
!   struct proc * p;
! #endif
! 
!   /* Either check a specific bit in the mask map, or find the first bit set in
!    * it (if any), depending on whether the receive was called on a specific
!    * source endpoint.
!    */
!   if (src_p != ANY) {
! 	src_id = nr_to_id(src_p);
! 	if (get_sys_bit(*map, src_id)) {
! #ifdef CONFIG_SMP
! 		p = proc_addr(id_to_nr(src_id));
! 		if (asynm && RTS_ISSET(p, RTS_VMINHIBIT))
! 			p->p_misc_flags |= MF_SENDA_VM_MISS;
! 		else
! #endif
! 			id = src_id;
! 	}
!   } else {
! 	/* Find a source with a pending message */
! 	for (src_id = 0; src_id < NR_SYS_PROCS; src_id += BITCHUNK_BITS) {
! 		if (get_sys_bits(*map, src_id) != 0) {
! #ifdef CONFIG_SMP
! 			while (src_id < NR_SYS_PROCS) {
! 				while (!get_sys_bit(*map, src_id)) {
! 					if (src_id == NR_SYS_PROCS)
! 						goto quit_search;
! 					src_id++;
! 				}
! 				p = proc_addr(id_to_nr(src_id));
! 				/*
! 				 * We must not let kernel fiddle with pages of a
! 				 * process which are currently being changed by
! 				 * VM.  It is dangerous! So do not report such a
! 				 * process as having pending async messages.
! 				 * Skip it.
! 				 */
! 				if (asynm && RTS_ISSET(p, RTS_VMINHIBIT)) {
! 					p->p_misc_flags |= MF_SENDA_VM_MISS;
! 					src_id++;
! 				} else
! 					goto quit_search;
! 			}
! #else
! 			while (!get_sys_bit(*map, src_id)) src_id++;
! 			goto quit_search;
! #endif
! 		}
! 	}
! 
! quit_search:
! 	if (src_id < NR_SYS_PROCS)	/* Found one */
! 		id = src_id;
!   }
! 
!   return(id);
! }
! 
! /*===========================================================================*
!  *				has_pending_notify			     *
!  *===========================================================================*/
! int has_pending_notify(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_notify_pending;
! 	return has_pending(map, src_p, 0);
! }
! 
! /*===========================================================================*
!  *				has_pending_asend			     *
!  *===========================================================================*/
! int has_pending_asend(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_asyn_pending;
! 	return has_pending(map, src_p, 1);
! }
! 
! /*===========================================================================*
!  *				unset_notify_pending			     *
!  *===========================================================================*/
! void unset_notify_pending(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_notify_pending;
! 	unset_sys_bit(*map, src_p);
! }
! 
! /*===========================================================================*
!  *				mini_send				     * 
!  *===========================================================================*/
! int mini_send(
!   register struct proc *caller_ptr,	/* who is trying to send a message? */
!   endpoint_t dst_e,			/* to whom is message being sent? */
!   message *m_ptr,			/* pointer to message buffer */
!   const int flags
! )
! {
! /* Send a message from 'caller_ptr' to 'dst'. If 'dst' is blocked waiting
!  * for this message, copy the message to it and unblock 'dst'. If 'dst' is
!  * not waiting at all, or is waiting for another source, queue 'caller_ptr'.
!  */
!   register struct proc *dst_ptr;
!   register struct proc **xpp;
!   int dst_p;
!   dst_p = _ENDPOINT_P(dst_e);
!   dst_ptr = proc_addr(dst_p);
! 
!   if (RTS_ISSET(dst_ptr, RTS_NO_ENDPOINT))
!   {
! 	return EDEADSRCDST;
!   }
! 
!   /* Check if 'dst' is blocked waiting for this message. The destination's 
!    * RTS_SENDING flag may be set when its SENDREC call blocked while sending.  
!    */
!   if (WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint)) {
! 	int call;
! 	/* Destination is indeed waiting for this message. */
! 	assert(!(dst_ptr->p_misc_flags & MF_DELIVERMSG));	
! 
! 	if (!(flags & FROM_KERNEL)) {
! 		if(copy_msg_from_user(m_ptr, &dst_ptr->p_delivermsg))
! 			return EFAULT;
! 	} else {
! 		dst_ptr->p_delivermsg = *m_ptr;
! 		IPC_STATUS_ADD_FLAGS(dst_ptr, IPC_FLG_MSG_FROM_KERNEL);
! 	}
! 
! 	dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
! 	dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! 	call = (caller_ptr->p_misc_flags & MF_REPLY_PEND ? SENDREC
! 		: (flags & NON_BLOCKING ? SENDNB : SEND));
! 	IPC_STATUS_ADD_CALL(dst_ptr, call);
! 
! 	if (dst_ptr->p_misc_flags & MF_REPLY_PEND)
! 		dst_ptr->p_misc_flags &= ~MF_REPLY_PEND;
! 
! 	RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgsend(&dst_ptr->p_delivermsg, caller_ptr, dst_ptr);
! 	hook_ipc_msgrecv(&dst_ptr->p_delivermsg, caller_ptr, dst_ptr);
! #endif
!   } else {
! 	if(flags & NON_BLOCKING) {
! 		return(ENOTREADY);
! 	}
! 
! 	/* Check for a possible deadlock before actually blocking. */
! 	if (deadlock(SEND, caller_ptr, dst_e)) {
! 		return(ELOCKED);
! 	}
! 
! 	/* Destination is not waiting.  Block and dequeue caller. */
! 	if (!(flags & FROM_KERNEL)) {
! 		if(copy_msg_from_user(m_ptr, &caller_ptr->p_sendmsg))
! 			return EFAULT;
! 	} else {
! 		caller_ptr->p_sendmsg = *m_ptr;
! 		/*
! 		 * we need to remember that this message is from kernel so we
! 		 * can set the delivery status flags when the message is
! 		 * actually delivered
! 		 */
! 		caller_ptr->p_misc_flags |= MF_SENDING_FROM_KERNEL;
! 	}
! 
! 	RTS_SET(caller_ptr, RTS_SENDING);
! 	caller_ptr->p_sendto_e = dst_e;
! 
! 	/* Process is now blocked.  Put in on the destination's queue. */
! 	assert(caller_ptr->p_q_link == NULL);
! 	xpp = &dst_ptr->p_caller_q;		/* find end of list */
! 	while (*xpp) xpp = &(*xpp)->p_q_link;	
! 	*xpp = caller_ptr;			/* add caller to end */
! 
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgsend(&caller_ptr->p_sendmsg, caller_ptr, dst_ptr);
! #endif
!   }
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				mini_receive				     * 
!  *===========================================================================*/
! static int mini_receive(struct proc * caller_ptr,
! 			endpoint_t src_e, /* which message source is wanted */
! 			message * m_buff_usr, /* pointer to message buffer */
! 			const int flags)
! {
! /* A process or task wants to get a message.  If a message is already queued,
!  * acquire it and deblock the sender.  If no message from the desired source
!  * is available block the caller.
!  */
!   register struct proc **xpp;
!   int r, src_id, src_proc_nr, src_p;
! 
!   assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 
!   /* This is where we want our message. */
!   caller_ptr->p_delivermsg_vir = (vir_bytes) m_buff_usr;
! 
!   if(src_e == ANY) src_p = ANY;
!   else
!   {
! 	okendpt(src_e, &src_p);
! 	if (RTS_ISSET(proc_addr(src_p), RTS_NO_ENDPOINT))
! 	{
! 		return EDEADSRCDST;
! 	}
!   }
! 
! 
!   /* Check to see if a message from desired source is already available.  The
!    * caller's RTS_SENDING flag may be set if SENDREC couldn't send. If it is
!    * set, the process should be blocked.
!    */
!   if (!RTS_ISSET(caller_ptr, RTS_SENDING)) {
! 
!     /* Check if there are pending notifications, except for SENDREC. */
!     if (! (caller_ptr->p_misc_flags & MF_REPLY_PEND)) {
! 
! 	/* Check for pending notifications */
!         if ((src_id = has_pending_notify(caller_ptr, src_p)) != NULL_PRIV_ID) {
!             endpoint_t hisep;
! 
!             src_proc_nr = id_to_nr(src_id);		/* get source proc */
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	    if(src_proc_nr == NONE) {
! 		printf("mini_receive: sending notify from NONE\n");
! 	    }
! #endif
! 	    assert(src_proc_nr != NONE);
!             unset_notify_pending(caller_ptr, src_id);	/* no longer pending */
! 
!             /* Found a suitable source, deliver the notification message. */
! 	    hisep = proc_addr(src_proc_nr)->p_endpoint;
! 	    assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));	
! 	    assert(src_e == ANY || hisep == src_e);
! 
! 	    /* assemble message */
! 	    BuildNotifyMessage(&caller_ptr->p_delivermsg, src_proc_nr, caller_ptr);
! 	    caller_ptr->p_delivermsg.m_source = hisep;
! 	    caller_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! 	    IPC_STATUS_ADD_CALL(caller_ptr, NOTIFY);
! 
! 	    goto receive_done;
!         }
!     }
! 
!     /* Check for pending asynchronous messages */
!     if (has_pending_asend(caller_ptr, src_p) != NULL_PRIV_ID) {
!         if (src_p != ANY)
!         	r = try_one(proc_addr(src_p), caller_ptr);
!         else
!         	r = try_async(caller_ptr);
! 
! 	if (r == OK) {
!             IPC_STATUS_ADD_CALL(caller_ptr, SENDA);
!             goto receive_done;
!         }
!     }
! 
!     /* Check caller queue. Use pointer pointers to keep code simple. */
!     xpp = &caller_ptr->p_caller_q;
!     while (*xpp) {
! 	struct proc * sender = *xpp;
! 
!         if (src_e == ANY || src_p == proc_nr(sender)) {
!             int call;
! 	    assert(!RTS_ISSET(sender, RTS_SLOT_FREE));
! 	    assert(!RTS_ISSET(sender, RTS_NO_ENDPOINT));
! 
! 	    /* Found acceptable message. Copy it and update status. */
!   	    assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 	    caller_ptr->p_delivermsg = sender->p_sendmsg;
! 	    caller_ptr->p_delivermsg.m_source = sender->p_endpoint;
! 	    caller_ptr->p_misc_flags |= MF_DELIVERMSG;
! 	    RTS_UNSET(sender, RTS_SENDING);
! 
! 	    call = (sender->p_misc_flags & MF_REPLY_PEND ? SENDREC : SEND);
! 	    IPC_STATUS_ADD_CALL(caller_ptr, call);
! 
! 	    /*
! 	     * if the message is originaly from the kernel on behalf of this
! 	     * process, we must send the status flags accordingly
! 	     */
! 	    if (sender->p_misc_flags & MF_SENDING_FROM_KERNEL) {
! 		IPC_STATUS_ADD_FLAGS(caller_ptr, IPC_FLG_MSG_FROM_KERNEL);
! 		/* we can clean the flag now, not need anymore */
! 		sender->p_misc_flags &= ~MF_SENDING_FROM_KERNEL;
! 	    }
! 	    if (sender->p_misc_flags & MF_SIG_DELAY)
! 		sig_delay_done(sender);
! 
! #if DEBUG_IPC_HOOK
!             hook_ipc_msgrecv(&caller_ptr->p_delivermsg, *xpp, caller_ptr);
! #endif
! 		
!             *xpp = sender->p_q_link;		/* remove from queue */
! 	    sender->p_q_link = NULL;
! 	    goto receive_done;
! 	}
! 	xpp = &sender->p_q_link;		/* proceed to next */
!     }
!   }
! 
!   /* No suitable message is available or the caller couldn't send in SENDREC. 
!    * Block the process trying to receive, unless the flags tell otherwise.
!    */
!   if ( ! (flags & NON_BLOCKING)) {
!       /* Check for a possible deadlock before actually blocking. */
!       if (deadlock(RECEIVE, caller_ptr, src_e)) {
!           return(ELOCKED);
!       }
! 
!       caller_ptr->p_getfrom_e = src_e;		
!       RTS_SET(caller_ptr, RTS_RECEIVING);
!       return(OK);
!   } else {
! 	return(ENOTREADY);
!   }
! 
! receive_done:
!   if (caller_ptr->p_misc_flags & MF_REPLY_PEND)
! 	  caller_ptr->p_misc_flags &= ~MF_REPLY_PEND;
!   return OK;
! }
! 
! /*===========================================================================*
!  *				mini_notify				     * 
!  *===========================================================================*/
! int mini_notify(
!   const struct proc *caller_ptr,	/* sender of the notification */
!   endpoint_t dst_e			/* which process to notify */
! )
! {
!   register struct proc *dst_ptr;
!   int src_id;				/* source id for late delivery */
!   int dst_p;
! 
!   if (!isokendpt(dst_e, &dst_p)) {
! 	util_stacktrace();
! 	printf("mini_notify: bogus endpoint %d\n", dst_e);
! 	return EDEADSRCDST;
!   }
! 
!   dst_ptr = proc_addr(dst_p);
! 
!   /* Check to see if target is blocked waiting for this message. A process 
!    * can be both sending and receiving during a SENDREC system call.
!    */
!     if (WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint) &&
!       ! (dst_ptr->p_misc_flags & MF_REPLY_PEND)) {
!       /* Destination is indeed waiting for a message. Assemble a notification 
!        * message and deliver it. Copy from pseudo-source HARDWARE, since the
!        * message is in the kernel's address space.
!        */ 
!       assert(!(dst_ptr->p_misc_flags & MF_DELIVERMSG));
! 
!       BuildNotifyMessage(&dst_ptr->p_delivermsg, proc_nr(caller_ptr), dst_ptr);
!       dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
!       dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
!       IPC_STATUS_ADD_CALL(dst_ptr, NOTIFY);
!       RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 
!       return(OK);
!   } 
! 
!   /* Destination is not ready to receive the notification. Add it to the 
!    * bit map with pending notifications. Note the indirectness: the privilege id
!    * instead of the process number is used in the pending bit map.
!    */ 
!   src_id = priv(caller_ptr)->s_id;
!   set_sys_bit(priv(dst_ptr)->s_notify_pending, src_id); 
!   return(OK);
! }
! 
! #define ASCOMPLAIN(caller, entry, field)	\
! 	printf("kernel:%s:%d: asyn failed for %s in %s "	\
! 	"(%d/%d, tab 0x%lx)\n",__FILE__,__LINE__,	\
! field, caller->p_name, entry, priv(caller)->s_asynsize, priv(caller)->s_asyntab)
! 
! #define A_RETR_FLD(entry, field)	\
!   if(data_copy(caller_ptr->p_endpoint,	\
! 	 table_v + (entry)*sizeof(asynmsg_t) + offsetof(struct asynmsg,field),\
! 		KERNEL, (vir_bytes) &tabent.field,	\
! 			sizeof(tabent.field)) != OK) {\
! 		ASCOMPLAIN(caller_ptr, entry, #field);	\
! 		r = EFAULT; \
! 	        goto asyn_error; \
! 	}
! 
! #define A_RETR(entry) do {			\
!   if (data_copy(				\
!   		caller_ptr->p_endpoint, table_v + (entry)*sizeof(asynmsg_t),\
!   		KERNEL, (vir_bytes) &tabent,	\
!   		sizeof(tabent)) != OK) {	\
!   			ASCOMPLAIN(caller_ptr, entry, "message entry");	\
!   			r = EFAULT;		\
! 	                goto asyn_error; \
!   }						\
!   			 } while(0)
! 
! #define A_INSRT_FLD(entry, field)	\
!   if(data_copy(KERNEL, (vir_bytes) &tabent.field, \
! 	caller_ptr->p_endpoint,	\
!  	table_v + (entry)*sizeof(asynmsg_t) + offsetof(struct asynmsg,field),\
! 		sizeof(tabent.field)) != OK) {\
! 		ASCOMPLAIN(caller_ptr, entry, #field);	\
! 		r = EFAULT; \
! 	        goto asyn_error; \
! 	}
! 
! #define A_INSRT(entry) do {			\
!   if (data_copy(KERNEL, (vir_bytes) &tabent,	\
!   		caller_ptr->p_endpoint, table_v + (entry)*sizeof(asynmsg_t),\
!   		sizeof(tabent)) != OK) {	\
!   			ASCOMPLAIN(caller_ptr, entry, "message entry");	\
!   			r = EFAULT;		\
! 	                goto asyn_error; \
!   }						\
!   			  } while(0)	
! 
! /*===========================================================================*
!  *				try_deliver_senda			     *
!  *===========================================================================*/
! int try_deliver_senda(struct proc *caller_ptr,
! 				asynmsg_t *table,
! 				size_t size)
! {
!   int r, dst_p, done, do_notify;
!   unsigned int i;
!   unsigned flags;
!   endpoint_t dst;
!   struct proc *dst_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   const vir_bytes table_v = (vir_bytes) table;
! 
!   privp = priv(caller_ptr);
! 
!   /* Clear table */
!   privp->s_asyntab = -1;
!   privp->s_asynsize = 0;
! 
!   if (size == 0) return(OK);  /* Nothing to do, just return */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
!   /* Limit size to something reasonable. An arbitrary choice is 16
!    * times the number of process table entries.
!    *
!    * (this check has been duplicated in sys_call but is left here
!    * as a sanity check)
!    */
!   if (size > 16*(NR_TASKS + NR_PROCS)) {
!     r = EDOM;
!     return r;
!   }
! 
!   for (i = 0; i < size; i++) {
! 	/* Process each entry in the table and store the result in the table.
! 	 * If we're done handling a message, copy the result to the sender. */
! 
! 	dst = NONE;
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue; /* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR)) {
! 		r = EINVAL;
! 		goto asyn_error;
! 	}
! 	if (!(flags & AMF_VALID)) { /* Must contain message */
! 		r = EINVAL;
! 		goto asyn_error;
! 	}
! 	if (flags & AMF_DONE) continue;	/* Already done processing */
! 
! 	r = OK;
! 	if (!isokendpt(tabent.dst, &dst_p)) 
! 		r = EDEADSRCDST; /* Bad destination, report the error */
! 	else if (iskerneln(dst_p)) 
! 		r = ECALLDENIED; /* Asyn sends to the kernel are not allowed */
! 	else if (!may_send_to(caller_ptr, dst_p)) 
! 		r = ECALLDENIED; /* Send denied by IPC mask */
! 	else 	/* r == OK */
! 		dst_ptr = proc_addr(dst_p);
! 
! 	/* XXX: RTS_NO_ENDPOINT should be removed */
! 	if (r == OK && RTS_ISSET(dst_ptr, RTS_NO_ENDPOINT)) {
! 		r = EDEADSRCDST;
! 	}
! 
! 	/* Check if 'dst' is blocked waiting for this message.
! 	 * If AMF_NOREPLY is set, do not satisfy the receiving part of
! 	 * a SENDREC.
! 	 */
! 	if (r == OK && WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint) &&
! 	    (!(flags&AMF_NOREPLY) || !(dst_ptr->p_misc_flags&MF_REPLY_PEND))) {
! 		/* Destination is indeed waiting for this message. */
! 		dst_ptr->p_delivermsg = tabent.msg;
! 		dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
! 		dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 		IPC_STATUS_ADD_CALL(dst_ptr, SENDA);
! 		RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 	} else if (r == OK) {
! 		/* Inform receiver that something is pending */
! 		set_sys_bit(priv(dst_ptr)->s_asyn_pending, 
! 			    priv(caller_ptr)->s_id); 
! 		done = FALSE;
! 		continue;
! 	} 
! 
! 	/* Store results */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY)
! 		do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR))
! 		do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to caller */
! 	continue;
! 
! asyn_error:
! 	if (dst != NONE)
! 		printf("KERNEL senda error %d to %d\n", r, dst);
! 	else
! 		printf("KERNEL senda error %d\n", r);
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), caller_ptr->p_endpoint);
! 
!   if (!done) {
! 	privp->s_asyntab = (vir_bytes) table;
! 	privp->s_asynsize = size;
!   }
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				mini_senda				     *
!  *===========================================================================*/
! static int mini_senda(struct proc *caller_ptr, asynmsg_t *table, size_t size)
! {
!   struct priv *privp;
! 
!   privp = priv(caller_ptr);
!   if (!(privp->s_flags & SYS_PROC)) {
! 	printf( "mini_senda: warning caller has no privilege structure\n");
! 	return(EPERM);
!   }
! 
!   return try_deliver_senda(caller_ptr, table, size);
! }
! 
! 
! /*===========================================================================*
!  *				try_async				     * 
!  *===========================================================================*/
! static int try_async(caller_ptr)
! struct proc *caller_ptr;
! {
!   int r;
!   struct priv *privp;
!   struct proc *src_ptr;
!   sys_map_t *map;
! 
!   map = &priv(caller_ptr)->s_asyn_pending;
! 
!   /* Try all privilege structures */
!   for (privp = BEG_PRIV_ADDR; privp < END_PRIV_ADDR; ++privp)  {
! 	if (privp->s_proc_nr == NONE)
! 		continue;
! 
! 	if (!get_sys_bit(*map, privp->s_id)) 
! 		continue;
! 
! 	src_ptr = proc_addr(privp->s_proc_nr);
! 
! #ifdef CONFIG_SMP
! 	/*
! 	 * Do not copy from a process which does not have a stable address space
! 	 * due to VM fiddling with it
! 	 */
! 	if (RTS_ISSET(src_ptr, RTS_VMINHIBIT)) {
! 		src_ptr->p_misc_flags |= MF_SENDA_VM_MISS;
! 		continue;
! 	}
! #endif
! 
! 	assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 	if ((r = try_one(src_ptr, caller_ptr)) == OK)
! 		return(r);
!   }
! 
!   return(ESRCH);
! }
! 
! 
! /*===========================================================================*
!  *				try_one					     *
!  *===========================================================================*/
! static int try_one(struct proc *src_ptr, struct proc *dst_ptr)
! {
! /* Try to receive an asynchronous message from 'src_ptr' */
!   int r = EAGAIN, done, do_notify;
!   unsigned int flags, i;
!   size_t size;
!   endpoint_t dst;
!   struct proc *caller_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   vir_bytes table_v;
! 
!   privp = priv(src_ptr);
!   if (!(privp->s_flags & SYS_PROC)) return(EPERM);
!   size = privp->s_asynsize;
!   table_v = privp->s_asyntab;
! 
!   /* Clear table pending message flag. We're done unless we're not. */
!   unset_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
! 
!   if (size == 0) return(EAGAIN);
!   if (!may_send_to(src_ptr, proc_nr(dst_ptr))) return(ECALLDENIED);
! 
!   caller_ptr = src_ptr;	/* Needed for A_ macros later on */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
!   for (i = 0; i < size; i++) {
!   	/* Process each entry in the table and store the result in the table.
!   	 * If we're done handling a message, copy the result to the sender.
!   	 * Some checks done in mini_senda are duplicated here, as the sender
!   	 * could've altered the contents of the table in the meantime.
!   	 */
! 
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue;	/* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR))
! 		r = EINVAL;
! 	else if (!(flags & AMF_VALID)) /* Must contain message */
! 		r = EINVAL; 
! 	else if (flags & AMF_DONE) continue; /* Already done processing */
! 
! 	/* Clear done flag. The sender is done sending when all messages in the
! 	 * table are marked done or empty. However, we will know that only
! 	 * the next time we enter this function or when the sender decides to
! 	 * send additional asynchronous messages and manages to deliver them
! 	 * all.
! 	 */
! 	done = FALSE;
! 
! 	if (r == EINVAL)
! 		goto store_result;
! 
! 	/* Message must be directed at receiving end */
! 	if (dst != dst_ptr->p_endpoint) continue;
! 
! 	/* If AMF_NOREPLY is set, then this message is not a reply to a
! 	 * SENDREC and thus should not satisfy the receiving part of the
! 	 * SENDREC. This message is to be delivered later.
! 	 */
! 	if ((flags & AMF_NOREPLY) && (dst_ptr->p_misc_flags & MF_REPLY_PEND)) 
! 		continue;
! 
! 	/* Destination is ready to receive the message; deliver it */
! 	r = OK;
! 	dst_ptr->p_delivermsg = tabent.msg;
! 	dst_ptr->p_delivermsg.m_source = src_ptr->p_endpoint;
! 	dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! store_result:
! 	/* Store results for sender */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY) do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR)) do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to sender */
! 
! 	break;
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), src_ptr->p_endpoint);
! 
!   if (done) {
! 	privp->s_asyntab = -1;
! 	privp->s_asynsize = 0;
!   } else {
! 	set_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
!   }
! 
! asyn_error:
!   return(r);
! }
! 
! /*===========================================================================*
!  *				cancel_async				     *
!  *===========================================================================*/
! int cancel_async(struct proc *src_ptr, struct proc *dst_ptr)
! {
! /* Cancel asynchronous messages from src to dst, because dst is not interested
!  * in them (e.g., dst has been restarted) */
!   int done, do_notify;
!   unsigned int flags, i;
!   size_t size;
!   endpoint_t dst;
!   struct proc *caller_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   vir_bytes table_v;
! 
!   privp = priv(src_ptr);
!   if (!(privp->s_flags & SYS_PROC)) return(EPERM);
!   size = privp->s_asynsize;
!   table_v = privp->s_asyntab;
! 
!   /* Clear table pending message flag. We're done unless we're not. */
!   privp->s_asyntab = -1;
!   privp->s_asynsize = 0;
!   unset_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
! 
!   if (size == 0) return(EAGAIN);
!   if (!may_send_to(src_ptr, proc_nr(dst_ptr))) return(ECALLDENIED);
! 
!   caller_ptr = src_ptr;	/* Needed for A_ macros later on */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
! 
!   for (i = 0; i < size; i++) {
!   	/* Process each entry in the table and store the result in the table.
!   	 * If we're done handling a message, copy the result to the sender.
!   	 * Some checks done in mini_senda are duplicated here, as the sender
!   	 * could've altered the contents of the table in the mean time.
!   	 */
! 
!   	int r = EDEADSRCDST;	/* Cancel delivery due to dead dst */
! 
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue;	/* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR))
! 		r = EINVAL;
! 	else if (!(flags & AMF_VALID)) /* Must contain message */
! 		r = EINVAL; 
! 	else if (flags & AMF_DONE) continue; /* Already done processing */
! 
! 	/* Message must be directed at receiving end */
! 	if (dst != dst_ptr->p_endpoint) {
! 		done = FALSE;
! 		continue;
! 	}
! 
! 	/* Store results for sender */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY) do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR)) do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to sender */
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), src_ptr->p_endpoint);
! 
!   if (!done) {
! 	privp->s_asyntab = table_v;
! 	privp->s_asynsize = size;
!   }
! 
! asyn_error:
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				enqueue					     * 
!  *===========================================================================*/
! void enqueue(
!   register struct proc *rp	/* this process is now runnable */
! )
! {
! /* Add 'rp' to one of the queues of runnable processes.  This function is 
!  * responsible for inserting a process into one of the scheduling queues. 
!  * The mechanism is implemented here.   The actual scheduling policy is
!  * defined in sched() and pick_proc().
!  *
!  * This function can be used x-cpu as it always uses the queues of the cpu the
!  * process is assigned to.
!  */
!   int q = rp->p_priority;	 		/* scheduling queue to use */
!   struct proc **rdy_head, **rdy_tail;
!   
!   assert(proc_is_runnable(rp));
! 
!   assert(q >= 0);
! 
!   rdy_head = get_cpu_var(rp->p_cpu, run_q_head);
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now add the process to the queue. */
!   if (!rdy_head[q]) {		/* add to empty queue */
!       rdy_head[q] = rdy_tail[q] = rp; 		/* create a new queue */
!       rp->p_nextready = NULL;		/* mark new end */
!   } 
!   else {					/* add to tail of queue */
!       rdy_tail[q]->p_nextready = rp;		/* chain tail of queue */	
!       rdy_tail[q] = rp;				/* set new queue tail */
!       rp->p_nextready = NULL;		/* mark new end */
!   }
! 
!   if (cpuid == rp->p_cpu) {
! 	  /*
! 	   * enqueueing a process with a higher priority than the current one,
! 	   * it gets preempted. The current process must be preemptible. Testing
! 	   * the priority also makes sure that a process does not preempt itself
! 	   */
! 	  struct proc * p;
! 	  p = get_cpulocal_var(proc_ptr);
! 	  assert(p);
! 	  if((p->p_priority > rp->p_priority) &&
! 			  (priv(p)->s_flags & PREEMPTIBLE))
! 		  RTS_SET(p, RTS_PREEMPTED); /* calls dequeue() */
!   }
! #ifdef CONFIG_SMP
!   /*
!    * if the process was enqueued on a different cpu and the cpu is idle, i.e.
!    * the time is off, we need to wake up that cpu and let it schedule this new
!    * process
!    */
!   else if (get_cpu_var(rp->p_cpu, cpu_is_idle)) {
! 	  smp_schedule(rp->p_cpu);
!   }
! #endif
! 
!   /* Make note of when this process was added to queue */
!   read_tsc_64(&(get_cpulocal_var(proc_ptr)->p_accounting.enter_queue));
! 
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				enqueue_head				     *
!  *===========================================================================*/
! /*
!  * put a process at the front of its run queue. It comes handy when a process is
!  * preempted and removed from run queue to not to have a currently not-runnable
!  * process on a run queue. We have to put this process back at the fron to be
!  * fair
!  */
! static void enqueue_head(struct proc *rp)
! {
!   const int q = rp->p_priority;	 		/* scheduling queue to use */
! 
!   struct proc **rdy_head, **rdy_tail;
! 
!   assert(proc_ptr_ok(rp));
!   assert(proc_is_runnable(rp));
! 
!   /*
!    * the process was runnable without its quantum expired when dequeued. A
!    * process with no time left should vahe been handled else and differently
!    */
!   assert(!is_zero64(rp->p_cpu_time_left));
! 
!   assert(q >= 0);
! 
! 
!   rdy_head = get_cpu_var(rp->p_cpu, run_q_head);
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now add the process to the queue. */
!   if (!rdy_head[q]) {		/* add to empty queue */
!       rdy_head[q] = rdy_tail[q] = rp; 		/* create a new queue */
!       rp->p_nextready = NULL;		/* mark new end */
!   }
!   else						/* add to head of queue */
!       rp->p_nextready = rdy_head[q];		/* chain head of queue */
!       rdy_head[q] = rp;				/* set new queue head */
! 
!   /* Make note of when this process was added to queue */
!   read_tsc_64(&(get_cpulocal_var(proc_ptr->p_accounting.enter_queue)));
! 
! 
!   /* Process accounting for scheduling */
!   rp->p_accounting.dequeues--;
!   rp->p_accounting.preempted++;
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				dequeue					     * 
!  *===========================================================================*/
! void dequeue(struct proc *rp)
! /* this process is no longer runnable */
! {
! /* A process must be removed from the scheduling queues, for example, because
!  * it has blocked.  If the currently active process is removed, a new process
!  * is picked to run by calling pick_proc().
!  *
!  * This function can operate x-cpu as it always removes the process from the
!  * queue of the cpu the process is currently assigned to.
!  */
!   int q = rp->p_priority;		/* queue to use */
!   struct proc **xpp;			/* iterate over queue */
!   struct proc *prev_xp;
!   u64_t tsc, tsc_delta;
! 
!   struct proc **rdy_tail;
! 
!   assert(proc_ptr_ok(rp));
!   assert(!proc_is_runnable(rp));
! 
!   /* Side-effect for kernel: check if the task's stack still is ok? */
!   assert (!iskernelp(rp) || *priv(rp)->s_stack_guard == STACK_GUARD);
! 
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now make sure that the process is not in its ready queue. Remove the 
!    * process if it is found. A process can be made unready even if it is not 
!    * running by being sent a signal that kills it.
!    */
!   prev_xp = NULL;				
!   for (xpp = get_cpu_var_ptr(rp->p_cpu, run_q_head[q]); *xpp;
! 		  xpp = &(*xpp)->p_nextready) {
!       if (*xpp == rp) {				/* found process to remove */
!           *xpp = (*xpp)->p_nextready;		/* replace with next chain */
!           if (rp == rdy_tail[q]) {		/* queue tail removed */
!               rdy_tail[q] = prev_xp;		/* set new tail */
! 	  }
! 
!           break;
!       }
!       prev_xp = *xpp;				/* save previous in chain */
!   }
! 
! 	
!   /* Process accounting for scheduling */
!   rp->p_accounting.dequeues++;
! 
!   /* this is not all that accurate on virtual machines, especially with
!      IO bound processes that only spend a short amount of time in the queue
!      at a time. */
!   if (!is_zero64(rp->p_accounting.enter_queue)) {
! 	read_tsc_64(&tsc);
! 	tsc_delta = sub64(tsc, rp->p_accounting.enter_queue);
! 	rp->p_accounting.time_in_queue = add64(rp->p_accounting.time_in_queue,
! 		tsc_delta);
! 	make_zero64(rp->p_accounting.enter_queue);
!   }
! 
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				pick_proc				     * 
!  *===========================================================================*/
! static struct proc * pick_proc(void)
! {
! /* Decide who to run now.  A new process is selected an returned.
!  * When a billable process is selected, record it in 'bill_ptr', so that the 
!  * clock task can tell who to bill for system time.
!  *
!  * This function always uses the run queues of the local cpu!
!  */
!   register struct proc *rp;			/* process to run */
!   struct proc **rdy_head;
!   int q;				/* iterate over queues */
! 
!   /* Check each of the scheduling queues for ready processes. The number of
!    * queues is defined in proc.h, and priorities are set in the task table.
!    * If there are no processes ready to run, return NULL.
!    */
!   rdy_head = get_cpulocal_var(run_q_head);
!   for (q=0; q < NR_SCHED_QUEUES; q++) {	
! 	if(!(rp = rdy_head[q])) {
! 		TRACE(VF_PICKPROC, printf("cpu %d queue %d empty\n", cpuid, q););
! 		continue;
! 	}
! 	assert(proc_is_runnable(rp));
! 	if (priv(rp)->s_flags & BILLABLE)	 	
! 		get_cpulocal_var(bill_ptr) = rp; /* bill for system time */
! 	return rp;
!   }
!   return NULL;
! }
! 
! /*===========================================================================*
!  *				endpoint_lookup				     *
!  *===========================================================================*/
! struct proc *endpoint_lookup(endpoint_t e)
! {
! 	int n;
! 
! 	if(!isokendpt(e, &n)) return NULL;
! 
! 	return proc_addr(n);
! }
! 
! /*===========================================================================*
!  *				isokendpt_f				     *
!  *===========================================================================*/
! #if DEBUG_ENABLE_IPC_WARNINGS
! int isokendpt_f(file, line, e, p, fatalflag)
! const char *file;
! int line;
! #else
! int isokendpt_f(e, p, fatalflag)
! #endif
! endpoint_t e;
! int *p;
! const int fatalflag;
! {
! 	int ok = 0;
! 	/* Convert an endpoint number into a process number.
! 	 * Return nonzero if the process is alive with the corresponding
! 	 * generation number, zero otherwise.
! 	 *
! 	 * This function is called with file and line number by the
! 	 * isokendpt_d macro if DEBUG_ENABLE_IPC_WARNINGS is defined,
! 	 * otherwise without. This allows us to print the where the
! 	 * conversion was attempted, making the errors verbose without
! 	 * adding code for that at every call.
! 	 * 
! 	 * If fatalflag is nonzero, we must panic if the conversion doesn't
! 	 * succeed.
! 	 */
! 	*p = _ENDPOINT_P(e);
! 	ok = 0;
! 	if(isokprocn(*p) && !isemptyn(*p) && proc_addr(*p)->p_endpoint == e)
! 		ok = 1;
! 	if(!ok && fatalflag)
! 		panic("invalid endpoint: %d",  e);
! 	return ok;
! }
! 
! static void notify_scheduler(struct proc *p)
! {
! 	message m_no_quantum;
! 	int err;
! 
! 	assert(!proc_kernel_scheduler(p));
! 
! 	/* dequeue the process */
! 	RTS_SET(p, RTS_NO_QUANTUM);
! 	/*
! 	 * Notify the process's scheduler that it has run out of
! 	 * quantum. This is done by sending a message to the scheduler
! 	 * on the process's behalf
! 	 */
! 	m_no_quantum.m_source = p->p_endpoint;
! 	m_no_quantum.m_type   = SCHEDULING_NO_QUANTUM;
! 	m_no_quantum.SCHEDULING_ACNT_QUEUE = cpu_time_2_ms(p->p_accounting.time_in_queue);
! 	m_no_quantum.SCHEDULING_ACNT_DEQS      = p->p_accounting.dequeues;
! 	m_no_quantum.SCHEDULING_ACNT_IPC_SYNC  = p->p_accounting.ipc_sync;
! 	m_no_quantum.SCHEDULING_ACNT_IPC_ASYNC = p->p_accounting.ipc_async;
! 	m_no_quantum.SCHEDULING_ACNT_PREEMPT   = p->p_accounting.preempted;
! 	m_no_quantum.SCHEDULING_ACNT_CPU       = cpuid;
! 	m_no_quantum.SCHEDULING_ACNT_CPU_LOAD  = cpu_load();
! 
! 	/* Reset accounting */
! 	reset_proc_accounting(p);
! 
! 	if ((err = mini_send(p, p->p_scheduler->p_endpoint,
! 					&m_no_quantum, FROM_KERNEL))) {
! 		panic("WARNING: Scheduling: mini_send returned %d\n", err);
! 	}
! }
! 
! void proc_no_time(struct proc * p)
! {
! 	if (!proc_kernel_scheduler(p) && priv(p)->s_flags & PREEMPTIBLE) {
! 		/* this dequeues the process */
! 		notify_scheduler(p);
! 	}
! 	else {
! 		/*
! 		 * non-preemptible processes only need their quantum to
! 		 * be renewed. In fact, they by pass scheduling
! 		 */
! 		p->p_cpu_time_left = ms_2_cpu_time(p->p_quantum_size_ms);
! #if DEBUG_RACE
! 		RTS_SET(p, RTS_PREEMPTED);
! 		RTS_UNSET(p, RTS_PREEMPTED);
! #endif
! 	}
! }
! 
! void reset_proc_accounting(struct proc *p)
! {
!   p->p_accounting.preempted = 0;
!   p->p_accounting.ipc_sync  = 0;
!   p->p_accounting.ipc_async = 0;
!   p->p_accounting.dequeues  = 0;
!   make_zero64(p->p_accounting.time_in_queue);
!   make_zero64(p->p_accounting.enter_queue);
! }
! 	
! void copr_not_available_handler(void)
! {
! 	struct proc * p;
! 	struct proc ** local_fpu_owner;
! 	/*
! 	 * Disable the FPU exception (both for the kernel and for the process
! 	 * once it's scheduled), and initialize or restore the FPU state.
! 	 */
! 
! 	disable_fpu_exception();
! 
! 	p = get_cpulocal_var(proc_ptr);
! 
! 	/* if FPU is not owned by anyone, do not store anything */
! 	local_fpu_owner = get_cpulocal_var_ptr(fpu_owner);
! 	if (*local_fpu_owner != NULL) {
! 		assert(*local_fpu_owner != p);
! 		save_local_fpu(*local_fpu_owner, FALSE /*retain*/);
! 	}
! 
! 	/*
! 	 * restore the current process' state and let it run again, do not
! 	 * schedule!
! 	 */
! 	if (restore_fpu(p) != OK) {
! 		/* Restoring FPU state failed. This is always the process's own
! 		 * fault. Send a signal, and schedule another process instead.
! 		 */
! 		*local_fpu_owner = NULL;		/* release FPU */
! 		cause_sig(proc_nr(p), SIGFPE);
! 		return;
! 	}
! 
! 	*local_fpu_owner = p;
! 	context_stop(proc_addr(KERNEL));
! 	restore_user_context(p);
! 	NOT_REACHABLE;
! }
! 
! void release_fpu(struct proc * p) {
! 	struct proc ** fpu_owner_ptr;
! 
! 	fpu_owner_ptr = get_cpu_var_ptr(p->p_cpu, fpu_owner);
! 
! 	if (*fpu_owner_ptr == p)
! 		*fpu_owner_ptr = NULL;
! }
--- 1,1919 ----
! /* This file contains essentially all of the process and message handling.
!  * Together with "mpx.s" it forms the lowest layer of the MINIX kernel.
!  * There is one entry point from the outside:
!  *
!  *   sys_call: 	      a system call, i.e., the kernel is trapped with an INT
!  *
!  * Changes:
!  *   Aug 19, 2005     rewrote scheduling code  (Jorrit N. Herder)
!  *   Jul 25, 2005     rewrote system call handling  (Jorrit N. Herder)
!  *   May 26, 2005     rewrote message passing functions  (Jorrit N. Herder)
!  *   May 24, 2005     new notification system call  (Jorrit N. Herder)
!  *   Oct 28, 2004     nonblocking send and receive calls  (Jorrit N. Herder)
!  *
!  * The code here is critical to make everything work and is important for the
!  * overall performance of the system. A large fraction of the code deals with
!  * list manipulation. To make this both easy to understand and fast to execute 
!  * pointer pointers are used throughout the code. Pointer pointers prevent
!  * exceptions for the head or tail of a linked list. 
!  *
!  *  node_t *queue, *new_node;	// assume these as global variables
!  *  node_t **xpp = &queue; 	// get pointer pointer to head of queue 
!  *  while (*xpp != NULL) 	// find last pointer of the linked list
!  *      xpp = &(*xpp)->next;	// get pointer to next pointer 
!  *  *xpp = new_node;		// now replace the end (the NULL pointer) 
!  *  new_node->next = NULL;	// and mark the new end of the list
!  * 
!  * For example, when adding a new node to the end of the list, one normally 
!  * makes an exception for an empty list and looks up the end of the list for 
!  * nonempty lists. As shown above, this is not required with pointer pointers.
!  */
! 
! #include <minix/com.h>
! #include <minix/ipcconst.h>
! #include <stddef.h>
! #include <signal.h>
! #include <assert.h>
! 
! #include "kernel/kernel.h"
! #include "vm.h"
! #include "clock.h"
! #include "spinlock.h"
! #include "arch_proto.h"
! #include "proc.h"
! #include "../../include/timers.h"
! 
! #include <minix/syslib.h>
! 
!  #include <stdio.h>
! 
! /* Scheduling and message passing functions */
! static void idle(void);
! /**
!  * Made public for use in clock.c (for user-space scheduling)
! static int mini_send(struct proc *caller_ptr, endpoint_t dst_e, message
! 	*m_ptr, int flags);
! */
! static int mini_receive(struct proc *caller_ptr, endpoint_t src,
! 	message *m_ptr, int flags);
! static int mini_senda(struct proc *caller_ptr, asynmsg_t *table, size_t
! 	size);
! static int deadlock(int function, register struct proc *caller,
! 	endpoint_t src_dst_e);
! static int try_async(struct proc *caller_ptr);
! static int try_one(struct proc *src_ptr, struct proc *dst_ptr);
! static struct proc * pick_proc(void);
! static void enqueue_head(struct proc *rp);
! 
! /* all idles share the same idle_priv structure */
! static struct priv idle_priv;
! 
! static void set_idle_name(char * name, int n)
! {
!         int i, c;
!         int p_z = 0;
! 
!         if (n > 999) 
!                 n = 999; 
! 
!         name[0] = 'i'; 
!         name[1] = 'd'; 
!         name[2] = 'l'; 
!         name[3] = 'e'; 
! 
!         for (i = 4, c = 100; c > 0; c /= 10) {
!                 int digit;
! 
!                 digit = n / c;  
!                 n -= digit * c;  
! 
!                 if (p_z || digit != 0 || c == 1) {
!                         p_z = 1;
!                         name[i++] = '0' + digit;
!                 }   
!         }    
! 
!         name[i] = '\0';
! 
! }
! 
! 
! #define PICK_ANY	1
! #define PICK_HIGHERONLY	2
! 
! #define BuildNotifyMessage(m_ptr, src, dst_ptr) \
! 	(m_ptr)->m_type = NOTIFY_MESSAGE;				\
! 	(m_ptr)->NOTIFY_TIMESTAMP = get_uptime();			\
! 	switch (src) {							\
! 	case HARDWARE:							\
! 		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_int_pending;	\
! 		priv(dst_ptr)->s_int_pending = 0;			\
! 		break;							\
! 	case SYSTEM:							\
! 		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_sig_pending;	\
! 		priv(dst_ptr)->s_sig_pending = 0;			\
! 		break;							\
! 	}
! 
! void proc_init(void)
! {
! 	struct proc * rp;
! 	struct priv *sp;
! 	int i;
! 
! 	/* Clear the process table. Anounce each slot as empty and set up
! 	 * mappings for proc_addr() and proc_nr() macros. Do the same for the
! 	 * table with privilege structures for the system processes. 
! 	 */
! 	for (rp = BEG_PROC_ADDR, i = -NR_TASKS; rp < END_PROC_ADDR; ++rp, ++i) {
! 		rp->p_rts_flags = RTS_SLOT_FREE;/* initialize free slot */
! 		rp->p_magic = PMAGIC;
! 		rp->p_nr = i;			/* proc number from ptr */
! 		rp->p_endpoint = _ENDPOINT(0, rp->p_nr); /* generation no. 0 */
! 		rp->p_scheduler = NULL;		/* no user space scheduler */
! 		rp->p_priority = 0;		/* no priority */
! 		rp->p_quantum_size_ms = 0;	/* no quantum size */
! 		rp->p_deadline.tmr_exp_time = 0; //new added, deadline initialize
! 
! 		/* arch-specific initialization */
! 		arch_proc_reset(rp);
! 	}
! 	for (sp = BEG_PRIV_ADDR, i = 0; sp < END_PRIV_ADDR; ++sp, ++i) {
! 		sp->s_proc_nr = NONE;		/* initialize as free */
! 		sp->s_id = (sys_id_t) i;	/* priv structure index */
! 		ppriv_addr[i] = sp;		/* priv ptr from number */
! 		sp->s_sig_mgr = NONE;		/* clear signal managers */
! 		sp->s_bak_sig_mgr = NONE;
! 	}
! 
! 	idle_priv.s_flags = IDL_F;
! 	/* initialize IDLE structures for every CPU */
! 	for (i = 0; i < CONFIG_MAX_CPUS; i++) {
! 		struct proc * ip = get_cpu_var_ptr(i, idle_proc);
! 		ip->p_endpoint = IDLE;
! 		ip->p_priv = &idle_priv;
! 		/* must not let idle ever get scheduled */
! 		ip->p_rts_flags |= RTS_PROC_STOP;
! 		set_idle_name(ip->p_name, i);
! 	}
! }
! 
! static void switch_address_space_idle(void)
! {
! #ifdef CONFIG_SMP
! 	/*
! 	 * currently we bet that VM is always alive and its pages available so
! 	 * when the CPU wakes up the kernel is mapped and no surprises happen.
! 	 * This is only a problem if more than 1 cpus are available
! 	 */
! 	switch_address_space(proc_addr(VM_PROC_NR));
! #endif
! }
! 
! /*===========================================================================*
!  *				idle					     * 
!  *===========================================================================*/
! static void idle(void)
! {
! 	struct proc * p;
! 
! 	/* This function is called whenever there is no work to do.
! 	 * Halt the CPU, and measure how many timestamp counter ticks are
! 	 * spent not doing anything. This allows test setups to measure
! 	 * the CPU utiliziation of certain workloads with high precision.
! 	 */
! 
! 	p = get_cpulocal_var(proc_ptr) = get_cpulocal_var_ptr(idle_proc);
! 	if (priv(p)->s_flags & BILLABLE)
! 		get_cpulocal_var(bill_ptr) = p;
! 
! 	switch_address_space_idle();
! 
! #ifdef CONFIG_SMP
! 	get_cpulocal_var(cpu_is_idle) = 1;
! 	/* we don't need to keep time on APs as it is handled on the BSP */
! 	if (cpuid != bsp_cpu_id)
! 		stop_local_timer();
! 	else
! #endif
! 	{
! 		/*
! 		 * If the timer has expired while in kernel we must
! 		 * rearm it before we go to sleep
! 		 */
! 		restart_local_timer();
! 	}
! 
! 	/* start accounting for the idle time */
! 	context_stop(proc_addr(KERNEL));
! #if !SPROFILE
! 	halt_cpu();
! #else
! 	if (!sprofiling)
! 		halt_cpu();
! 	else {
! 		volatile int * v;
! 
! 		v = get_cpulocal_var_ptr(idle_interrupted);
! 		interrupts_enable();
! 		while (!*v)
! 			arch_pause();
! 		interrupts_disable();
! 		*v = 0;
! 	}
! #endif
! 	/*
! 	 * end of accounting for the idle task does not happen here, the kernel
! 	 * is handling stuff for quite a while before it gets back here!
! 	 */
! }
! 
! /*===========================================================================*
!  *				switch_to_user				     * 
!  *===========================================================================*/
! void switch_to_user(void)
! {
! 	/* This function is called an instant before proc_ptr is
! 	 * to be scheduled again.
! 	 */
! 	struct proc * p;
! #ifdef CONFIG_SMP
! 	int tlb_must_refresh = 0;
! #endif
! 
! 	p = get_cpulocal_var(proc_ptr);
! 	/*
! 	 * if the current process is still runnable check the misc flags and let
! 	 * it run unless it becomes not runnable in the meantime
! 	 */
! 	if (proc_is_runnable(p))
! 		goto check_misc_flags;
! 	/*
! 	 * if a process becomes not runnable while handling the misc flags, we
! 	 * need to pick a new one here and start from scratch. Also if the
! 	 * current process wasn' runnable, we pick a new one here
! 	 */
! not_runnable_pick_new:
! 	if (proc_is_preempted(p)) {
! 		p->p_rts_flags &= ~RTS_PREEMPTED;
! 		if (proc_is_runnable(p)) {
! 			if (!is_zero64(p->p_cpu_time_left))
! 				enqueue_head(p);
! 			else
! 				enqueue(p);
! 		}
! 	}
! 
! 	/*
! 	 * if we have no process to run, set IDLE as the current process for
! 	 * time accounting and put the cpu in and idle state. After the next
! 	 * timer interrupt the execution resumes here and we can pick another
! 	 * process. If there is still nothing runnable we "schedule" IDLE again
! 	 */
! 	while (!(p = pick_proc())) {
! 		idle();
! 	}
! 
! 	/* update the global variable */
! 	get_cpulocal_var(proc_ptr) = p;
! 
! #ifdef CONFIG_SMP
! 	if (p->p_misc_flags & MF_FLUSH_TLB && get_cpulocal_var(ptproc) == p)
! 		tlb_must_refresh = 1;
! #endif
! 	switch_address_space(p);
! 
! check_misc_flags:
! 
! 	assert(p);
! 	assert(proc_is_runnable(p));
! 	while (p->p_misc_flags &
! 		(MF_KCALL_RESUME | MF_DELIVERMSG |
! 		 MF_SC_DEFER | MF_SC_TRACE | MF_SC_ACTIVE)) {
! 
! 		assert(proc_is_runnable(p));
! 		if (p->p_misc_flags & MF_KCALL_RESUME) {
! 			kernel_call_resume(p);
! 		}
! 		else if (p->p_misc_flags & MF_DELIVERMSG) {
! 			TRACE(VF_SCHEDULING, printf("delivering to %s / %d\n",
! 				p->p_name, p->p_endpoint););
! 			delivermsg(p);
! 		}
! 		else if (p->p_misc_flags & MF_SC_DEFER) {
! 			/* Perform the system call that we deferred earlier. */
! 
! 			assert (!(p->p_misc_flags & MF_SC_ACTIVE));
! 
! 			arch_do_syscall(p);
! 
! 			/* If the process is stopped for signal delivery, and
! 			 * not blocked sending a message after the system call,
! 			 * inform PM.
! 			 */
! 			if ((p->p_misc_flags & MF_SIG_DELAY) &&
! 					!RTS_ISSET(p, RTS_SENDING))
! 				sig_delay_done(p);
! 		}
! 		else if (p->p_misc_flags & MF_SC_TRACE) {
! 			/* Trigger a system call leave event if this was a
! 			 * system call. We must do this after processing the
! 			 * other flags above, both for tracing correctness and
! 			 * to be able to use 'break'.
! 			 */
! 			if (!(p->p_misc_flags & MF_SC_ACTIVE))
! 				break;
! 
! 			p->p_misc_flags &=
! 				~(MF_SC_TRACE | MF_SC_ACTIVE);
! 
! 			/* Signal the "leave system call" event.
! 			 * Block the process.
! 			 */
! 			cause_sig(proc_nr(p), SIGTRAP);
! 		}
! 		else if (p->p_misc_flags & MF_SC_ACTIVE) {
! 			/* If MF_SC_ACTIVE was set, remove it now:
! 			 * we're leaving the system call.
! 			 */
! 			p->p_misc_flags &= ~MF_SC_ACTIVE;
! 
! 			break;
! 		}
! 
! 		/*
! 		 * the selected process might not be runnable anymore. We have
! 		 * to checkit and schedule another one
! 		 */
! 		if (!proc_is_runnable(p))
! 			goto not_runnable_pick_new;
! 	}
! 	/*
! 	 * check the quantum left before it runs again. We must do it only here
! 	 * as we are sure that a possible out-of-quantum message to the
! 	 * scheduler will not collide with the regular ipc
! 	 */
! 	if (is_zero64(p->p_cpu_time_left))
! 		proc_no_time(p);
! 	/*
! 	 * After handling the misc flags the selected process might not be
! 	 * runnable anymore. We have to checkit and schedule another one
! 	 */
! 	if (!proc_is_runnable(p))
! 		goto not_runnable_pick_new;
! 
! 	TRACE(VF_SCHEDULING, printf("cpu %d starting %s / %d "
! 				"pc 0x%08x\n",
! 		cpuid, p->p_name, p->p_endpoint, p->p_reg.pc););
! #if DEBUG_TRACE
! 	p->p_schedules++;
! #endif
! 
! 	p = arch_finish_switch_to_user();
! 	assert(!is_zero64(p->p_cpu_time_left));
! 
! 	context_stop(proc_addr(KERNEL));
! 
! 	/* If the process isn't the owner of FPU, enable the FPU exception */
! 	if(get_cpulocal_var(fpu_owner) != p)
! 		enable_fpu_exception();
! 	else
! 		disable_fpu_exception();
! 
! 	/* If MF_CONTEXT_SET is set, don't clobber process state within
! 	 * the kernel. The next kernel entry is OK again though.
! 	 */
! 	p->p_misc_flags &= ~MF_CONTEXT_SET;
! 
! #if defined(__i386__)
!   	assert(p->p_seg.p_cr3 != 0);
! #elif defined(__arm__)
! 	assert(p->p_seg.p_ttbr != 0);
! #endif
! #ifdef CONFIG_SMP
! 	if (p->p_misc_flags & MF_FLUSH_TLB) {
! 		if (tlb_must_refresh)
! 			refresh_tlb();
! 		p->p_misc_flags &= ~MF_FLUSH_TLB;
! 	}
! #endif
! 	
! 	restart_local_timer();
! 	
! 	/*
! 	 * restore_user_context() carries out the actual mode switch from kernel
! 	 * to userspace. This function does not return
! 	 */
! 	restore_user_context(p);
! 	NOT_REACHABLE;
! }
! 
! /*
!  * handler for all synchronous IPC calls
!  */
! static int do_sync_ipc(struct proc * caller_ptr, /* who made the call */
! 			int call_nr,	/* system call number and flags */
! 			endpoint_t src_dst_e,	/* src or dst of the call */
! 			message *m_ptr)	/* users pointer to a message */
! {
!   int result;					/* the system call's result */
!   int src_dst_p;				/* Process slot number */
!   char *callname;
! 
!   /* Check destination. RECEIVE is the only call that accepts ANY (in addition
!    * to a real endpoint). The other calls (SEND, SENDREC, and NOTIFY) require an
!    * endpoint to corresponds to a process. In addition, it is necessary to check
!    * whether a process is allowed to send to a given destination.
!    */
!   assert(call_nr != SENDA);
! 
!   /* Only allow non-negative call_nr values less than 32 */
!   if (call_nr < 0 || call_nr > IPCNO_HIGHEST || call_nr >= 32
!       || !(callname = ipc_call_names[call_nr])) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: trap %d not allowed, caller %d, src_dst %d\n", 
!           call_nr, proc_nr(caller_ptr), src_dst_e);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   if (src_dst_e == ANY)
!   {
! 	if (call_nr != RECEIVE)
! 	{
! #if 0
! 		printf("sys_call: %s by %d with bad endpoint %d\n", 
! 			callname,
! 			proc_nr(caller_ptr), src_dst_e);
! #endif
! 		return EINVAL;
! 	}
! 	src_dst_p = (int) src_dst_e;
!   }
!   else
!   {
! 	/* Require a valid source and/or destination process. */
! 	if(!isokendpt(src_dst_e, &src_dst_p)) {
! #if 0
! 		printf("sys_call: %s by %d with bad endpoint %d\n", 
! 			callname,
! 			proc_nr(caller_ptr), src_dst_e);
! #endif
! 		return EDEADSRCDST;
! 	}
! 
! 	/* If the call is to send to a process, i.e., for SEND, SENDNB,
! 	 * SENDREC or NOTIFY, verify that the caller is allowed to send to
! 	 * the given destination. 
! 	 */
! 	if (call_nr != RECEIVE)
! 	{
! 		if (!may_send_to(caller_ptr, src_dst_p)) {
! #if DEBUG_ENABLE_IPC_WARNINGS
! 			printf(
! 			"sys_call: ipc mask denied %s from %d to %d\n",
! 				callname,
! 				caller_ptr->p_endpoint, src_dst_e);
! #endif
! 			return(ECALLDENIED);	/* call denied by ipc mask */
! 		}
! 	}
!   }
! 
!   /* Check if the process has privileges for the requested call. Calls to the 
!    * kernel may only be SENDREC, because tasks always reply and may not block 
!    * if the caller doesn't do receive(). 
!    */
!   if (!(priv(caller_ptr)->s_trap_mask & (1 << call_nr))) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: %s not allowed, caller %d, src_dst %d\n", 
!           callname, proc_nr(caller_ptr), src_dst_p);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   if (call_nr != SENDREC && call_nr != RECEIVE && iskerneln(src_dst_p)) {
! #if DEBUG_ENABLE_IPC_WARNINGS
!       printf("sys_call: trap %s not allowed, caller %d, src_dst %d\n",
!            callname, proc_nr(caller_ptr), src_dst_e);
! #endif
! 	return(ETRAPDENIED);		/* trap denied by mask or kernel */
!   }
! 
!   switch(call_nr) {
!   case SENDREC:
! 	/* A flag is set so that notifications cannot interrupt SENDREC. */
! 	caller_ptr->p_misc_flags |= MF_REPLY_PEND;
! 	/* fall through */
!   case SEND:			
! 	result = mini_send(caller_ptr, src_dst_e, m_ptr, 0);
! 	if (call_nr == SEND || result != OK)
! 		break;				/* done, or SEND failed */
! 	/* fall through for SENDREC */
!   case RECEIVE:			
! 	if (call_nr == RECEIVE) {
! 		caller_ptr->p_misc_flags &= ~MF_REPLY_PEND;
! 		IPC_STATUS_CLEAR(caller_ptr);  /* clear IPC status code */
! 	}
! 	result = mini_receive(caller_ptr, src_dst_e, m_ptr, 0);
! 	break;
!   case NOTIFY:
! 	result = mini_notify(caller_ptr, src_dst_e);
! 	break;
!   case SENDNB:
!         result = mini_send(caller_ptr, src_dst_e, m_ptr, NON_BLOCKING);
!         break;
!   default:
! 	result = EBADCALL;			/* illegal system call */
!   }
! 
!   /* Now, return the result of the system call to the caller. */
!   return(result);
! }
! 
! int do_ipc(reg_t r1, reg_t r2, reg_t r3)
! {
!   struct proc *const caller_ptr = get_cpulocal_var(proc_ptr);	/* get pointer to caller */
!   int call_nr = (int) r1;
! 
!   assert(!RTS_ISSET(caller_ptr, RTS_SLOT_FREE));
! 
!   /* bill kernel time to this process. */
!   kbill_ipc = caller_ptr;
! 
!   /* If this process is subject to system call tracing, handle that first. */
!   if (caller_ptr->p_misc_flags & (MF_SC_TRACE | MF_SC_DEFER)) {
! 	/* Are we tracing this process, and is it the first sys_call entry? */
! 	if ((caller_ptr->p_misc_flags & (MF_SC_TRACE | MF_SC_DEFER)) ==
! 							MF_SC_TRACE) {
! 		/* We must notify the tracer before processing the actual
! 		 * system call. If we don't, the tracer could not obtain the
! 		 * input message. Postpone the entire system call.
! 		 */
! 		caller_ptr->p_misc_flags &= ~MF_SC_TRACE;
! 		assert(!(caller_ptr->p_misc_flags & MF_SC_DEFER));
! 		caller_ptr->p_misc_flags |= MF_SC_DEFER;
! 		caller_ptr->p_defer.r1 = r1;
! 		caller_ptr->p_defer.r2 = r2;
! 		caller_ptr->p_defer.r3 = r3;
! 
! 		/* Signal the "enter system call" event. Block the process. */
! 		cause_sig(proc_nr(caller_ptr), SIGTRAP);
! 
! 		/* Preserve the return register's value. */
! 		return caller_ptr->p_reg.retreg;
! 	}
! 
! 	/* If the MF_SC_DEFER flag is set, the syscall is now being resumed. */
! 	caller_ptr->p_misc_flags &= ~MF_SC_DEFER;
! 
! 	assert (!(caller_ptr->p_misc_flags & MF_SC_ACTIVE));
! 
! 	/* Set a flag to allow reliable tracing of leaving the system call. */
! 	caller_ptr->p_misc_flags |= MF_SC_ACTIVE;
!   }
! 
!   if(caller_ptr->p_misc_flags & MF_DELIVERMSG) {
! 	panic("sys_call: MF_DELIVERMSG on for %s / %d\n",
! 		caller_ptr->p_name, caller_ptr->p_endpoint);
!   }
! 
!   /* Now check if the call is known and try to perform the request. The only
!    * system calls that exist in MINIX are sending and receiving messages.
!    *   - SENDREC: combines SEND and RECEIVE in a single system call
!    *   - SEND:    sender blocks until its message has been delivered
!    *   - RECEIVE: receiver blocks until an acceptable message has arrived
!    *   - NOTIFY:  asynchronous call; deliver notification or mark pending
!    *   - SENDA:   list of asynchronous send requests
!    */
!   switch(call_nr) {
!   	case SENDREC:
!   	case SEND:			
!   	case RECEIVE:			
!   	case NOTIFY:
!   	case SENDNB:
!   	{
!   	    /* Process accounting for scheduling */
! 	    caller_ptr->p_accounting.ipc_sync++;
! 
!   	    return do_sync_ipc(caller_ptr, call_nr, (endpoint_t) r2,
! 			    (message *) r3);
!   	}
!   	case SENDA:
!   	{
!  	    /*
!   	     * Get and check the size of the argument in bytes as it is a
!   	     * table
!   	     */
!   	    size_t msg_size = (size_t) r2;
!   
!   	    /* Process accounting for scheduling */
! 	    caller_ptr->p_accounting.ipc_async++;
!  
!   	    /* Limit size to something reasonable. An arbitrary choice is 16
!   	     * times the number of process table entries.
!   	     */
!   	    if (msg_size > 16*(NR_TASKS + NR_PROCS))
! 	        return EDOM;
!   	    return mini_senda(caller_ptr, (asynmsg_t *) r3, msg_size);
!   	}
!   	case MINIX_KERNINFO:
! 	{
! 		/* It might not be initialized yet. */
! 	  	if(!minix_kerninfo_user) {
! 			return EBADCALL;
! 		}
! 
!   		arch_set_secondary_ipc_return(caller_ptr, minix_kerninfo_user);
!   		return OK;
! 	}
!   	default:
! 	return EBADCALL;		/* illegal system call */
!   }
! }
! 
! /*===========================================================================*
!  *				deadlock				     * 
!  *===========================================================================*/
! static int deadlock(function, cp, src_dst_e) 
! int function;					/* trap number */
! register struct proc *cp;			/* pointer to caller */
! endpoint_t src_dst_e;				/* src or dst process */
! {
! /* Check for deadlock. This can happen if 'caller_ptr' and 'src_dst' have
!  * a cyclic dependency of blocking send and receive calls. The only cyclic 
!  * depency that is not fatal is if the caller and target directly SEND(REC)
!  * and RECEIVE to each other. If a deadlock is found, the group size is 
!  * returned. Otherwise zero is returned. 
!  */
!   register struct proc *xp;			/* process pointer */
!   int group_size = 1;				/* start with only caller */
! #if DEBUG_ENABLE_IPC_WARNINGS
!   static struct proc *processes[NR_PROCS + NR_TASKS];
!   processes[0] = cp;
! #endif
! 
!   while (src_dst_e != ANY) { 			/* check while process nr */
!       int src_dst_slot;
!       okendpt(src_dst_e, &src_dst_slot);
!       xp = proc_addr(src_dst_slot);		/* follow chain of processes */
!       assert(proc_ptr_ok(xp));
!       assert(!RTS_ISSET(xp, RTS_SLOT_FREE));
! #if DEBUG_ENABLE_IPC_WARNINGS
!       processes[group_size] = xp;
! #endif
!       group_size ++;				/* extra process in group */
! 
!       /* Check whether the last process in the chain has a dependency. If it 
!        * has not, the cycle cannot be closed and we are done.
!        */
!       if((src_dst_e = P_BLOCKEDON(xp)) == NONE)
! 	return 0;
! 
!       /* Now check if there is a cyclic dependency. For group sizes of two,  
!        * a combination of SEND(REC) and RECEIVE is not fatal. Larger groups
!        * or other combinations indicate a deadlock.  
!        */
!       if (src_dst_e == cp->p_endpoint) {	/* possible deadlock */
! 	  if (group_size == 2) {		/* caller and src_dst */
! 	      /* The function number is magically converted to flags. */
! 	      if ((xp->p_rts_flags ^ (function << 2)) & RTS_SENDING) { 
! 	          return(0);			/* not a deadlock */
! 	      }
! 	  }
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	  {
! 		int i;
! 		printf("deadlock between these processes:\n");
! 		for(i = 0; i < group_size; i++) {
! 			printf(" %10s ", processes[i]->p_name);
! 		}
! 		printf("\n\n");
! 		for(i = 0; i < group_size; i++) {
! 			print_proc(processes[i]);
! 			proc_stacktrace(processes[i]);
! 		}
! 	  }
! #endif
!           return(group_size);			/* deadlock found */
!       }
!   }
!   return(0);					/* not a deadlock */
! }
! 
! /*===========================================================================*
!  *				has_pending				     * 
!  *===========================================================================*/
! static int has_pending(sys_map_t *map, int src_p, int asynm)
! {
! /* Check to see if there is a pending message from the desired source
!  * available.
!  */
! 
!   int src_id;
!   sys_id_t id = NULL_PRIV_ID;
! #ifdef CONFIG_SMP
!   struct proc * p;
! #endif
! 
!   /* Either check a specific bit in the mask map, or find the first bit set in
!    * it (if any), depending on whether the receive was called on a specific
!    * source endpoint.
!    */
!   if (src_p != ANY) {
! 	src_id = nr_to_id(src_p);
! 	if (get_sys_bit(*map, src_id)) {
! #ifdef CONFIG_SMP
! 		p = proc_addr(id_to_nr(src_id));
! 		if (asynm && RTS_ISSET(p, RTS_VMINHIBIT))
! 			p->p_misc_flags |= MF_SENDA_VM_MISS;
! 		else
! #endif
! 			id = src_id;
! 	}
!   } else {
! 	/* Find a source with a pending message */
! 	for (src_id = 0; src_id < NR_SYS_PROCS; src_id += BITCHUNK_BITS) {
! 		if (get_sys_bits(*map, src_id) != 0) {
! #ifdef CONFIG_SMP
! 			while (src_id < NR_SYS_PROCS) {
! 				while (!get_sys_bit(*map, src_id)) {
! 					if (src_id == NR_SYS_PROCS)
! 						goto quit_search;
! 					src_id++;
! 				}
! 				p = proc_addr(id_to_nr(src_id));
! 				/*
! 				 * We must not let kernel fiddle with pages of a
! 				 * process which are currently being changed by
! 				 * VM.  It is dangerous! So do not report such a
! 				 * process as having pending async messages.
! 				 * Skip it.
! 				 */
! 				if (asynm && RTS_ISSET(p, RTS_VMINHIBIT)) {
! 					p->p_misc_flags |= MF_SENDA_VM_MISS;
! 					src_id++;
! 				} else
! 					goto quit_search;
! 			}
! #else
! 			while (!get_sys_bit(*map, src_id)) src_id++;
! 			goto quit_search;
! #endif
! 		}
! 	}
! 
! quit_search:
! 	if (src_id < NR_SYS_PROCS)	/* Found one */
! 		id = src_id;
!   }
! 
!   return(id);
! }
! 
! /*===========================================================================*
!  *				has_pending_notify			     *
!  *===========================================================================*/
! int has_pending_notify(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_notify_pending;
! 	return has_pending(map, src_p, 0);
! }
! 
! /*===========================================================================*
!  *				has_pending_asend			     *
!  *===========================================================================*/
! int has_pending_asend(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_asyn_pending;
! 	return has_pending(map, src_p, 1);
! }
! 
! /*===========================================================================*
!  *				unset_notify_pending			     *
!  *===========================================================================*/
! void unset_notify_pending(struct proc * caller, int src_p)
! {
! 	sys_map_t * map = &priv(caller)->s_notify_pending;
! 	unset_sys_bit(*map, src_p);
! }
! 
! /*===========================================================================*
!  *				mini_send				     * 
!  *===========================================================================*/
! int mini_send(
!   register struct proc *caller_ptr,	/* who is trying to send a message? */
!   endpoint_t dst_e,			/* to whom is message being sent? */
!   message *m_ptr,			/* pointer to message buffer */
!   const int flags
! )
! {
! /* Send a message from 'caller_ptr' to 'dst'. If 'dst' is blocked waiting
!  * for this message, copy the message to it and unblock 'dst'. If 'dst' is
!  * not waiting at all, or is waiting for another source, queue 'caller_ptr'.
!  */
!   register struct proc *dst_ptr;
!   register struct proc **xpp;
!   int dst_p;
!   dst_p = _ENDPOINT_P(dst_e);
!   dst_ptr = proc_addr(dst_p);
! 
!   if (RTS_ISSET(dst_ptr, RTS_NO_ENDPOINT))
!   {
! 	return EDEADSRCDST;
!   }
! 
!   /* Check if 'dst' is blocked waiting for this message. The destination's 
!    * RTS_SENDING flag may be set when its SENDREC call blocked while sending.  
!    */
!   if (WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint)) {
! 	int call;
! 	/* Destination is indeed waiting for this message. */
! 	assert(!(dst_ptr->p_misc_flags & MF_DELIVERMSG));	
! 
! 	if (!(flags & FROM_KERNEL)) {
! 		if(copy_msg_from_user(m_ptr, &dst_ptr->p_delivermsg))
! 			return EFAULT;
! 	} else {
! 		dst_ptr->p_delivermsg = *m_ptr;
! 		IPC_STATUS_ADD_FLAGS(dst_ptr, IPC_FLG_MSG_FROM_KERNEL);
! 	}
! 
! 	dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
! 	dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! 	call = (caller_ptr->p_misc_flags & MF_REPLY_PEND ? SENDREC
! 		: (flags & NON_BLOCKING ? SENDNB : SEND));
! 	IPC_STATUS_ADD_CALL(dst_ptr, call);
! 
! 	if (dst_ptr->p_misc_flags & MF_REPLY_PEND)
! 		dst_ptr->p_misc_flags &= ~MF_REPLY_PEND;
! 
! 	RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgsend(&dst_ptr->p_delivermsg, caller_ptr, dst_ptr);
! 	hook_ipc_msgrecv(&dst_ptr->p_delivermsg, caller_ptr, dst_ptr);
! #endif
!   } else {
! 	if(flags & NON_BLOCKING) {
! 		return(ENOTREADY);
! 	}
! 
! 	/* Check for a possible deadlock before actually blocking. */
! 	if (deadlock(SEND, caller_ptr, dst_e)) {
! 		return(ELOCKED);
! 	}
! 
! 	/* Destination is not waiting.  Block and dequeue caller. */
! 	if (!(flags & FROM_KERNEL)) {
! 		if(copy_msg_from_user(m_ptr, &caller_ptr->p_sendmsg))
! 			return EFAULT;
! 	} else {
! 		caller_ptr->p_sendmsg = *m_ptr;
! 		/*
! 		 * we need to remember that this message is from kernel so we
! 		 * can set the delivery status flags when the message is
! 		 * actually delivered
! 		 */
! 		caller_ptr->p_misc_flags |= MF_SENDING_FROM_KERNEL;
! 	}
! 
! 	RTS_SET(caller_ptr, RTS_SENDING);
! 	caller_ptr->p_sendto_e = dst_e;
! 
! 	/* Process is now blocked.  Put in on the destination's queue. */
! 	assert(caller_ptr->p_q_link == NULL);
! 	xpp = &dst_ptr->p_caller_q;		/* find end of list */
! 	while (*xpp) xpp = &(*xpp)->p_q_link;	
! 	*xpp = caller_ptr;			/* add caller to end */
! 
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgsend(&caller_ptr->p_sendmsg, caller_ptr, dst_ptr);
! #endif
!   }
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				mini_receive				     * 
!  *===========================================================================*/
! static int mini_receive(struct proc * caller_ptr,
! 			endpoint_t src_e, /* which message source is wanted */
! 			message * m_buff_usr, /* pointer to message buffer */
! 			const int flags)
! {
! /* A process or task wants to get a message.  If a message is already queued,
!  * acquire it and deblock the sender.  If no message from the desired source
!  * is available block the caller.
!  */
!   register struct proc **xpp;
!   int r, src_id, src_proc_nr, src_p;
! 
!   assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 
!   /* This is where we want our message. */
!   caller_ptr->p_delivermsg_vir = (vir_bytes) m_buff_usr;
! 
!   if(src_e == ANY) src_p = ANY;
!   else
!   {
! 	okendpt(src_e, &src_p);
! 	if (RTS_ISSET(proc_addr(src_p), RTS_NO_ENDPOINT))
! 	{
! 		return EDEADSRCDST;
! 	}
!   }
! 
! 
!   /* Check to see if a message from desired source is already available.  The
!    * caller's RTS_SENDING flag may be set if SENDREC couldn't send. If it is
!    * set, the process should be blocked.
!    */
!   if (!RTS_ISSET(caller_ptr, RTS_SENDING)) {
! 
!     /* Check if there are pending notifications, except for SENDREC. */
!     if (! (caller_ptr->p_misc_flags & MF_REPLY_PEND)) {
! 
! 	/* Check for pending notifications */
!         if ((src_id = has_pending_notify(caller_ptr, src_p)) != NULL_PRIV_ID) {
!             endpoint_t hisep;
! 
!             src_proc_nr = id_to_nr(src_id);		/* get source proc */
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	    if(src_proc_nr == NONE) {
! 		printf("mini_receive: sending notify from NONE\n");
! 	    }
! #endif
! 	    assert(src_proc_nr != NONE);
!             unset_notify_pending(caller_ptr, src_id);	/* no longer pending */
! 
!             /* Found a suitable source, deliver the notification message. */
! 	    hisep = proc_addr(src_proc_nr)->p_endpoint;
! 	    assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));	
! 	    assert(src_e == ANY || hisep == src_e);
! 
! 	    /* assemble message */
! 	    BuildNotifyMessage(&caller_ptr->p_delivermsg, src_proc_nr, caller_ptr);
! 	    caller_ptr->p_delivermsg.m_source = hisep;
! 	    caller_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! 	    IPC_STATUS_ADD_CALL(caller_ptr, NOTIFY);
! 
! 	    goto receive_done;
!         }
!     }
! 
!     /* Check for pending asynchronous messages */
!     if (has_pending_asend(caller_ptr, src_p) != NULL_PRIV_ID) {
!         if (src_p != ANY)
!         	r = try_one(proc_addr(src_p), caller_ptr);
!         else
!         	r = try_async(caller_ptr);
! 
! 	if (r == OK) {
!             IPC_STATUS_ADD_CALL(caller_ptr, SENDA);
!             goto receive_done;
!         }
!     }
! 
!     /* Check caller queue. Use pointer pointers to keep code simple. */
!     xpp = &caller_ptr->p_caller_q;
!     while (*xpp) {
! 	struct proc * sender = *xpp;
! 
!         if (src_e == ANY || src_p == proc_nr(sender)) {
!             int call;
! 	    assert(!RTS_ISSET(sender, RTS_SLOT_FREE));
! 	    assert(!RTS_ISSET(sender, RTS_NO_ENDPOINT));
! 
! 	    /* Found acceptable message. Copy it and update status. */
!   	    assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 	    caller_ptr->p_delivermsg = sender->p_sendmsg;
! 	    caller_ptr->p_delivermsg.m_source = sender->p_endpoint;
! 	    caller_ptr->p_misc_flags |= MF_DELIVERMSG;
! 	    RTS_UNSET(sender, RTS_SENDING);
! 
! 	    call = (sender->p_misc_flags & MF_REPLY_PEND ? SENDREC : SEND);
! 	    IPC_STATUS_ADD_CALL(caller_ptr, call);
! 
! 	    /*
! 	     * if the message is originaly from the kernel on behalf of this
! 	     * process, we must send the status flags accordingly
! 	     */
! 	    if (sender->p_misc_flags & MF_SENDING_FROM_KERNEL) {
! 		IPC_STATUS_ADD_FLAGS(caller_ptr, IPC_FLG_MSG_FROM_KERNEL);
! 		/* we can clean the flag now, not need anymore */
! 		sender->p_misc_flags &= ~MF_SENDING_FROM_KERNEL;
! 	    }
! 	    if (sender->p_misc_flags & MF_SIG_DELAY)
! 		sig_delay_done(sender);
! 
! #if DEBUG_IPC_HOOK
!             hook_ipc_msgrecv(&caller_ptr->p_delivermsg, *xpp, caller_ptr);
! #endif
! 		
!             *xpp = sender->p_q_link;		/* remove from queue */
! 	    sender->p_q_link = NULL;
! 	    goto receive_done;
! 	}
! 	xpp = &sender->p_q_link;		/* proceed to next */
!     }
!   }
! 
!   /* No suitable message is available or the caller couldn't send in SENDREC. 
!    * Block the process trying to receive, unless the flags tell otherwise.
!    */
!   if ( ! (flags & NON_BLOCKING)) {
!       /* Check for a possible deadlock before actually blocking. */
!       if (deadlock(RECEIVE, caller_ptr, src_e)) {
!           return(ELOCKED);
!       }
! 
!       caller_ptr->p_getfrom_e = src_e;		
!       RTS_SET(caller_ptr, RTS_RECEIVING);
!       return(OK);
!   } else {
! 	return(ENOTREADY);
!   }
! 
! receive_done:
!   if (caller_ptr->p_misc_flags & MF_REPLY_PEND)
! 	  caller_ptr->p_misc_flags &= ~MF_REPLY_PEND;
!   return OK;
! }
! 
! /*===========================================================================*
!  *				mini_notify				     * 
!  *===========================================================================*/
! int mini_notify(
!   const struct proc *caller_ptr,	/* sender of the notification */
!   endpoint_t dst_e			/* which process to notify */
! )
! {
!   register struct proc *dst_ptr;
!   int src_id;				/* source id for late delivery */
!   int dst_p;
! 
!   if (!isokendpt(dst_e, &dst_p)) {
! 	util_stacktrace();
! 	printf("mini_notify: bogus endpoint %d\n", dst_e);
! 	return EDEADSRCDST;
!   }
! 
!   dst_ptr = proc_addr(dst_p);
! 
!   /* Check to see if target is blocked waiting for this message. A process 
!    * can be both sending and receiving during a SENDREC system call.
!    */
!     if (WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint) &&
!       ! (dst_ptr->p_misc_flags & MF_REPLY_PEND)) {
!       /* Destination is indeed waiting for a message. Assemble a notification 
!        * message and deliver it. Copy from pseudo-source HARDWARE, since the
!        * message is in the kernel's address space.
!        */ 
!       assert(!(dst_ptr->p_misc_flags & MF_DELIVERMSG));
! 
!       BuildNotifyMessage(&dst_ptr->p_delivermsg, proc_nr(caller_ptr), dst_ptr);
!       dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
!       dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
!       IPC_STATUS_ADD_CALL(dst_ptr, NOTIFY);
!       RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 
!       return(OK);
!   } 
! 
!   /* Destination is not ready to receive the notification. Add it to the 
!    * bit map with pending notifications. Note the indirectness: the privilege id
!    * instead of the process number is used in the pending bit map.
!    */ 
!   src_id = priv(caller_ptr)->s_id;
!   set_sys_bit(priv(dst_ptr)->s_notify_pending, src_id); 
!   return(OK);
! }
! 
! #define ASCOMPLAIN(caller, entry, field)	\
! 	printf("kernel:%s:%d: asyn failed for %s in %s "	\
! 	"(%d/%d, tab 0x%lx)\n",__FILE__,__LINE__,	\
! field, caller->p_name, entry, priv(caller)->s_asynsize, priv(caller)->s_asyntab)
! 
! #define A_RETR_FLD(entry, field)	\
!   if(data_copy(caller_ptr->p_endpoint,	\
! 	 table_v + (entry)*sizeof(asynmsg_t) + offsetof(struct asynmsg,field),\
! 		KERNEL, (vir_bytes) &tabent.field,	\
! 			sizeof(tabent.field)) != OK) {\
! 		ASCOMPLAIN(caller_ptr, entry, #field);	\
! 		r = EFAULT; \
! 	        goto asyn_error; \
! 	}
! 
! #define A_RETR(entry) do {			\
!   if (data_copy(				\
!   		caller_ptr->p_endpoint, table_v + (entry)*sizeof(asynmsg_t),\
!   		KERNEL, (vir_bytes) &tabent,	\
!   		sizeof(tabent)) != OK) {	\
!   			ASCOMPLAIN(caller_ptr, entry, "message entry");	\
!   			r = EFAULT;		\
! 	                goto asyn_error; \
!   }						\
!   			 } while(0)
! 
! #define A_INSRT_FLD(entry, field)	\
!   if(data_copy(KERNEL, (vir_bytes) &tabent.field, \
! 	caller_ptr->p_endpoint,	\
!  	table_v + (entry)*sizeof(asynmsg_t) + offsetof(struct asynmsg,field),\
! 		sizeof(tabent.field)) != OK) {\
! 		ASCOMPLAIN(caller_ptr, entry, #field);	\
! 		r = EFAULT; \
! 	        goto asyn_error; \
! 	}
! 
! #define A_INSRT(entry) do {			\
!   if (data_copy(KERNEL, (vir_bytes) &tabent,	\
!   		caller_ptr->p_endpoint, table_v + (entry)*sizeof(asynmsg_t),\
!   		sizeof(tabent)) != OK) {	\
!   			ASCOMPLAIN(caller_ptr, entry, "message entry");	\
!   			r = EFAULT;		\
! 	                goto asyn_error; \
!   }						\
!   			  } while(0)	
! 
! /*===========================================================================*
!  *				try_deliver_senda			     *
!  *===========================================================================*/
! int try_deliver_senda(struct proc *caller_ptr,
! 				asynmsg_t *table,
! 				size_t size)
! {
!   int r, dst_p, done, do_notify;
!   unsigned int i;
!   unsigned flags;
!   endpoint_t dst;
!   struct proc *dst_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   const vir_bytes table_v = (vir_bytes) table;
! 
!   privp = priv(caller_ptr);
! 
!   /* Clear table */
!   privp->s_asyntab = -1;
!   privp->s_asynsize = 0;
! 
!   if (size == 0) return(OK);  /* Nothing to do, just return */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
!   /* Limit size to something reasonable. An arbitrary choice is 16
!    * times the number of process table entries.
!    *
!    * (this check has been duplicated in sys_call but is left here
!    * as a sanity check)
!    */
!   if (size > 16*(NR_TASKS + NR_PROCS)) {
!     r = EDOM;
!     return r;
!   }
! 
!   for (i = 0; i < size; i++) {
! 	/* Process each entry in the table and store the result in the table.
! 	 * If we're done handling a message, copy the result to the sender. */
! 
! 	dst = NONE;
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue; /* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR)) {
! 		r = EINVAL;
! 		goto asyn_error;
! 	}
! 	if (!(flags & AMF_VALID)) { /* Must contain message */
! 		r = EINVAL;
! 		goto asyn_error;
! 	}
! 	if (flags & AMF_DONE) continue;	/* Already done processing */
! 
! 	r = OK;
! 	if (!isokendpt(tabent.dst, &dst_p)) 
! 		r = EDEADSRCDST; /* Bad destination, report the error */
! 	else if (iskerneln(dst_p)) 
! 		r = ECALLDENIED; /* Asyn sends to the kernel are not allowed */
! 	else if (!may_send_to(caller_ptr, dst_p)) 
! 		r = ECALLDENIED; /* Send denied by IPC mask */
! 	else 	/* r == OK */
! 		dst_ptr = proc_addr(dst_p);
! 
! 	/* XXX: RTS_NO_ENDPOINT should be removed */
! 	if (r == OK && RTS_ISSET(dst_ptr, RTS_NO_ENDPOINT)) {
! 		r = EDEADSRCDST;
! 	}
! 
! 	/* Check if 'dst' is blocked waiting for this message.
! 	 * If AMF_NOREPLY is set, do not satisfy the receiving part of
! 	 * a SENDREC.
! 	 */
! 	if (r == OK && WILLRECEIVE(dst_ptr, caller_ptr->p_endpoint) &&
! 	    (!(flags&AMF_NOREPLY) || !(dst_ptr->p_misc_flags&MF_REPLY_PEND))) {
! 		/* Destination is indeed waiting for this message. */
! 		dst_ptr->p_delivermsg = tabent.msg;
! 		dst_ptr->p_delivermsg.m_source = caller_ptr->p_endpoint;
! 		dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 		IPC_STATUS_ADD_CALL(dst_ptr, SENDA);
! 		RTS_UNSET(dst_ptr, RTS_RECEIVING);
! 	} else if (r == OK) {
! 		/* Inform receiver that something is pending */
! 		set_sys_bit(priv(dst_ptr)->s_asyn_pending, 
! 			    priv(caller_ptr)->s_id); 
! 		done = FALSE;
! 		continue;
! 	} 
! 
! 	/* Store results */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY)
! 		do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR))
! 		do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to caller */
! 	continue;
! 
! asyn_error:
! 	if (dst != NONE)
! 		printf("KERNEL senda error %d to %d\n", r, dst);
! 	else
! 		printf("KERNEL senda error %d\n", r);
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), caller_ptr->p_endpoint);
! 
!   if (!done) {
! 	privp->s_asyntab = (vir_bytes) table;
! 	privp->s_asynsize = size;
!   }
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				mini_senda				     *
!  *===========================================================================*/
! static int mini_senda(struct proc *caller_ptr, asynmsg_t *table, size_t size)
! {
!   struct priv *privp;
! 
!   privp = priv(caller_ptr);
!   if (!(privp->s_flags & SYS_PROC)) {
! 	printf( "mini_senda: warning caller has no privilege structure\n");
! 	return(EPERM);
!   }
! 
!   return try_deliver_senda(caller_ptr, table, size);
! }
! 
! 
! /*===========================================================================*
!  *				try_async				     * 
!  *===========================================================================*/
! static int try_async(caller_ptr)
! struct proc *caller_ptr;
! {
!   int r;
!   struct priv *privp;
!   struct proc *src_ptr;
!   sys_map_t *map;
! 
!   map = &priv(caller_ptr)->s_asyn_pending;
! 
!   /* Try all privilege structures */
!   for (privp = BEG_PRIV_ADDR; privp < END_PRIV_ADDR; ++privp)  {
! 	if (privp->s_proc_nr == NONE)
! 		continue;
! 
! 	if (!get_sys_bit(*map, privp->s_id)) 
! 		continue;
! 
! 	src_ptr = proc_addr(privp->s_proc_nr);
! 
! #ifdef CONFIG_SMP
! 	/*
! 	 * Do not copy from a process which does not have a stable address space
! 	 * due to VM fiddling with it
! 	 */
! 	if (RTS_ISSET(src_ptr, RTS_VMINHIBIT)) {
! 		src_ptr->p_misc_flags |= MF_SENDA_VM_MISS;
! 		continue;
! 	}
! #endif
! 
! 	assert(!(caller_ptr->p_misc_flags & MF_DELIVERMSG));
! 	if ((r = try_one(src_ptr, caller_ptr)) == OK)
! 		return(r);
!   }
! 
!   return(ESRCH);
! }
! 
! 
! /*===========================================================================*
!  *				try_one					     *
!  *===========================================================================*/
! static int try_one(struct proc *src_ptr, struct proc *dst_ptr)
! {
! /* Try to receive an asynchronous message from 'src_ptr' */
!   int r = EAGAIN, done, do_notify;
!   unsigned int flags, i;
!   size_t size;
!   endpoint_t dst;
!   struct proc *caller_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   vir_bytes table_v;
! 
!   privp = priv(src_ptr);
!   if (!(privp->s_flags & SYS_PROC)) return(EPERM);
!   size = privp->s_asynsize;
!   table_v = privp->s_asyntab;
! 
!   /* Clear table pending message flag. We're done unless we're not. */
!   unset_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
! 
!   if (size == 0) return(EAGAIN);
!   if (!may_send_to(src_ptr, proc_nr(dst_ptr))) return(ECALLDENIED);
! 
!   caller_ptr = src_ptr;	/* Needed for A_ macros later on */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
!   for (i = 0; i < size; i++) {
!   	/* Process each entry in the table and store the result in the table.
!   	 * If we're done handling a message, copy the result to the sender.
!   	 * Some checks done in mini_senda are duplicated here, as the sender
!   	 * could've altered the contents of the table in the meantime.
!   	 */
! 
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue;	/* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR))
! 		r = EINVAL;
! 	else if (!(flags & AMF_VALID)) /* Must contain message */
! 		r = EINVAL; 
! 	else if (flags & AMF_DONE) continue; /* Already done processing */
! 
! 	/* Clear done flag. The sender is done sending when all messages in the
! 	 * table are marked done or empty. However, we will know that only
! 	 * the next time we enter this function or when the sender decides to
! 	 * send additional asynchronous messages and manages to deliver them
! 	 * all.
! 	 */
! 	done = FALSE;
! 
! 	if (r == EINVAL)
! 		goto store_result;
! 
! 	/* Message must be directed at receiving end */
! 	if (dst != dst_ptr->p_endpoint) continue;
! 
! 	/* If AMF_NOREPLY is set, then this message is not a reply to a
! 	 * SENDREC and thus should not satisfy the receiving part of the
! 	 * SENDREC. This message is to be delivered later.
! 	 */
! 	if ((flags & AMF_NOREPLY) && (dst_ptr->p_misc_flags & MF_REPLY_PEND)) 
! 		continue;
! 
! 	/* Destination is ready to receive the message; deliver it */
! 	r = OK;
! 	dst_ptr->p_delivermsg = tabent.msg;
! 	dst_ptr->p_delivermsg.m_source = src_ptr->p_endpoint;
! 	dst_ptr->p_misc_flags |= MF_DELIVERMSG;
! 
! store_result:
! 	/* Store results for sender */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY) do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR)) do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to sender */
! 
! 	break;
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), src_ptr->p_endpoint);
! 
!   if (done) {
! 	privp->s_asyntab = -1;
! 	privp->s_asynsize = 0;
!   } else {
! 	set_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
!   }
! 
! asyn_error:
!   return(r);
! }
! 
! /*===========================================================================*
!  *				cancel_async				     *
!  *===========================================================================*/
! int cancel_async(struct proc *src_ptr, struct proc *dst_ptr)
! {
! /* Cancel asynchronous messages from src to dst, because dst is not interested
!  * in them (e.g., dst has been restarted) */
!   int done, do_notify;
!   unsigned int flags, i;
!   size_t size;
!   endpoint_t dst;
!   struct proc *caller_ptr;
!   struct priv *privp;
!   asynmsg_t tabent;
!   vir_bytes table_v;
! 
!   privp = priv(src_ptr);
!   if (!(privp->s_flags & SYS_PROC)) return(EPERM);
!   size = privp->s_asynsize;
!   table_v = privp->s_asyntab;
! 
!   /* Clear table pending message flag. We're done unless we're not. */
!   privp->s_asyntab = -1;
!   privp->s_asynsize = 0;
!   unset_sys_bit(priv(dst_ptr)->s_asyn_pending, privp->s_id);
! 
!   if (size == 0) return(EAGAIN);
!   if (!may_send_to(src_ptr, proc_nr(dst_ptr))) return(ECALLDENIED);
! 
!   caller_ptr = src_ptr;	/* Needed for A_ macros later on */
! 
!   /* Scan the table */
!   do_notify = FALSE;
!   done = TRUE;
! 
! 
!   for (i = 0; i < size; i++) {
!   	/* Process each entry in the table and store the result in the table.
!   	 * If we're done handling a message, copy the result to the sender.
!   	 * Some checks done in mini_senda are duplicated here, as the sender
!   	 * could've altered the contents of the table in the mean time.
!   	 */
! 
!   	int r = EDEADSRCDST;	/* Cancel delivery due to dead dst */
! 
! 	/* Copy message to kernel */
! 	A_RETR(i);
! 	flags = tabent.flags;
! 	dst = tabent.dst;
! 
! 	if (flags == 0) continue;	/* Skip empty entries */
! 
! 	/* 'flags' field must contain only valid bits */
! 	if(flags & ~(AMF_VALID|AMF_DONE|AMF_NOTIFY|AMF_NOREPLY|AMF_NOTIFY_ERR))
! 		r = EINVAL;
! 	else if (!(flags & AMF_VALID)) /* Must contain message */
! 		r = EINVAL; 
! 	else if (flags & AMF_DONE) continue; /* Already done processing */
! 
! 	/* Message must be directed at receiving end */
! 	if (dst != dst_ptr->p_endpoint) {
! 		done = FALSE;
! 		continue;
! 	}
! 
! 	/* Store results for sender */
! 	tabent.result = r;
! 	tabent.flags = flags | AMF_DONE;
! 	if (flags & AMF_NOTIFY) do_notify = TRUE;
! 	else if (r != OK && (flags & AMF_NOTIFY_ERR)) do_notify = TRUE;
! 	A_INSRT(i);	/* Copy results to sender */
!   }
! 
!   if (do_notify) 
! 	mini_notify(proc_addr(ASYNCM), src_ptr->p_endpoint);
! 
!   if (!done) {
! 	privp->s_asyntab = table_v;
! 	privp->s_asynsize = size;
!   }
! 
! asyn_error:
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				enqueue					     * 
!  *===========================================================================*/
! void enqueue(
!   register struct proc *rp	/* this process is now runnable */
! )
! {
! /* Add 'rp' to one of the queues of runnable processes.  This function is 
!  * responsible for inserting a process into one of the scheduling queues. 
!  * The mechanism is implemented here.   The actual scheduling policy is
!  * defined in sched() and pick_proc().
!  *
!  * This function can be used x-cpu as it always uses the queues of the cpu the
!  * process is assigned to.
!  */
!   int q = rp->p_priority;	 		/* scheduling queue to use */
!   struct proc **rdy_head, **rdy_tail;
!   
!   assert(proc_is_runnable(rp));
! 
!   assert(q >= 0);
! 
!   rdy_head = get_cpu_var(rp->p_cpu, run_q_head);
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now add the process to the queue. */
!   if (!rdy_head[q]) {		/* add to empty queue */
!       rdy_head[q] = rdy_tail[q] = rp; 		/* create a new queue */
!       rp->p_nextready = NULL;		/* mark new end */
!   } 
!   else {					/* add to tail of queue */
!       rdy_tail[q]->p_nextready = rp;		/* chain tail of queue */	
!       rdy_tail[q] = rp;				/* set new queue tail */
!       rp->p_nextready = NULL;		/* mark new end */
!   }
! 
!   if (cpuid == rp->p_cpu) {
! 	  /*
! 	   * enqueueing a process with a higher priority than the current one,
! 	   * it gets preempted. The current process must be preemptible. Testing
! 	   * the priority also makes sure that a process does not preempt itself
! 	   */
! 	  struct proc * p;
! 	  p = get_cpulocal_var(proc_ptr);
! 	  assert(p);
! 	  if((p->p_priority > rp->p_priority) &&
! 			  (priv(p)->s_flags & PREEMPTIBLE))
! 		  RTS_SET(p, RTS_PREEMPTED); /* calls dequeue() */
!   }
! #ifdef CONFIG_SMP
!   /*
!    * if the process was enqueued on a different cpu and the cpu is idle, i.e.
!    * the time is off, we need to wake up that cpu and let it schedule this new
!    * process
!    */
!   else if (get_cpu_var(rp->p_cpu, cpu_is_idle)) {
! 	  smp_schedule(rp->p_cpu);
!   }
! #endif
! 
!   /* Make note of when this process was added to queue */
!   read_tsc_64(&(get_cpulocal_var(proc_ptr)->p_accounting.enter_queue));
! 
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				enqueue_head				     *
!  *===========================================================================*/
! /*
!  * put a process at the front of its run queue. It comes handy when a process is
!  * preempted and removed from run queue to not to have a currently not-runnable
!  * process on a run queue. We have to put this process back at the fron to be
!  * fair
!  */
! static void enqueue_head(struct proc *rp)
! {
!   const int q = rp->p_priority;	 		/* scheduling queue to use */
! 
!   struct proc **rdy_head, **rdy_tail;
! 
!   assert(proc_ptr_ok(rp));
!   assert(proc_is_runnable(rp));
! 
!   /*
!    * the process was runnable without its quantum expired when dequeued. A
!    * process with no time left should vahe been handled else and differently
!    */
!   assert(!is_zero64(rp->p_cpu_time_left));
! 
!   assert(q >= 0);
! 
! 
!   rdy_head = get_cpu_var(rp->p_cpu, run_q_head);
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now add the process to the queue. */
!   if (!rdy_head[q]) {		/* add to empty queue */
!       rdy_head[q] = rdy_tail[q] = rp; 		/* create a new queue */
!       rp->p_nextready = NULL;		/* mark new end */
!   }
!   else						/* add to head of queue */
!       rp->p_nextready = rdy_head[q];		/* chain head of queue */
!       rdy_head[q] = rp;				/* set new queue head */
! 
!   /* Make note of when this process was added to queue */
!   read_tsc_64(&(get_cpulocal_var(proc_ptr->p_accounting.enter_queue)));
! 
! 
!   /* Process accounting for scheduling */
!   rp->p_accounting.dequeues--;
!   rp->p_accounting.preempted++;
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				dequeue					     * 
!  *===========================================================================*/
! void dequeue(struct proc *rp)
! /* this process is no longer runnable */
! {
! /* A process must be removed from the scheduling queues, for example, because
!  * it has blocked.  If the currently active process is removed, a new process
!  * is picked to run by calling pick_proc().
!  *
!  * This function can operate x-cpu as it always removes the process from the
!  * queue of the cpu the process is currently assigned to.
!  */
!   int q = rp->p_priority;		/* queue to use */
!   struct proc **xpp;			/* iterate over queue */
!   struct proc *prev_xp;
!   u64_t tsc, tsc_delta;
! 
!   struct proc **rdy_tail;
! 
!   assert(proc_ptr_ok(rp));
!   assert(!proc_is_runnable(rp));
! 
!   /* Side-effect for kernel: check if the task's stack still is ok? */
!   assert (!iskernelp(rp) || *priv(rp)->s_stack_guard == STACK_GUARD);
! 
!   rdy_tail = get_cpu_var(rp->p_cpu, run_q_tail);
! 
!   /* Now make sure that the process is not in its ready queue. Remove the 
!    * process if it is found. A process can be made unready even if it is not 
!    * running by being sent a signal that kills it.
!    */
!   prev_xp = NULL;				
!   for (xpp = get_cpu_var_ptr(rp->p_cpu, run_q_head[q]); *xpp;
! 		  xpp = &(*xpp)->p_nextready) {
!       if (*xpp == rp) {				/* found process to remove */
!           *xpp = (*xpp)->p_nextready;		/* replace with next chain */
!           if (rp == rdy_tail[q]) {		/* queue tail removed */
!               rdy_tail[q] = prev_xp;		/* set new tail */
! 	  }
! 
!           break;
!       }
!       prev_xp = *xpp;				/* save previous in chain */
!   }
! 
! 	
!   /* Process accounting for scheduling */
!   rp->p_accounting.dequeues++;
! 
!   /* this is not all that accurate on virtual machines, especially with
!      IO bound processes that only spend a short amount of time in the queue
!      at a time. */
!   if (!is_zero64(rp->p_accounting.enter_queue)) {
! 	read_tsc_64(&tsc);
! 	tsc_delta = sub64(tsc, rp->p_accounting.enter_queue);
! 	rp->p_accounting.time_in_queue = add64(rp->p_accounting.time_in_queue,
! 		tsc_delta);
! 	make_zero64(rp->p_accounting.enter_queue);
!   }
! 
! 
! #if DEBUG_SANITYCHECKS
!   assert(runqueues_ok_local());
! #endif
! }
! 
! /*===========================================================================*
!  *				pick_proc				     * 
!  *===========================================================================*/
! static struct proc * pick_proc(void)
! {
!     /* Decide who to run now.  A new process is selected an returned.
!     * When a billable process is selected, record it in 'bill_ptr', so that the
!     * clock task can tell who to bill for system time.
!     *
!     * This function always uses the run queues of the local cpu!
!     */
!     register struct proc *rp;			/* process to run */
!     struct proc **rdy_head;
!     int q;				/* iterate over queues */
!     struct proc *tmp;//new added tmp pointer for struct proc.
!     /* Check each of the scheduling queues for ready processes. The number of
!     * queues is defined in proc.h, and priorities are set in the task table.
!     * If there are no processes ready to run, return NULL.
!     */
!     rdy_head = get_cpulocal_var(run_q_head);
!     for (q=0; q < NR_SCHED_QUEUES; q++) {
!     //check if current queue is empty or not, 2016.12.3
!     if(!(rp = rdy_head[q])) {
!         TRACE(VF_PICKPROC, printf("cpu %d queue %d empty\n", cpuid, q););
!         continue;
!     }
!     //if current queue is 7, there might be real time proc. find it and execute small deadline proc first, new added 2016.12.3
!     
!     if (q == 7)
!     {
!     	//printf("pick proc in queue 7\n");
!       rp =rdy_head[q];
!       if ( !rp )
!           {
!           	tmp = NULL;
!           	continue;
!           }
!       else
!           tmp = rp->p_nextready;
!       while (tmp!=NULL)
!       {
!           //if next has deadline and ( current has no deadline or current deadline is larger than next)
!           if (tmp->p_deadline.tmr_exp_time>0 && (rp->p_deadline.tmr_exp_time ==0 || rp->p_deadline.tmr_exp_time>0 && rp->p_deadline.tmr_exp_time > tmp->p_deadline.tmr_exp_time ) && proc_is_runnable(tmp))
!               rp=tmp;
!           tmp=tmp->p_nextready;
!       }
!     }
!     
!     assert(proc_is_runnable(rp));
!     if (priv(rp)->s_flags & BILLABLE)
!         get_cpulocal_var(bill_ptr) = rp; /* bill for system time */
!     return rp;
!   }
! 
!     return NULL;
! }
! 
! /*===========================================================================*
!  *				endpoint_lookup				     *
!  *===========================================================================*/
! struct proc *endpoint_lookup(endpoint_t e)
! {
! 	int n;
! 
! 	if(!isokendpt(e, &n)) return NULL;
! 
! 	return proc_addr(n);
! }
! 
! /*===========================================================================*
!  *				isokendpt_f				     *
!  *===========================================================================*/
! #if DEBUG_ENABLE_IPC_WARNINGS
! int isokendpt_f(file, line, e, p, fatalflag)
! const char *file;
! int line;
! #else
! int isokendpt_f(e, p, fatalflag)
! #endif
! endpoint_t e;
! int *p;
! const int fatalflag;
! {
! 	int ok = 0;
! 	/* Convert an endpoint number into a process number.
! 	 * Return nonzero if the process is alive with the corresponding
! 	 * generation number, zero otherwise.
! 	 *
! 	 * This function is called with file and line number by the
! 	 * isokendpt_d macro if DEBUG_ENABLE_IPC_WARNINGS is defined,
! 	 * otherwise without. This allows us to print the where the
! 	 * conversion was attempted, making the errors verbose without
! 	 * adding code for that at every call.
! 	 * 
! 	 * If fatalflag is nonzero, we must panic if the conversion doesn't
! 	 * succeed.
! 	 */
! 	*p = _ENDPOINT_P(e);
! 	ok = 0;
! 	if(isokprocn(*p) && !isemptyn(*p) && proc_addr(*p)->p_endpoint == e)
! 		ok = 1;
! 	if(!ok && fatalflag)
! 		panic("invalid endpoint: %d",  e);
! 	return ok;
! }
! 
! static void notify_scheduler(struct proc *p)
! {
! 	message m_no_quantum;
! 	int err;
! 
! 	assert(!proc_kernel_scheduler(p));
! 
! 	/* dequeue the process */
! 	RTS_SET(p, RTS_NO_QUANTUM);
! 	/*
! 	 * Notify the process's scheduler that it has run out of
! 	 * quantum. This is done by sending a message to the scheduler
! 	 * on the process's behalf
! 	 */
! 	m_no_quantum.m_source = p->p_endpoint;
! 	m_no_quantum.m_type   = SCHEDULING_NO_QUANTUM;
! 	m_no_quantum.SCHEDULING_ACNT_QUEUE = cpu_time_2_ms(p->p_accounting.time_in_queue);
! 	m_no_quantum.SCHEDULING_ACNT_DEQS      = p->p_accounting.dequeues;
! 	m_no_quantum.SCHEDULING_ACNT_IPC_SYNC  = p->p_accounting.ipc_sync;
! 	m_no_quantum.SCHEDULING_ACNT_IPC_ASYNC = p->p_accounting.ipc_async;
! 	m_no_quantum.SCHEDULING_ACNT_PREEMPT   = p->p_accounting.preempted;
! 	m_no_quantum.SCHEDULING_ACNT_CPU       = cpuid;
! 	m_no_quantum.SCHEDULING_ACNT_CPU_LOAD  = cpu_load();
! 
! 	/* Reset accounting */
! 	reset_proc_accounting(p);
! 
! 	if ((err = mini_send(p, p->p_scheduler->p_endpoint,
! 					&m_no_quantum, FROM_KERNEL))) {
! 		panic("WARNING: Scheduling: mini_send returned %d\n", err);
! 	}
! }
! 
! void proc_no_time(struct proc * p)
! {
! 	if (!proc_kernel_scheduler(p) && priv(p)->s_flags & PREEMPTIBLE) {
! 		/* this dequeues the process */
! 		notify_scheduler(p);
! 	}
! 	else {
! 		/*
! 		 * non-preemptible processes only need their quantum to
! 		 * be renewed. In fact, they by pass scheduling
! 		 */
! 		p->p_cpu_time_left = ms_2_cpu_time(p->p_quantum_size_ms);
! #if DEBUG_RACE
! 		RTS_SET(p, RTS_PREEMPTED);
! 		RTS_UNSET(p, RTS_PREEMPTED);
! #endif
! 	}
! }
! 
! void reset_proc_accounting(struct proc *p)
! {
!   p->p_accounting.preempted = 0;
!   p->p_accounting.ipc_sync  = 0;
!   p->p_accounting.ipc_async = 0;
!   p->p_accounting.dequeues  = 0;
!   make_zero64(p->p_accounting.time_in_queue);
!   make_zero64(p->p_accounting.enter_queue);
! }
! 	
! void copr_not_available_handler(void)
! {
! 	struct proc * p;
! 	struct proc ** local_fpu_owner;
! 	/*
! 	 * Disable the FPU exception (both for the kernel and for the process
! 	 * once it's scheduled), and initialize or restore the FPU state.
! 	 */
! 
! 	disable_fpu_exception();
! 
! 	p = get_cpulocal_var(proc_ptr);
! 
! 	/* if FPU is not owned by anyone, do not store anything */
! 	local_fpu_owner = get_cpulocal_var_ptr(fpu_owner);
! 	if (*local_fpu_owner != NULL) {
! 		assert(*local_fpu_owner != p);
! 		save_local_fpu(*local_fpu_owner, FALSE /*retain*/);
! 	}
! 
! 	/*
! 	 * restore the current process' state and let it run again, do not
! 	 * schedule!
! 	 */
! 	if (restore_fpu(p) != OK) {
! 		/* Restoring FPU state failed. This is always the process's own
! 		 * fault. Send a signal, and schedule another process instead.
! 		 */
! 		*local_fpu_owner = NULL;		/* release FPU */
! 		cause_sig(proc_nr(p), SIGFPE);
! 		return;
! 	}
! 
! 	*local_fpu_owner = p;
! 	context_stop(proc_addr(KERNEL));
! 	restore_user_context(p);
! 	NOT_REACHABLE;
! }
! 
! void release_fpu(struct proc * p) {
! 	struct proc ** fpu_owner_ptr;
! 
! 	fpu_owner_ptr = get_cpu_var_ptr(p->p_cpu, fpu_owner);
! 
! 	if (*fpu_owner_ptr == p)
! 		*fpu_owner_ptr = NULL;
! }
diff -crN usr_orig/src/kernel/proc.h EDF/src/kernel/proc.h
*** usr_orig/src/kernel/proc.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/proc.h	2016-12-08 00:17:19.599910743 +0800
***************
*** 1,283 ****
! #ifndef PROC_H
! #define PROC_H
! 
! #include <minix/const.h>
! #include <sys/cdefs.h>
! 
! #ifndef __ASSEMBLY__
! 
! /* Here is the declaration of the process table.  It contains all process
!  * data, including registers, flags, scheduling priority, memory map, 
!  * accounting, message passing (IPC) information, and so on. 
!  *
!  * Many assembly code routines reference fields in it.  The offsets to these
!  * fields are defined in the assembler include file sconst.h.  When changing
!  * struct proc, be sure to change sconst.h to match.
!  */
! #include <minix/com.h>
! #include <minix/portio.h>
! #include "const.h"
! #include "priv.h"
! 
! struct proc {
!   struct stackframe_s p_reg;	/* process' registers saved in stack frame */
!   struct segframe p_seg;	/* segment descriptors */
!   proc_nr_t p_nr;		/* number of this process (for fast access) */
!   struct priv *p_priv;		/* system privileges structure */
!   volatile u32_t p_rts_flags;	/* process is runnable only if zero */
!   volatile u32_t p_misc_flags;	/* flags that do not suspend the process */
! 
!   char p_priority;		/* current process priority */
!   u64_t p_cpu_time_left;	/* time left to use the cpu */
!   unsigned p_quantum_size_ms;	/* assigned time quantum in ms
! 				   FIXME remove this */
!   struct proc *p_scheduler;	/* who should get out of quantum msg */
!   unsigned p_cpu;		/* what CPU is the process running on */
! #ifdef CONFIG_SMP
!   bitchunk_t p_cpu_mask[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* what CPUs is hte
! 							    process allowed to
! 							    run on */
!   bitchunk_t p_stale_tlb[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* On which cpu are
! 				possibly stale entries from this process and has
! 				to be fresed the next kernel touches this
! 				processes memory
! 				 */
! #endif
! 
!   /* Accounting statistics that get passed to the process' scheduler */
!   struct {
! 	u64_t enter_queue;	/* time when enqueued (cycles) */
! 	u64_t time_in_queue;	/* time spent in queue */
! 	unsigned long dequeues;
! 	unsigned long ipc_sync;
! 	unsigned long ipc_async;
! 	unsigned long preempted;
!   } p_accounting;
! 
!   clock_t p_user_time;		/* user time in ticks */
!   clock_t p_sys_time;		/* sys time in ticks */
! 
!   clock_t p_virt_left;		/* number of ticks left on virtual timer */
!   clock_t p_prof_left;		/* number of ticks left on profile timer */
! 
!   u64_t p_cycles;		/* how many cycles did the process use */
!   u64_t p_kcall_cycles;		/* kernel cycles caused by this proc (kcall) */
!   u64_t p_kipc_cycles;		/* cycles caused by this proc (ipc) */
! 
!   struct proc *p_nextready;	/* pointer to next ready process */
!   struct proc *p_caller_q;	/* head of list of procs wishing to send */
!   struct proc *p_q_link;	/* link to next proc wishing to send */
!   endpoint_t p_getfrom_e;	/* from whom does process want to receive? */
!   endpoint_t p_sendto_e;	/* to whom does process want to send? */
! 
!   sigset_t p_pending;		/* bit map for pending kernel signals */
! 
!   char p_name[PROC_NAME_LEN];	/* name of the process, including \0 */
! 
!   endpoint_t p_endpoint;	/* endpoint number, generation-aware */
! 
!   message p_sendmsg;		/* Message from this process if SENDING */
!   message p_delivermsg;		/* Message for this process if MF_DELIVERMSG */
!   vir_bytes p_delivermsg_vir;	/* Virtual addr this proc wants message at */
! 
!   /* If handler functions detect a process wants to do something with
!    * memory that isn't present, VM has to fix it. Until it has asked
!    * what needs to be done and fixed it, save necessary state here.
!    *
!    * The requestor gets a copy of its request message in reqmsg and gets
!    * VMREQUEST set.
!    */
!   struct {
! 	struct proc	*nextrestart;	/* next in vmrestart chain */
! 	struct proc	*nextrequestor;	/* next in vmrequest chain */
! #define VMSTYPE_SYS_NONE	0
! #define VMSTYPE_KERNELCALL	1
! #define VMSTYPE_DELIVERMSG	2
! #define VMSTYPE_MAP		3
! 
! 	int		type;		/* suspended operation */
! 	union {
! 		/* VMSTYPE_SYS_MESSAGE */
! 		message		reqmsg;	/* suspended request message */
! 	} saved;
! 
! 	/* Parameters of request to VM */
! 	int		req_type;
! 	endpoint_t	target;
! 	union {
! 		struct {
! 			vir_bytes 	start, length;	/* memory range */
! 			u8_t		writeflag;	/* nonzero for write access */
! 		} check;
! 	} params;
! 	/* VM result when available */
! 	int		vmresult;
! 
! 	/* If the suspended operation is a sys_call, its details are
! 	 * stored here.
! 	 */
!   } p_vmrequest;
! 
!   int p_found;	/* consistency checking variables */
!   int p_magic;		/* check validity of proc pointers */
! 
!   /* if MF_SC_DEFER is set, this struct is valid and contains the
!    * do_ipc() arguments that are still to be executed
!    */
!   struct { reg_t r1, r2, r3; } p_defer;
! 
! #if DEBUG_TRACE
!   int p_schedules;
! #endif
! };
! 
! #endif /* __ASSEMBLY__ */
! 
! /* Bits for the runtime flags. A process is runnable iff p_rts_flags == 0. */
! #define RTS_SLOT_FREE	0x01	/* process slot is free */
! #define RTS_PROC_STOP	0x02	/* process has been stopped */
! #define RTS_SENDING	0x04	/* process blocked trying to send */
! #define RTS_RECEIVING	0x08	/* process blocked trying to receive */
! #define RTS_SIGNALED	0x10	/* set when new kernel signal arrives */
! #define RTS_SIG_PENDING	0x20	/* unready while signal being processed */
! #define RTS_P_STOP	0x40	/* set when process is being traced */
! #define RTS_NO_PRIV	0x80	/* keep forked system process from running */
! #define RTS_NO_ENDPOINT	0x100	/* process cannot send or receive messages */
! #define RTS_VMINHIBIT	0x200	/* not scheduled until pagetable set by VM */
! #define RTS_PAGEFAULT	0x400	/* process has unhandled pagefault */
! #define RTS_VMREQUEST	0x800	/* originator of vm memory request */
! #define RTS_VMREQTARGET	0x1000	/* target of vm memory request */
! #define RTS_PREEMPTED	0x4000	/* this process was preempted by a higher
! 				   priority process and we should pick a new one
! 				   to run. Processes with this flag should be
! 				   returned to the front of their current
! 				   priority queue if they are still runnable
! 				   before we pick a new one
! 				 */
! #define RTS_NO_QUANTUM	0x8000	/* process ran out of its quantum and we should
! 				   pick a new one. Process was dequeued and
! 				   should be enqueued at the end of some run
! 				   queue again */
! #define RTS_BOOTINHIBIT	0x10000	/* not ready until VM has made it */
! 
! /* A process is runnable iff p_rts_flags == 0. */
! #define rts_f_is_runnable(flg)	((flg) == 0)
! #define proc_is_runnable(p)	(rts_f_is_runnable((p)->p_rts_flags))
! 
! #define proc_is_preempted(p)	((p)->p_rts_flags & RTS_PREEMPTED)
! #define proc_no_quantum(p)	((p)->p_rts_flags & RTS_NO_QUANTUM)
! #define proc_ptr_ok(p)		((p)->p_magic == PMAGIC)
! #define proc_used_fpu(p)	((p)->p_misc_flags & (MF_FPU_INITIALIZED))
! 
! /* test whether the process is scheduled by the kernel's default policy  */
! #define proc_kernel_scheduler(p)	((p)->p_scheduler == NULL || \
! 					(p)->p_scheduler == (p))
! 
! /* Macro to return: on which process is a certain process blocked?
!  * return endpoint number (can be ANY) or NONE. It's important to
!  * check RTS_SENDING first, and then RTS_RECEIVING, as they could
!  * both be on (if a sendrec() blocks on sending), and p_getfrom_e
!  * could be nonsense even though RTS_RECEIVING is on.
!  */
! #define P_BLOCKEDON(p)							\
! 	(								\
! 		((p)->p_rts_flags & RTS_SENDING) ? 			\
! 		(p)->p_sendto_e : 					\
! 		(							\
! 			(						\
! 				((p)->p_rts_flags & RTS_RECEIVING) ?	\
! 				(p)->p_getfrom_e : 			\
! 				NONE					\
! 			) 						\
! 		)							\
! 	)
! 
! /* These runtime flags can be tested and manipulated by these macros. */
! 
! #define RTS_ISSET(rp, f) (((rp)->p_rts_flags & (f)) == (f))
! 
! 
! /* Set flag and dequeue if the process was runnable. */
! #define RTS_SET(rp, f)							\
! 	do {								\
! 		const int rts = (rp)->p_rts_flags;			\
! 		(rp)->p_rts_flags |= (f);				\
! 		if(rts_f_is_runnable(rts) && !proc_is_runnable(rp)) {	\
! 			dequeue(rp);					\
! 		}							\
! 	} while(0)
! 
! /* Clear flag and enqueue if the process was not runnable but is now. */
! #define RTS_UNSET(rp, f) 						\
! 	do {								\
! 		int rts;						\
! 		rts = (rp)->p_rts_flags;				\
! 		(rp)->p_rts_flags &= ~(f);				\
! 		if(!rts_f_is_runnable(rts) && proc_is_runnable(rp)) {	\
! 			enqueue(rp);					\
! 		}							\
! 	} while(0)
! 
! /* Set flags to this value. */
! #define RTS_SETFLAGS(rp, f)					\
! 	do {								\
! 		if(proc_is_runnable(rp) && (f)) { dequeue(rp); }		\
! 		(rp)->p_rts_flags = (f);				\
! 	} while(0)
! 
! /* Misc flags */
! #define MF_REPLY_PEND	0x001	/* reply to IPC_REQUEST is pending */
! #define MF_VIRT_TIMER	0x002	/* process-virtual timer is running */
! #define MF_PROF_TIMER	0x004	/* process-virtual profile timer is running */
! #define MF_KCALL_RESUME 0x008	/* processing a kernel call was interrupted,
! 				   most likely because we need VM to resolve a
! 				   problem or a long running copy was preempted.
! 				   We need to resume the kernel call execution
! 				   now
! 				 */
! #define MF_DELIVERMSG	0x040	/* Copy message for him before running */
! #define MF_SIG_DELAY	0x080	/* Send signal when no longer sending */
! #define MF_SC_ACTIVE	0x100	/* Syscall tracing: in a system call now */
! #define MF_SC_DEFER	0x200	/* Syscall tracing: deferred system call */
! #define MF_SC_TRACE	0x400	/* Syscall tracing: trigger syscall events */
! #define MF_FPU_INITIALIZED	0x1000  /* process already used math, so fpu
! 					 * regs are significant (initialized)*/
! #define MF_SENDING_FROM_KERNEL	0x2000 /* message of this process is from kernel */
! #define MF_CONTEXT_SET	0x4000 /* don't touch context */
! #define MF_SPROF_SEEN	0x8000 /* profiling has seen this process */
! #define MF_FLUSH_TLB	0x10000	/* if set, TLB must be flushed before letting
! 				   this process run again. Currently it only
! 				   applies to SMP */
! #define MF_SENDA_VM_MISS 0x20000 /* set if a processes wanted to receive an asyn
! 				    message from this sender but could not
! 				    because of VM modifying the sender's address
! 				    space*/
! #define MF_STEP		 0x40000 /* Single-step process */
! 
! /* Magic process table addresses. */
! #define BEG_PROC_ADDR (&proc[0])
! #define BEG_USER_ADDR (&proc[NR_TASKS])
! #define END_PROC_ADDR (&proc[NR_TASKS + NR_PROCS])
! 
! #define proc_addr(n)      (&(proc[NR_TASKS + (n)]))
! #define proc_nr(p) 	  ((p)->p_nr)
! 
! #define isokprocn(n)      ((unsigned) ((n) + NR_TASKS) < NR_PROCS + NR_TASKS)
! #define isemptyn(n)       isemptyp(proc_addr(n)) 
! #define isemptyp(p)       ((p)->p_rts_flags == RTS_SLOT_FREE)
! #define iskernelp(p)	  ((p) < BEG_USER_ADDR)
! #define iskerneln(n)	  ((n) < 0)
! #define isuserp(p)        isusern((p) >= BEG_USER_ADDR)
! #define isusern(n)        ((n) >= 0)
! #define isrootsysn(n)	  ((n) == ROOT_SYS_PROC_NR)
! 
! #ifndef __ASSEMBLY__
! 
! EXTERN struct proc proc[NR_TASKS + NR_PROCS];	/* process table */
! 
! int mini_send(struct proc *caller_ptr, endpoint_t dst_e, message *m_ptr,
! 	int flags);
! 
! #endif /* __ASSEMBLY__ */
! 
! #endif /* PROC_H */
--- 1,285 ----
! #ifndef PROC_H
! #define PROC_H
! 
! #include <minix/const.h>
! #include <sys/cdefs.h>
! 
! #ifndef __ASSEMBLY__
! 
! /* Here is the declaration of the process table.  It contains all process
!  * data, including registers, flags, scheduling priority, memory map, 
!  * accounting, message passing (IPC) information, and so on. 
!  *
!  * Many assembly code routines reference fields in it.  The offsets to these
!  * fields are defined in the assembler include file sconst.h.  When changing
!  * struct proc, be sure to change sconst.h to match.
!  */
! #include <minix/com.h>
! #include <minix/portio.h>
! #include "const.h"
! #include "priv.h"
! 
! struct proc {
!   struct stackframe_s p_reg;	/* process' registers saved in stack frame */
!   struct segframe p_seg;	/* segment descriptors */
!   proc_nr_t p_nr;		/* number of this process (for fast access) */
!   struct priv *p_priv;		/* system privileges structure */
!   volatile u32_t p_rts_flags;	/* process is runnable only if zero */
!   volatile u32_t p_misc_flags;	/* flags that do not suspend the process */
! 
!   char p_priority;		/* current process priority */
!   u64_t p_cpu_time_left;	/* time left to use the cpu */
!   unsigned p_quantum_size_ms;	/* assigned time quantum in ms
! 				   FIXME remove this */
!   struct proc *p_scheduler;	/* who should get out of quantum msg */
!   unsigned p_cpu;		/* what CPU is the process running on */
!   struct timer p_deadline;//2016.12.3 new added, a timer for deadline
! #ifdef CONFIG_SMP
!   bitchunk_t p_cpu_mask[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* what CPUs is hte
! 							    process allowed to
! 							    run on */
!   bitchunk_t p_stale_tlb[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* On which cpu are
! 				possibly stale entries from this process and has
! 				to be fresed the next kernel touches this
! 				processes memory
! 				 */
! #endif
! 
!   /* Accounting statistics that get passed to the process' scheduler */
!   struct {
! 	u64_t enter_queue;	/* time when enqueued (cycles) */
! 	u64_t time_in_queue;	/* time spent in queue */
! 	unsigned long dequeues;
! 	unsigned long ipc_sync;
! 	unsigned long ipc_async;
! 	unsigned long preempted;
!   } p_accounting;
! 
!   clock_t p_user_time;		/* user time in ticks */
!   clock_t p_sys_time;		/* sys time in ticks */
! 
!   clock_t p_virt_left;		/* number of ticks left on virtual timer */
!   clock_t p_prof_left;		/* number of ticks left on profile timer */
! 
!   u64_t p_cycles;		/* how many cycles did the process use */
!   u64_t p_kcall_cycles;		/* kernel cycles caused by this proc (kcall) */
!   u64_t p_kipc_cycles;		/* cycles caused by this proc (ipc) */
! 
!   struct proc *p_nextready;	/* pointer to next ready process */
!   struct proc *p_caller_q;	/* head of list of procs wishing to send */
!   struct proc *p_q_link;	/* link to next proc wishing to send */
!   endpoint_t p_getfrom_e;	/* from whom does process want to receive? */
!   endpoint_t p_sendto_e;	/* to whom does process want to send? */
! 
!   sigset_t p_pending;		/* bit map for pending kernel signals */
! 
!   char p_name[PROC_NAME_LEN];	/* name of the process, including \0 */
! 
!   endpoint_t p_endpoint;	/* endpoint number, generation-aware */
! 
!   message p_sendmsg;		/* Message from this process if SENDING */
!   message p_delivermsg;		/* Message for this process if MF_DELIVERMSG */
!   vir_bytes p_delivermsg_vir;	/* Virtual addr this proc wants message at */
! 
!   /* If handler functions detect a process wants to do something with
!    * memory that isn't present, VM has to fix it. Until it has asked
!    * what needs to be done and fixed it, save necessary state here.
!    *
!    * The requestor gets a copy of its request message in reqmsg and gets
!    * VMREQUEST set.
!    */
!   struct {
! 	struct proc	*nextrestart;	/* next in vmrestart chain */
! 	struct proc	*nextrequestor;	/* next in vmrequest chain */
! #define VMSTYPE_SYS_NONE	0
! #define VMSTYPE_KERNELCALL	1
! #define VMSTYPE_DELIVERMSG	2
! #define VMSTYPE_MAP		3
! 
! 	int		type;		/* suspended operation */
! 	union {
! 		/* VMSTYPE_SYS_MESSAGE */
! 		message		reqmsg;	/* suspended request message */
! 	} saved;
! 
! 	/* Parameters of request to VM */
! 	int		req_type;
! 	endpoint_t	target;
! 	union {
! 		struct {
! 			vir_bytes 	start, length;	/* memory range */
! 			u8_t		writeflag;	/* nonzero for write access */
! 		} check;
! 	} params;
! 	/* VM result when available */
! 	int		vmresult;
! 
! 	/* If the suspended operation is a sys_call, its details are
! 	 * stored here.
! 	 */
!   } p_vmrequest;
! 
!   int p_found;	/* consistency checking variables */
!   int p_magic;		/* check validity of proc pointers */
! 
!   /* if MF_SC_DEFER is set, this struct is valid and contains the
!    * do_ipc() arguments that are still to be executed
!    */
!   struct { reg_t r1, r2, r3; } p_defer;
! 
! #if DEBUG_TRACE
!   int p_schedules;
! #endif
! };
! 
! #endif /* __ASSEMBLY__ */
! 
! /* Bits for the runtime flags. A process is runnable iff p_rts_flags == 0. */
! #define RTS_SLOT_FREE	0x01	/* process slot is free */
! #define RTS_PROC_STOP	0x02	/* process has been stopped */
! #define RTS_SENDING	0x04	/* process blocked trying to send */
! #define RTS_RECEIVING	0x08	/* process blocked trying to receive */
! #define RTS_SIGNALED	0x10	/* set when new kernel signal arrives */
! #define RTS_SIG_PENDING	0x20	/* unready while signal being processed */
! #define RTS_P_STOP	0x40	/* set when process is being traced */
! #define RTS_NO_PRIV	0x80	/* keep forked system process from running */
! #define RTS_NO_ENDPOINT	0x100	/* process cannot send or receive messages */
! #define RTS_VMINHIBIT	0x200	/* not scheduled until pagetable set by VM */
! #define RTS_PAGEFAULT	0x400	/* process has unhandled pagefault */
! #define RTS_VMREQUEST	0x800	/* originator of vm memory request */
! #define RTS_VMREQTARGET	0x1000	/* target of vm memory request */
! #define RTS_SYS_LOCK	0x2000	// temporary process lock flag for systask //new added back, 2016.12.4
! #define RTS_PREEMPTED	0x4000	/* this process was preempted by a higher
! 				   priority process and we should pick a new one
! 				   to run. Processes with this flag should be
! 				   returned to the front of their current
! 				   priority queue if they are still runnable
! 				   before we pick a new one
! 				 */
! #define RTS_NO_QUANTUM	0x8000	/* process ran out of its quantum and we should
! 				   pick a new one. Process was dequeued and
! 				   should be enqueued at the end of some run
! 				   queue again */
! #define RTS_BOOTINHIBIT	0x10000	/* not ready until VM has made it */
! 
! /* A process is runnable iff p_rts_flags == 0. */
! #define rts_f_is_runnable(flg)	((flg) == 0)
! #define proc_is_runnable(p)	(rts_f_is_runnable((p)->p_rts_flags))
! 
! #define proc_is_preempted(p)	((p)->p_rts_flags & RTS_PREEMPTED)
! #define proc_no_quantum(p)	((p)->p_rts_flags & RTS_NO_QUANTUM)
! #define proc_ptr_ok(p)		((p)->p_magic == PMAGIC)
! #define proc_used_fpu(p)	((p)->p_misc_flags & (MF_FPU_INITIALIZED))
! 
! /* test whether the process is scheduled by the kernel's default policy  */
! #define proc_kernel_scheduler(p)	((p)->p_scheduler == NULL || \
! 					(p)->p_scheduler == (p))
! 
! /* Macro to return: on which process is a certain process blocked?
!  * return endpoint number (can be ANY) or NONE. It's important to
!  * check RTS_SENDING first, and then RTS_RECEIVING, as they could
!  * both be on (if a sendrec() blocks on sending), and p_getfrom_e
!  * could be nonsense even though RTS_RECEIVING is on.
!  */
! #define P_BLOCKEDON(p)							\
! 	(								\
! 		((p)->p_rts_flags & RTS_SENDING) ? 			\
! 		(p)->p_sendto_e : 					\
! 		(							\
! 			(						\
! 				((p)->p_rts_flags & RTS_RECEIVING) ?	\
! 				(p)->p_getfrom_e : 			\
! 				NONE					\
! 			) 						\
! 		)							\
! 	)
! 
! /* These runtime flags can be tested and manipulated by these macros. */
! 
! #define RTS_ISSET(rp, f) (((rp)->p_rts_flags & (f)) == (f))
! 
! 
! /* Set flag and dequeue if the process was runnable. */
! #define RTS_SET(rp, f)							\
! 	do {								\
! 		const int rts = (rp)->p_rts_flags;			\
! 		(rp)->p_rts_flags |= (f);				\
! 		if(rts_f_is_runnable(rts) && !proc_is_runnable(rp)) {	\
! 			dequeue(rp);					\
! 		}							\
! 	} while(0)
! 
! /* Clear flag and enqueue if the process was not runnable but is now. */
! #define RTS_UNSET(rp, f) 						\
! 	do {								\
! 		int rts;						\
! 		rts = (rp)->p_rts_flags;				\
! 		(rp)->p_rts_flags &= ~(f);				\
! 		if(!rts_f_is_runnable(rts) && proc_is_runnable(rp)) {	\
! 			enqueue(rp);					\
! 		}							\
! 	} while(0)
! 
! /* Set flags to this value. */
! #define RTS_SETFLAGS(rp, f)					\
! 	do {								\
! 		if(proc_is_runnable(rp) && (f)) { dequeue(rp); }		\
! 		(rp)->p_rts_flags = (f);				\
! 	} while(0)
! 
! /* Misc flags */
! #define MF_REPLY_PEND	0x001	/* reply to IPC_REQUEST is pending */
! #define MF_VIRT_TIMER	0x002	/* process-virtual timer is running */
! #define MF_PROF_TIMER	0x004	/* process-virtual profile timer is running */
! #define MF_KCALL_RESUME 0x008	/* processing a kernel call was interrupted,
! 				   most likely because we need VM to resolve a
! 				   problem or a long running copy was preempted.
! 				   We need to resume the kernel call execution
! 				   now
! 				 */
! #define MF_DELIVERMSG	0x040	/* Copy message for him before running */
! #define MF_SIG_DELAY	0x080	/* Send signal when no longer sending */
! #define MF_SC_ACTIVE	0x100	/* Syscall tracing: in a system call now */
! #define MF_SC_DEFER	0x200	/* Syscall tracing: deferred system call */
! #define MF_SC_TRACE	0x400	/* Syscall tracing: trigger syscall events */
! #define MF_FPU_INITIALIZED	0x1000  /* process already used math, so fpu
! 					 * regs are significant (initialized)*/
! #define MF_SENDING_FROM_KERNEL	0x2000 /* message of this process is from kernel */
! #define MF_CONTEXT_SET	0x4000 /* don't touch context */
! #define MF_SPROF_SEEN	0x8000 /* profiling has seen this process */
! #define MF_FLUSH_TLB	0x10000	/* if set, TLB must be flushed before letting
! 				   this process run again. Currently it only
! 				   applies to SMP */
! #define MF_SENDA_VM_MISS 0x20000 /* set if a processes wanted to receive an asyn
! 				    message from this sender but could not
! 				    because of VM modifying the sender's address
! 				    space*/
! #define MF_STEP		 0x40000 /* Single-step process */
! 
! /* Magic process table addresses. */
! #define BEG_PROC_ADDR (&proc[0])
! #define BEG_USER_ADDR (&proc[NR_TASKS])
! #define END_PROC_ADDR (&proc[NR_TASKS + NR_PROCS])
! 
! #define proc_addr(n)      (&(proc[NR_TASKS + (n)]))
! #define proc_nr(p) 	  ((p)->p_nr)
! 
! #define isokprocn(n)      ((unsigned) ((n) + NR_TASKS) < NR_PROCS + NR_TASKS)
! #define isemptyn(n)       isemptyp(proc_addr(n)) 
! #define isemptyp(p)       ((p)->p_rts_flags == RTS_SLOT_FREE)
! #define iskernelp(p)	  ((p) < BEG_USER_ADDR)
! #define iskerneln(n)	  ((n) < 0)
! #define isuserp(p)        isusern((p) >= BEG_USER_ADDR)
! #define isusern(n)        ((n) >= 0)
! #define isrootsysn(n)	  ((n) == ROOT_SYS_PROC_NR)
! 
! #ifndef __ASSEMBLY__
! 
! EXTERN struct proc proc[NR_TASKS + NR_PROCS];	/* process table */
! 
! int mini_send(struct proc *caller_ptr, endpoint_t dst_e, message *m_ptr,
! 	int flags);
! 
! #endif /* __ASSEMBLY__ */
! 
! #endif /* PROC_H */
diff -crN usr_orig/src/kernel/system/do_chrealtime.c EDF/src/kernel/system/do_chrealtime.c
*** usr_orig/src/kernel/system/do_chrealtime.c	1970-01-01 08:00:00.000000000 +0800
--- EDF/src/kernel/system/do_chrealtime.c	2016-12-08 00:17:19.659910741 +0800
***************
*** 0 ****
--- 1,50 ----
+ /* The kernel call implemented in this file:
+  *   m_type:	SYS_CHREALTIME
+  *
+  * The parameters for this kernel call are:
+  *    m2_i1:	RA_PROC_NR   indecates a process
+  *    m2_l1:	RA_DEADLINE  deadline
+  */
+ #include "kernel/system.h"
+ #include <stdio.h>
+ #include <signal.h>
+ 
+ #if USE_CHREALTIME
+ 
+ /*===============================================================*
+  *				  do_chrealtime				     *
+ *===============================================================*/
+ 
+ void reach_deadline(timer_t * tp)
+ {
+   printf("Process %d reaches deadline.\n",tp->tmr_arg.ta_int);
+   cause_sig(tp->tmr_arg.ta_int,SIGTERM);
+   return;
+ }
+ int do_chrealtime(struct proc * caller, message *m_ptr)
+ {
+   printf("do_chrealtime in kernel/system is called\n");
+   struct proc *rp;
+   timer_t *tp;
+   rp = proc_addr(m_ptr->m2_i1); //m2_i1 is the end point, proc_addr is in kernel/proc.h
+   RTS_SET(rp, RTS_SYS_LOCK);//lock the process from schduled
+   if (rp->p_deadline.tmr_exp_time!=0)
+   {
+     reset_timer(&rp->p_deadline);
+     rp->p_deadline.tmr_exp_time = 0;
+   }
+   if (m_ptr->m2_l1!=0)//if deadline is set
+   {
+   	tp = &rp->p_deadline;
+   	tp->tmr_arg.ta_int = rp->p_nr;
+   	tp->tmr_exp_time = m_ptr->m2_l1*60+get_uptime();                                                    // timeout time = duration + the current clock uptime in ticks.
+   	tp->tmr_func = reach_deadline;                                                                      //function to terminate time out process
+   	printf("Process %d sets timer, deadline = %d \n",tp->tmr_arg.ta_int,tp->tmr_exp_time);
+   	set_timer(tp,tp->tmr_exp_time,tp->tmr_func);                                                        //clock.c, set a timer for the time out of process
+   }
+ 	RTS_UNSET(rp, RTS_SYS_LOCK);//unlock the process, it can be scheduled
+   return(OK);
+ }
+ 
+ 
+ #endif /* USE_CHREALTIME */
diff -crN usr_orig/src/kernel/system/do_clear.c EDF/src/kernel/system/do_clear.c
*** usr_orig/src/kernel/system/do_clear.c	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/system/do_clear.c	2016-12-08 00:17:19.659910741 +0800
***************
*** 1,80 ****
! /* The kernel call implemented in this file:
!  *   m_type:	SYS_CLEAR
!  *
!  * The parameters for this kernel call are:
!  *    m1_i1:	PR_ENDPT		(endpoint of process to clean up)
!  */
! 
! #include "kernel/system.h"
! 
! #include <minix/endpoint.h>
! 
! #if USE_CLEAR
! 
! /*===========================================================================*
!  *				do_clear				     *
!  *===========================================================================*/
! int do_clear(struct proc * caller, message * m_ptr)
! {
! /* Handle sys_clear. Only the PM can request other process slots to be cleared
!  * when a process has exited.
!  * The routine to clean up a process table slot cancels outstanding timers, 
!  * possibly removes the process from the message queues, and resets certain 
!  * process table fields to the default values.
!  */
!   struct proc *rc;
!   int exit_p;
!   int i;
! 
!   if(!isokendpt(m_ptr->PR_ENDPT, &exit_p)) { /* get exiting process */
!       return EINVAL;
!   }
!   rc = proc_addr(exit_p);	/* clean up */
! 
!   release_address_space(rc);
! 
!   /* Don't clear if already cleared. */
!   if(isemptyp(rc)) return OK;
! 
!   /* Check the table with IRQ hooks to see if hooks should be released. */
!   for (i=0; i < NR_IRQ_HOOKS; i++) {
!       if (rc->p_endpoint == irq_hooks[i].proc_nr_e) {
!         rm_irq_handler(&irq_hooks[i]);	/* remove interrupt handler */
!         irq_hooks[i].proc_nr_e = NONE;	/* mark hook as free */
!       } 
!   }
! 
!   /* Remove the process' ability to send and receive messages */
!   clear_endpoint(rc);
! 
!   /* Turn off any alarm timers at the clock. */   
!   reset_timer(&priv(rc)->s_alarm_timer);
! 
!   /* Make sure that the exiting process is no longer scheduled,
!    * and mark slot as FREE. Also mark saved fpu contents as not significant.
!    */
!   RTS_SETFLAGS(rc, RTS_SLOT_FREE);
!   
!   /* release FPU */
!   release_fpu(rc);
!   rc->p_misc_flags &= ~MF_FPU_INITIALIZED;
! 
!   /* Release the process table slot. If this is a system process, also
!    * release its privilege structure.  Further cleanup is not needed at
!    * this point. All important fields are reinitialized when the 
!    * slots are assigned to another, new process. 
!    */
!   if (priv(rc)->s_flags & SYS_PROC) priv(rc)->s_proc_nr = NONE;
! 
! #if 0
!   /* Clean up virtual memory */
!   if (rc->p_misc_flags & MF_VM) {
!   	vm_map_default(rc);
!   }
! #endif
! 
!   return OK;
! }
! 
! #endif /* USE_CLEAR */
! 
--- 1,85 ----
! /* The kernel call implemented in this file:
!  *   m_type:	SYS_CLEAR
!  *
!  * The parameters for this kernel call are:
!  *    m1_i1:	PR_ENDPT		(endpoint of process to clean up)
!  */
! 
! #include "kernel/system.h"
! 
! #include <minix/endpoint.h>
! 
! #if USE_CLEAR
! 
! /*===========================================================================*
!  *				do_clear				     *
!  *===========================================================================*/
! int do_clear(struct proc * caller, message * m_ptr)
! {
! /* Handle sys_clear. Only the PM can request other process slots to be cleared
!  * when a process has exited.
!  * The routine to clean up a process table slot cancels outstanding timers, 
!  * possibly removes the process from the message queues, and resets certain 
!  * process table fields to the default values.
!  */
!   struct proc *rc;
!   int exit_p;
!   int i;
! 
!   if(!isokendpt(m_ptr->PR_ENDPT, &exit_p)) { /* get exiting process */
!       return EINVAL;
!   }
!   rc = proc_addr(exit_p);	/* clean up */
! 
!   //extra clean up due to p_deadline, new added 2016.12.3
!   reset_timer(&rc->p_deadline);
!   rc->p_deadline.tmr_exp_time = 0;
! 
!   release_address_space(rc);
! 
!   /* Don't clear if already cleared. */
!   if(isemptyp(rc)) return OK;
! 
! 
!   /* Check the table with IRQ hooks to see if hooks should be released. */
!   for (i=0; i < NR_IRQ_HOOKS; i++) {
!       if (rc->p_endpoint == irq_hooks[i].proc_nr_e) {
!         rm_irq_handler(&irq_hooks[i]);	/* remove interrupt handler */
!         irq_hooks[i].proc_nr_e = NONE;	/* mark hook as free */
!       } 
!   }
! 
!   /* Remove the process' ability to send and receive messages */
!   clear_endpoint(rc);
! 
!   /* Turn off any alarm timers at the clock. */   
!   reset_timer(&priv(rc)->s_alarm_timer);
! 
!   /* Make sure that the exiting process is no longer scheduled,
!    * and mark slot as FREE. Also mark saved fpu contents as not significant.
!    */
!   RTS_SETFLAGS(rc, RTS_SLOT_FREE);
!   
!   /* release FPU */
!   release_fpu(rc);
!   rc->p_misc_flags &= ~MF_FPU_INITIALIZED;
! 
!   /* Release the process table slot. If this is a system process, also
!    * release its privilege structure.  Further cleanup is not needed at
!    * this point. All important fields are reinitialized when the 
!    * slots are assigned to another, new process. 
!    */
!   if (priv(rc)->s_flags & SYS_PROC) priv(rc)->s_proc_nr = NONE;
! 
! #if 0
!   /* Clean up virtual memory */
!   if (rc->p_misc_flags & MF_VM) {
!   	vm_map_default(rc);
!   }
! #endif
! 
!   return OK;
! }
! 
! #endif /* USE_CLEAR */
! 
diff -crN usr_orig/src/kernel/system/Makefile.inc EDF/src/kernel/system/Makefile.inc
*** usr_orig/src/kernel/system/Makefile.inc	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/system/Makefile.inc	2016-12-08 00:17:19.667910741 +0800
***************
*** 37,43 ****
  	do_vmctl.c \
  	do_schedule.c \
  	do_schedctl.c \
! 	do_statectl.c
  
  .if ${MACHINE_ARCH} == "i386"
  SRCS+=  \
--- 37,44 ----
  	do_vmctl.c \
  	do_schedule.c \
  	do_schedctl.c \
! 	do_statectl.c \
! 	do_chrealtime.c
  
  .if ${MACHINE_ARCH} == "i386"
  SRCS+=  \
diff -crN usr_orig/src/kernel/system.c EDF/src/kernel/system.c
*** usr_orig/src/kernel/system.c	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/system.c	2016-12-08 00:17:19.611910742 +0800
***************
*** 1,647 ****
! /* This task handles the interface between the kernel and user-level servers.
!  * System services can be accessed by doing a system call. System calls are 
!  * transformed into request messages, which are handled by this task. By 
!  * convention, a sys_call() is transformed in a SYS_CALL request message that
!  * is handled in a function named do_call(). 
!  *
!  * A private call vector is used to map all system calls to the functions that
!  * handle them. The actual handler functions are contained in separate files
!  * to keep this file clean. The call vector is used in the system task's main
!  * loop to handle all incoming requests.  
!  *
!  * In addition to the main sys_task() entry point, which starts the main loop,
!  * there are several other minor entry points:
!  *   get_priv:		assign privilege structure to user or system process
!  *   set_sendto_bit:	allow a process to send messages to a new target
!  *   unset_sendto_bit:	disallow a process from sending messages to a target
!  *   fill_sendto_mask:	fill the target mask of a given process
!  *   send_sig:		send a signal directly to a system process
!  *   cause_sig:		take action to cause a signal to occur via a signal mgr
!  *   sig_delay_done:	tell PM that a process is not sending
!  *   get_randomness:	accumulate randomness in a buffer
!  *   clear_endpoint:	remove a process' ability to send and receive messages
!  *   sched_proc:	schedule a process
!  *
!  * Changes:
! *    Nov 22, 2009   get_priv supports static priv ids (Cristiano Giuffrida)
!  *   Aug 04, 2005   check if system call is allowed  (Jorrit N. Herder)
!  *   Jul 20, 2005   send signal to services with message  (Jorrit N. Herder) 
!  *   Jan 15, 2005   new, generalized virtual copy function  (Jorrit N. Herder)
!  *   Oct 10, 2004   dispatch system calls from call vector  (Jorrit N. Herder)
!  *   Sep 30, 2004   source code documentation updated  (Jorrit N. Herder)
!  */
! 
! #include "kernel/kernel.h"
! #include "kernel/system.h"
! #include "kernel/vm.h"
! #include "kernel/clock.h"
! #include <stdlib.h>
! #include <assert.h>
! #include <signal.h>
! #include <unistd.h>
! #include <minix/endpoint.h>
! #include <minix/safecopies.h>
! 
! /* Declaration of the call vector that defines the mapping of system calls 
!  * to handler functions. The vector is initialized in sys_init() with map(), 
!  * which makes sure the system call numbers are ok. No space is allocated, 
!  * because the dummy is declared extern. If an illegal call is given, the 
!  * array size will be negative and this won't compile. 
!  */
! static int (*call_vec[NR_SYS_CALLS])(struct proc * caller, message *m_ptr);
! 
! #define map(call_nr, handler) 					\
!     {	int call_index = call_nr-KERNEL_CALL; 				\
!     	assert(call_index >= 0 && call_index < NR_SYS_CALLS);			\
!     call_vec[call_index] = (handler)  ; }
! 
! static void kernel_call_finish(struct proc * caller, message *msg, int result)
! {
!   if(result == VMSUSPEND) {
! 	  /* Special case: message has to be saved for handling
! 	   * until VM tells us it's allowed. VM has been notified
! 	   * and we must wait for its reply to restart the call.
! 	   */
! 	  assert(RTS_ISSET(caller, RTS_VMREQUEST));
! 	  assert(caller->p_vmrequest.type == VMSTYPE_KERNELCALL);
! 	  caller->p_vmrequest.saved.reqmsg = *msg;
! 	  caller->p_misc_flags |= MF_KCALL_RESUME;
!   } else {
! 	  /*
! 	   * call is finished, we could have been suspended because of VM,
! 	   * remove the request message
! 	   */
! 	  caller->p_vmrequest.saved.reqmsg.m_source = NONE;
! 	  if (result != EDONTREPLY) {
! 		  /* copy the result as a message to the original user buffer */
! 		  msg->m_source = SYSTEM;
! 		  msg->m_type = result;		/* report status of call */
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgkresult(msg, caller);
! #endif
! 		  if (copy_msg_to_user(msg, (message *)caller->p_delivermsg_vir)) {
! 			  printf("WARNING wrong user pointer 0x%08x from "
! 					  "process %s / %d\n",
! 					  caller->p_delivermsg_vir,
! 					  caller->p_name,
! 					  caller->p_endpoint);
! 			  cause_sig(proc_nr(caller), SIGSEGV);
! 		  }
! 	  }
!   }
! }
! 
! static int kernel_call_dispatch(struct proc * caller, message *msg)
! {
!   int result = OK;
!   int call_nr;
!   
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgkcall(msg, caller);
! #endif
!   call_nr = msg->m_type - KERNEL_CALL;
! 
!   /* See if the caller made a valid request and try to handle it. */
!   if (call_nr < 0 || call_nr >= NR_SYS_CALLS) {	/* check call number */
! 	  printf("SYSTEM: illegal request %d from %d.\n",
! 			  call_nr,msg->m_source);
! 	  result = EBADREQUEST;			/* illegal message type */
!   }
!   else if (!GET_BIT(priv(caller)->s_k_call_mask, call_nr)) {
! 	  printf("SYSTEM: denied request %d from %d.\n",
! 			  call_nr,msg->m_source);
! 	  result = ECALLDENIED;			/* illegal message type */
!   } else {
! 	  /* handle the system call */
! 	  if (call_vec[call_nr])
! 		  result = (*call_vec[call_nr])(caller, msg);
! 	  else {
! 		  printf("Unused kernel call %d from %d\n",
! 				  call_nr, caller->p_endpoint);
! 		  result = EBADREQUEST;
! 	  }
!   }
! 
!   return result;
! }
! 
! /*===========================================================================*
!  *				kernel_call				     *
!  *===========================================================================*/
! /*
!  * this function checks the basic syscall parameters and if accepted it
!  * dispatches its handling to the right handler
!  */
! void kernel_call(message *m_user, struct proc * caller)
! {
!   int result = OK;
!   message msg;
! 
!   caller->p_delivermsg_vir = (vir_bytes) m_user;
!   /*
!    * the ldt and cr3 of the caller process is loaded because it just've trapped
!    * into the kernel or was already set in switch_to_user() before we resume
!    * execution of an interrupted kernel call
!    */
!   if (copy_msg_from_user(m_user, &msg) == 0) {
! 	  msg.m_source = caller->p_endpoint;
! 	  result = kernel_call_dispatch(caller, &msg);
!   }
!   else {
! 	  printf("WARNING wrong user pointer 0x%08x from process %s / %d\n",
! 			  m_user, caller->p_name, caller->p_endpoint);
! 	  cause_sig(proc_nr(caller), SIGSEGV);
! 	  return;
!   }
! 
!   
!   /* remember who invoked the kcall so we can bill it its time */
!   kbill_kcall = caller;
! 
!   kernel_call_finish(caller, &msg, result);
! }
! 
! /*===========================================================================*
!  *				initialize				     *
!  *===========================================================================*/
! void system_init(void)
! {
!   register struct priv *sp;
!   int i;
! 
!   /* Initialize IRQ handler hooks. Mark all hooks available. */
!   for (i=0; i<NR_IRQ_HOOKS; i++) {
!       irq_hooks[i].proc_nr_e = NONE;
!   }
! 
!   /* Initialize all alarm timers for all processes. */
!   for (sp=BEG_PRIV_ADDR; sp < END_PRIV_ADDR; sp++) {
!     tmr_inittimer(&(sp->s_alarm_timer));
!   }
! 
!   /* Initialize the call vector to a safe default handler. Some system calls 
!    * may be disabled or nonexistant. Then explicitely map known calls to their
!    * handler functions. This is done with a macro that gives a compile error
!    * if an illegal call number is used. The ordering is not important here.
!    */
!   for (i=0; i<NR_SYS_CALLS; i++) {
!       call_vec[i] = NULL;
!   }
! 
!   /* Process management. */
!   map(SYS_FORK, do_fork); 		/* a process forked a new process */
!   map(SYS_EXEC, do_exec);		/* update process after execute */
!   map(SYS_CLEAR, do_clear);		/* clean up after process exit */
!   map(SYS_EXIT, do_exit);		/* a system process wants to exit */
!   map(SYS_PRIVCTL, do_privctl);		/* system privileges control */
!   map(SYS_TRACE, do_trace);		/* request a trace operation */
!   map(SYS_SETGRANT, do_setgrant);	/* get/set own parameters */
!   map(SYS_RUNCTL, do_runctl);		/* set/clear stop flag of a process */
!   map(SYS_UPDATE, do_update);		/* update a process into another */
!   map(SYS_STATECTL, do_statectl);	/* let a process control its state */
! 
!   /* Signal handling. */
!   map(SYS_KILL, do_kill); 		/* cause a process to be signaled */
!   map(SYS_GETKSIG, do_getksig);		/* signal manager checks for signals */
!   map(SYS_ENDKSIG, do_endksig);		/* signal manager finished signal */
!   map(SYS_SIGSEND, do_sigsend);		/* start POSIX-style signal */
!   map(SYS_SIGRETURN, do_sigreturn);	/* return from POSIX-style signal */
! 
!   /* Device I/O. */
!   map(SYS_IRQCTL, do_irqctl);  		/* interrupt control operations */ 
! #if defined(__i386__)
!   map(SYS_DEVIO, do_devio);   		/* inb, inw, inl, outb, outw, outl */ 
!   map(SYS_VDEVIO, do_vdevio);  		/* vector with devio requests */ 
! #endif
! 
!   /* Memory management. */
!   map(SYS_MEMSET, do_memset);		/* write char to memory area */
!   map(SYS_VMCTL, do_vmctl);		/* various VM process settings */
! 
!   /* Copying. */
!   map(SYS_UMAP, do_umap);		/* map virtual to physical address */
!   map(SYS_UMAP_REMOTE, do_umap_remote);	/* do_umap for non-caller process */
!   map(SYS_VUMAP, do_vumap);		/* vectored virtual to physical map */
!   map(SYS_VIRCOPY, do_vircopy); 	/* use pure virtual addressing */
!   map(SYS_PHYSCOPY, do_copy);	 	/* use physical addressing */
!   map(SYS_SAFECOPYFROM, do_safecopy_from);/* copy with pre-granted permission */
!   map(SYS_SAFECOPYTO, do_safecopy_to);	/* copy with pre-granted permission */
!   map(SYS_VSAFECOPY, do_vsafecopy);	/* vectored safecopy */
! 
!   /* safe memset */
!   map(SYS_SAFEMEMSET, do_safememset);	/* safememset */
! 
!   /* Clock functionality. */
!   map(SYS_TIMES, do_times);		/* get uptime and process times */
!   map(SYS_SETALARM, do_setalarm);	/* schedule a synchronous alarm */
!   map(SYS_STIME, do_stime);		/* set the boottime */
!   map(SYS_VTIMER, do_vtimer);		/* set or retrieve a virtual timer */
! 
!   /* System control. */
!   map(SYS_ABORT, do_abort);		/* abort MINIX */
!   map(SYS_GETINFO, do_getinfo); 	/* request system information */ 
!   map(SYS_SYSCTL, do_sysctl); 		/* misc system manipulation */ 
! 
!   /* Profiling. */
!   map(SYS_SPROF, do_sprofile);         /* start/stop statistical profiling */
!   map(SYS_CPROF, do_cprofile);         /* get/reset call profiling data */
!   map(SYS_PROFBUF, do_profbuf);        /* announce locations to kernel */
! 
!   /* i386-specific. */
! #if defined(__i386__)
!   map(SYS_READBIOS, do_readbios);	/* read from BIOS locations */
!   map(SYS_IOPENABLE, do_iopenable); 	/* Enable I/O */
!   map(SYS_SDEVIO, do_sdevio);		/* phys_insb, _insw, _outsb, _outsw */
! #endif
! 
!   /* Machine state switching. */
!   map(SYS_SETMCONTEXT, do_setmcontext); /* set machine context */
!   map(SYS_GETMCONTEXT, do_getmcontext); /* get machine context */
! 
!   /* Scheduling */
!   map(SYS_SCHEDULE, do_schedule);	/* reschedule a process */
!   map(SYS_SCHEDCTL, do_schedctl);	/* change process scheduler */
! 
! }
! /*===========================================================================*
!  *				get_priv				     *
!  *===========================================================================*/
! int get_priv(rc, priv_id)
! register struct proc *rc;		/* new (child) process pointer */
! int priv_id;				/* privilege id */
! {
! /* Allocate a new privilege structure for a system process. Privilege ids
!  * can be assigned either statically or dynamically.
!  */
!   register struct priv *sp;                 /* privilege structure */
! 
!   if(priv_id == NULL_PRIV_ID) {             /* allocate slot dynamically */
!       for (sp = BEG_DYN_PRIV_ADDR; sp < END_DYN_PRIV_ADDR; ++sp) 
!           if (sp->s_proc_nr == NONE) break;	
!       if (sp >= END_DYN_PRIV_ADDR) return(ENOSPC);
!   }
!   else {                                    /* allocate slot from id */
!       if(!is_static_priv_id(priv_id)) {
!           return EINVAL;                    /* invalid static priv id */
!       }
!       if(priv[priv_id].s_proc_nr != NONE) {
!           return EBUSY;                     /* slot already in use */
!       }
!       sp = &priv[priv_id];
!   }
!   rc->p_priv = sp;			    /* assign new slot */
!   rc->p_priv->s_proc_nr = proc_nr(rc);	    /* set association */
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				set_sendto_bit				     *
!  *===========================================================================*/
! void set_sendto_bit(const struct proc *rp, int id)
! {
! /* Allow a process to send messages to the process(es) associated with the
!  * system privilege structure with the given ID. 
!  */
! 
!   /* Disallow the process from sending to a process privilege structure with no
!    * associated process, and disallow the process from sending to itself.
!    */
!   if (id_to_nr(id) == NONE || priv_id(rp) == id) {
! 	unset_sys_bit(priv(rp)->s_ipc_to, id);
! 	return;
!   }
! 
!   set_sys_bit(priv(rp)->s_ipc_to, id);
! 
!   /* The process that this process can now send to, must be able to reply (or
!    * vice versa). Therefore, its send mask should be updated as well. Ignore
!    * receivers that don't support traps other than RECEIVE, they can't reply
!    * or send messages anyway.
!    */
!   if (priv_addr(id)->s_trap_mask & ~((1 << RECEIVE)))
!       set_sys_bit(priv_addr(id)->s_ipc_to, priv_id(rp));
! }
! 
! /*===========================================================================*
!  *				unset_sendto_bit			     *
!  *===========================================================================*/
! void unset_sendto_bit(const struct proc *rp, int id)
! {
! /* Prevent a process from sending to another process. Retain the send mask
!  * symmetry by also unsetting the bit for the other direction.
!  */
! 
!   unset_sys_bit(priv(rp)->s_ipc_to, id);
! 
!   unset_sys_bit(priv_addr(id)->s_ipc_to, priv_id(rp));
! }
! 
! /*===========================================================================*
!  *			      fill_sendto_mask				     *
!  *===========================================================================*/
! void fill_sendto_mask(const struct proc *rp, sys_map_t *map)
! {
!   int i;
! 
!   for (i=0; i < NR_SYS_PROCS; i++) {
!   	if (get_sys_bit(*map, i))
!   		set_sendto_bit(rp, i);
!   	else
!   		unset_sendto_bit(rp, i);
!   }
! }
! 
! /*===========================================================================*
!  *				send_sig				     *
!  *===========================================================================*/
! int send_sig(endpoint_t ep, int sig_nr)
! {
! /* Notify a system process about a signal. This is straightforward. Simply
!  * set the signal that is to be delivered in the pending signals map and 
!  * send a notification with source SYSTEM.
!  */ 
!   register struct proc *rp;
!   struct priv *priv;
!   int proc_nr;
! 
!   if(!isokendpt(ep, &proc_nr) || isemptyn(proc_nr))
! 	return EINVAL;
! 
!   rp = proc_addr(proc_nr);
!   priv = priv(rp);
!   if(!priv) return ENOENT;
!   sigaddset(&priv->s_sig_pending, sig_nr);
!   mini_notify(proc_addr(SYSTEM), rp->p_endpoint);
! 
!   return OK;
! }
! 
! /*===========================================================================*
!  *				cause_sig				     *
!  *===========================================================================*/
! void cause_sig(proc_nr, sig_nr)
! proc_nr_t proc_nr;		/* process to be signalled */
! int sig_nr;			/* signal to be sent */
! {
! /* A system process wants to send a signal to a process.  Examples are:
!  *  - HARDWARE wanting to cause a SIGSEGV after a CPU exception
!  *  - TTY wanting to cause SIGINT upon getting a DEL
!  *  - FS wanting to cause SIGPIPE for a broken pipe 
!  * Signals are handled by sending a message to the signal manager assigned to
!  * the process. This function handles the signals and makes sure the signal
!  * manager gets them by sending a notification. The process being signaled
!  * is blocked while the signal manager has not finished all signals for it.
!  * Race conditions between calls to this function and the system calls that
!  * process pending kernel signals cannot exist. Signal related functions are
!  * only called when a user process causes a CPU exception and from the kernel 
!  * process level, which runs to completion.
!  */
!   register struct proc *rp, *sig_mgr_rp;
!   endpoint_t sig_mgr;
!   int sig_mgr_proc_nr;
! 
!   /* Lookup signal manager. */
!   rp = proc_addr(proc_nr);
!   sig_mgr = priv(rp)->s_sig_mgr;
!   if(sig_mgr == SELF) sig_mgr = rp->p_endpoint;
! 
!   /* If the target is the signal manager of itself, send the signal directly. */
!   if(rp->p_endpoint == sig_mgr) {
!        if(SIGS_IS_LETHAL(sig_nr)) {
!            /* If the signal is lethal, see if a backup signal manager exists. */
!            sig_mgr = priv(rp)->s_bak_sig_mgr;
!            if(sig_mgr != NONE && isokendpt(sig_mgr, &sig_mgr_proc_nr)) {
!                priv(rp)->s_sig_mgr = sig_mgr;
!                priv(rp)->s_bak_sig_mgr = NONE;
!                sig_mgr_rp = proc_addr(sig_mgr_proc_nr);
!                RTS_UNSET(sig_mgr_rp, RTS_NO_PRIV);
!                cause_sig(proc_nr, sig_nr); /* try again with the new sig mgr. */
!                return;
!            }
!            /* We are out of luck. Time to panic. */
!            proc_stacktrace(rp);
!            panic("cause_sig: sig manager %d gets lethal signal %d for itself",
! 	   	rp->p_endpoint, sig_nr);
!        }
!        sigaddset(&priv(rp)->s_sig_pending, sig_nr);
!        if(OK != send_sig(rp->p_endpoint, SIGKSIGSM))
!        	panic("send_sig failed");
!        return;
!   }
! 
!   /* Check if the signal is already pending. Process it otherwise. */
!   if (! sigismember(&rp->p_pending, sig_nr)) {
!       sigaddset(&rp->p_pending, sig_nr);
!       if (! (RTS_ISSET(rp, RTS_SIGNALED))) {		/* other pending */
! 	  RTS_SET(rp, RTS_SIGNALED | RTS_SIG_PENDING);
!           if(OK != send_sig(sig_mgr, SIGKSIG))
! 	  	panic("send_sig failed");
!       }
!   }
! }
! 
! /*===========================================================================*
!  *				sig_delay_done				     *
!  *===========================================================================*/
! void sig_delay_done(struct proc *rp)
! {
! /* A process is now known not to send any direct messages.
!  * Tell PM that the stop delay has ended, by sending a signal to the process.
!  * Used for actual signal delivery.
!  */
! 
!   rp->p_misc_flags &= ~MF_SIG_DELAY;
! 
!   cause_sig(proc_nr(rp), SIGSNDELAY);
! }
! 
! /*===========================================================================*
!  *			         clear_ipc				     *
!  *===========================================================================*/
! static void clear_ipc(
!   register struct proc *rc	/* slot of process to clean up */
! )
! {
! /* Clear IPC data for a given process slot. */
!   struct proc **xpp;			/* iterate over caller queue */
! 
!   if (RTS_ISSET(rc, RTS_SENDING)) {
!       int target_proc;
! 
!       okendpt(rc->p_sendto_e, &target_proc);
!       xpp = &proc_addr(target_proc)->p_caller_q; /* destination's queue */
!       while (*xpp) {		/* check entire queue */
!           if (*xpp == rc) {			/* process is on the queue */
!               *xpp = (*xpp)->p_q_link;		/* replace by next process */
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	      printf("endpoint %d / %s removed from queue at %d\n",
! 	          rc->p_endpoint, rc->p_name, rc->p_sendto_e);
! #endif
!               break;				/* can only be queued once */
!           }
!           xpp = &(*xpp)->p_q_link;		/* proceed to next queued */
!       }
!       RTS_UNSET(rc, RTS_SENDING);
!   }
!   RTS_UNSET(rc, RTS_RECEIVING);
! }
! 
! /*===========================================================================*
!  *			         clear_endpoint				     *
!  *===========================================================================*/
! void clear_endpoint(rc)
! register struct proc *rc;		/* slot of process to clean up */
! {
!   if(isemptyp(rc)) panic("clear_proc: empty process: %d",  rc->p_endpoint);
! 
! 
! #if DEBUG_IPC_HOOK
!   hook_ipc_clear(rc);
! #endif
! 
!   /* Make sure that the exiting process is no longer scheduled. */
!   RTS_SET(rc, RTS_NO_ENDPOINT);
!   if (priv(rc)->s_flags & SYS_PROC)
!   {
! 	priv(rc)->s_asynsize= 0;
!   }
! 
!   /* If the process happens to be queued trying to send a
!    * message, then it must be removed from the message queues.
!    */
!   clear_ipc(rc);
! 
!   /* Likewise, if another process was sending or receive a message to or from 
!    * the exiting process, it must be alerted that process no longer is alive.
!    * Check all processes. 
!    */
!   clear_ipc_refs(rc, EDEADSRCDST);
! 
! }
! 
! /*===========================================================================*
!  *			       clear_ipc_refs				     *
!  *===========================================================================*/
! void clear_ipc_refs(rc, caller_ret)
! register struct proc *rc;		/* slot of process to clean up */
! int caller_ret;				/* code to return on callers */
! {
! /* Clear IPC references for a given process slot. */
!   struct proc *rp;			/* iterate over process table */
!   int src_id;
! 
!   /* Tell processes that sent asynchronous messages to 'rc' they are not
!    * going to be delivered */
!   while ((src_id = has_pending_asend(rc, ANY)) != NULL_PRIV_ID) 
!       cancel_async(proc_addr(id_to_nr(src_id)), rc);
! 
!   for (rp = BEG_PROC_ADDR; rp < END_PROC_ADDR; rp++) {
!       if(isemptyp(rp))
! 	continue;
! 
!       /* Unset pending notification bits. */
!       unset_sys_bit(priv(rp)->s_notify_pending, priv(rc)->s_id);
! 
!       /* Unset pending asynchronous messages */
!       unset_sys_bit(priv(rp)->s_asyn_pending, priv(rc)->s_id);
! 
!       /* Check if process depends on given process. */
!       if (P_BLOCKEDON(rp) == rc->p_endpoint) {
!           rp->p_reg.retreg = caller_ret;	/* return requested code */
! 	  clear_ipc(rp);
!       }
!   }
! }
! 
! /*===========================================================================*
!  *                              kernel_call_resume                           *
!  *===========================================================================*/
! void kernel_call_resume(struct proc *caller)
! {
! 	int result;
! 
! 	assert(!RTS_ISSET(caller, RTS_SLOT_FREE));
! 	assert(!RTS_ISSET(caller, RTS_VMREQUEST));
! 
! 	assert(caller->p_vmrequest.saved.reqmsg.m_source == caller->p_endpoint);
! 
! 	/*
! 	printf("KERNEL_CALL restart from %s / %d rts 0x%08x misc 0x%08x\n",
! 			caller->p_name, caller->p_endpoint,
! 			caller->p_rts_flags, caller->p_misc_flags);
! 	 */
! 
! 	/* re-execute the kernel call, with MF_KCALL_RESUME still set so
! 	 * the call knows this is a retry.
! 	 */
! 	result = kernel_call_dispatch(caller, &caller->p_vmrequest.saved.reqmsg);
! 	/*
! 	 * we are resuming the kernel call so we have to remove this flag so it
! 	 * can be set again
! 	 */
! 	caller->p_misc_flags &= ~MF_KCALL_RESUME;
! 	kernel_call_finish(caller, &caller->p_vmrequest.saved.reqmsg, result);
! }
! 
! /*===========================================================================*
!  *                               sched_proc                                  *
!  *===========================================================================*/
! int sched_proc(struct proc *p,
! 			int priority,
! 			int quantum,
! 			int cpu)
! {
! 	/* Make sure the values given are within the allowed range.*/
! 	if ((priority < TASK_Q && priority != -1) || priority > NR_SCHED_QUEUES)
! 		return(EINVAL);
! 
! 	if (quantum < 1 && quantum != -1)
! 		return(EINVAL);
! 
! #ifdef CONFIG_SMP
! 	if ((cpu < 0 && cpu != -1) || (cpu > 0 && (unsigned) cpu >= ncpus))
! 		return(EINVAL);
! 	if (cpu != -1 && !(cpu_is_ready(cpu)))
! 		return EBADCPU;
! #endif
! 
! 	/* In some cases, we might be rescheduling a runnable process. In such
! 	 * a case (i.e. if we are updating the priority) we set the NO_QUANTUM
! 	 * flag before the generic unset to dequeue/enqueue the process
! 	 */
! 
! 	/* FIXME this preempts the process, do we really want to do that ?*/
! 
! 	/* FIXME this is a problem for SMP if the processes currently runs on a
! 	 * different CPU */
! 	if (proc_is_runnable(p)) {
! #ifdef CONFIG_SMP
! 		if (p->p_cpu != cpuid && cpu != -1 && cpu != p->p_cpu) {
! 			smp_schedule_migrate_proc(p, cpu);
! 		}
! #endif
! 
! 		RTS_SET(p, RTS_NO_QUANTUM);
! 	}
! 
! 	if (proc_is_runnable(p))
! 		RTS_SET(p, RTS_NO_QUANTUM);
! 
! 	if (priority != -1)
! 		p->p_priority = priority;
! 	if (quantum != -1) {
! 		p->p_quantum_size_ms = quantum;
! 		p->p_cpu_time_left = ms_2_cpu_time(quantum);
! 	}
! #ifdef CONFIG_SMP
! 	if (cpu != -1)
! 		p->p_cpu = cpu;
! #endif
! 
! 	/* Clear the scheduling bit and enqueue the process */
! 	RTS_UNSET(p, RTS_NO_QUANTUM);
! 
! 	return OK;
! }
! 
--- 1,653 ----
! /* This task handles the interface between the kernel and user-level servers.
!  * System services can be accessed by doing a system call. System calls are 
!  * transformed into request messages, which are handled by this task. By 
!  * convention, a sys_call() is transformed in a SYS_CALL request message that
!  * is handled in a function named do_call(). 
!  *
!  * A private call vector is used to map all system calls to the functions that
!  * handle them. The actual handler functions are contained in separate files
!  * to keep this file clean. The call vector is used in the system task's main
!  * loop to handle all incoming requests.  
!  *
!  * In addition to the main sys_task() entry point, which starts the main loop,
!  * there are several other minor entry points:
!  *   get_priv:		assign privilege structure to user or system process
!  *   set_sendto_bit:	allow a process to send messages to a new target
!  *   unset_sendto_bit:	disallow a process from sending messages to a target
!  *   fill_sendto_mask:	fill the target mask of a given process
!  *   send_sig:		send a signal directly to a system process
!  *   cause_sig:		take action to cause a signal to occur via a signal mgr
!  *   sig_delay_done:	tell PM that a process is not sending
!  *   get_randomness:	accumulate randomness in a buffer
!  *   clear_endpoint:	remove a process' ability to send and receive messages
!  *   sched_proc:	schedule a process
!  *
!  * Changes:
! *    Nov 22, 2009   get_priv supports static priv ids (Cristiano Giuffrida)
!  *   Aug 04, 2005   check if system call is allowed  (Jorrit N. Herder)
!  *   Jul 20, 2005   send signal to services with message  (Jorrit N. Herder) 
!  *   Jan 15, 2005   new, generalized virtual copy function  (Jorrit N. Herder)
!  *   Oct 10, 2004   dispatch system calls from call vector  (Jorrit N. Herder)
!  *   Sep 30, 2004   source code documentation updated  (Jorrit N. Herder)
!  */
! 
! #include "kernel/kernel.h"
! #include "kernel/system.h"
! #include "kernel/vm.h"
! #include "kernel/clock.h"
! #include <stdlib.h>
! #include <assert.h>
! #include <signal.h>
! #include <unistd.h>
! #include <minix/endpoint.h>
! #include <minix/safecopies.h>
! 
! /* Declaration of the call vector that defines the mapping of system calls 
!  * to handler functions. The vector is initialized in sys_init() with map(), 
!  * which makes sure the system call numbers are ok. No space is allocated, 
!  * because the dummy is declared extern. If an illegal call is given, the 
!  * array size will be negative and this won't compile. 
!  */
! static int (*call_vec[NR_SYS_CALLS])(struct proc * caller, message *m_ptr);
! 
! #define map(call_nr, handler) 					\
!     {	int call_index = call_nr-KERNEL_CALL; 				\
!     	assert(call_index >= 0 && call_index < NR_SYS_CALLS);			\
!     call_vec[call_index] = (handler)  ; }
! 
! static void kernel_call_finish(struct proc * caller, message *msg, int result)
! {
!   if(result == VMSUSPEND) {
! 	  /* Special case: message has to be saved for handling
! 	   * until VM tells us it's allowed. VM has been notified
! 	   * and we must wait for its reply to restart the call.
! 	   */
! 	  assert(RTS_ISSET(caller, RTS_VMREQUEST));
! 	  assert(caller->p_vmrequest.type == VMSTYPE_KERNELCALL);
! 	  caller->p_vmrequest.saved.reqmsg = *msg;
! 	  caller->p_misc_flags |= MF_KCALL_RESUME;
!   } else {
! 	  /*
! 	   * call is finished, we could have been suspended because of VM,
! 	   * remove the request message
! 	   */
! 	  caller->p_vmrequest.saved.reqmsg.m_source = NONE;
! 	  if (result != EDONTREPLY) {
! 		  /* copy the result as a message to the original user buffer */
! 		  msg->m_source = SYSTEM;
! 		  msg->m_type = result;		/* report status of call */
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgkresult(msg, caller);
! #endif
! 		  if (copy_msg_to_user(msg, (message *)caller->p_delivermsg_vir)) {
! 			  printf("WARNING wrong user pointer 0x%08x from "
! 					  "process %s / %d\n",
! 					  caller->p_delivermsg_vir,
! 					  caller->p_name,
! 					  caller->p_endpoint);
! 			  cause_sig(proc_nr(caller), SIGSEGV);
! 		  }
! 	  }
!   }
! }
! 
! static int kernel_call_dispatch(struct proc * caller, message *msg)
! {
!   int result = OK;
!   int call_nr;
!   
! #if DEBUG_IPC_HOOK
! 	hook_ipc_msgkcall(msg, caller);
! #endif
!   call_nr = msg->m_type - KERNEL_CALL;
! 
!   /* See if the caller made a valid request and try to handle it. */
!   if (call_nr < 0 || call_nr >= NR_SYS_CALLS) {	/* check call number */
! 	  printf("SYSTEM: illegal request %d from %d.\n",
! 			  call_nr,msg->m_source);
! 	  result = EBADREQUEST;			/* illegal message type */
!   }
!   else if (!GET_BIT(priv(caller)->s_k_call_mask, call_nr)) {
! 	  printf("SYSTEM: denied request %d from %d.\n",
! 			  call_nr,msg->m_source);
! 	  result = ECALLDENIED;			/* illegal message type */
!   } else {
! 	  /* handle the system call */
! 	  if (call_vec[call_nr])
! 		  result = (*call_vec[call_nr])(caller, msg);
! 	  else {
! 		  printf("Unused kernel call %d from %d\n",
! 				  call_nr, caller->p_endpoint);
! 		  result = EBADREQUEST;
! 	  }
!   }
! 
!   return result;
! }
! 
! /*===========================================================================*
!  *				kernel_call				     *
!  *===========================================================================*/
! /*
!  * this function checks the basic syscall parameters and if accepted it
!  * dispatches its handling to the right handler
!  */
! void kernel_call(message *m_user, struct proc * caller)
! {
!   int result = OK;
!   message msg;
! 
!   caller->p_delivermsg_vir = (vir_bytes) m_user;
!   /*
!    * the ldt and cr3 of the caller process is loaded because it just've trapped
!    * into the kernel or was already set in switch_to_user() before we resume
!    * execution of an interrupted kernel call
!    */
!   if (copy_msg_from_user(m_user, &msg) == 0) {
! 	  msg.m_source = caller->p_endpoint;
! 	  result = kernel_call_dispatch(caller, &msg);
!   }
!   else {
! 	  printf("WARNING wrong user pointer 0x%08x from process %s / %d\n",
! 			  m_user, caller->p_name, caller->p_endpoint);
! 	  cause_sig(proc_nr(caller), SIGSEGV);
! 	  return;
!   }
! 
!   
!   /* remember who invoked the kcall so we can bill it its time */
!   kbill_kcall = caller;
! 
!   kernel_call_finish(caller, &msg, result);
! }
! 
! /*===========================================================================*
!  *				initialize				     *
!  *===========================================================================*/
! void system_init(void)
! {
!   register struct priv *sp;
!   int i;
! 
!   /* Initialize IRQ handler hooks. Mark all hooks available. */
!   for (i=0; i<NR_IRQ_HOOKS; i++) {
!       irq_hooks[i].proc_nr_e = NONE;
!   }
! 
!   /* Initialize all alarm timers for all processes. */
!   for (sp=BEG_PRIV_ADDR; sp < END_PRIV_ADDR; sp++) {
!     tmr_inittimer(&(sp->s_alarm_timer));
!   }
! 
!   /* Initialize the call vector to a safe default handler. Some system calls 
!    * may be disabled or nonexistant. Then explicitely map known calls to their
!    * handler functions. This is done with a macro that gives a compile error
!    * if an illegal call number is used. The ordering is not important here.
!    */
!   for (i=0; i<NR_SYS_CALLS; i++) {
!       call_vec[i] = NULL;
!   }
! 
!   /* Process management. */
!   map(SYS_FORK, do_fork); 		/* a process forked a new process */
!   map(SYS_EXEC, do_exec);		/* update process after execute */
!   map(SYS_CLEAR, do_clear);		/* clean up after process exit */
!   map(SYS_EXIT, do_exit);		/* a system process wants to exit */
!   map(SYS_PRIVCTL, do_privctl);		/* system privileges control */
!   map(SYS_TRACE, do_trace);		/* request a trace operation */
!   map(SYS_SETGRANT, do_setgrant);	/* get/set own parameters */
!   map(SYS_RUNCTL, do_runctl);		/* set/clear stop flag of a process */
!   map(SYS_UPDATE, do_update);		/* update a process into another */
!   map(SYS_STATECTL, do_statectl);	/* let a process control its state */
!   map(SYS_CHREALTIME, do_chrealtime);   //change realtime, new added 2016.12.3
! 
!   /* Signal handling. */
!   map(SYS_KILL, do_kill); 		/* cause a process to be signaled */
!   map(SYS_GETKSIG, do_getksig);		/* signal manager checks for signals */
!   map(SYS_ENDKSIG, do_endksig);		/* signal manager finished signal */
!   map(SYS_SIGSEND, do_sigsend);		/* start POSIX-style signal */
!   map(SYS_SIGRETURN, do_sigreturn);	/* return from POSIX-style signal */
! 
!   /* Device I/O. */
!   map(SYS_IRQCTL, do_irqctl);  		/* interrupt control operations */ 
! #if defined(__i386__)
!   map(SYS_DEVIO, do_devio);   		/* inb, inw, inl, outb, outw, outl */ 
!   map(SYS_VDEVIO, do_vdevio);  		/* vector with devio requests */ 
! #endif
! 
!   /* Memory management. */
!   map(SYS_MEMSET, do_memset);		/* write char to memory area */
!   map(SYS_VMCTL, do_vmctl);		/* various VM process settings */
! 
!   /* Copying. */
!   map(SYS_UMAP, do_umap);		/* map virtual to physical address */
!   map(SYS_UMAP_REMOTE, do_umap_remote);	/* do_umap for non-caller process */
!   map(SYS_VUMAP, do_vumap);		/* vectored virtual to physical map */
!   map(SYS_VIRCOPY, do_vircopy); 	/* use pure virtual addressing */
!   map(SYS_PHYSCOPY, do_copy);	 	/* use physical addressing */
!   map(SYS_SAFECOPYFROM, do_safecopy_from);/* copy with pre-granted permission */
!   map(SYS_SAFECOPYTO, do_safecopy_to);	/* copy with pre-granted permission */
!   map(SYS_VSAFECOPY, do_vsafecopy);	/* vectored safecopy */
! 
!   /* safe memset */
!   map(SYS_SAFEMEMSET, do_safememset);	/* safememset */
! 
!   /* Clock functionality. */
!   map(SYS_TIMES, do_times);		/* get uptime and process times */
!   map(SYS_SETALARM, do_setalarm);	/* schedule a synchronous alarm */
!   map(SYS_STIME, do_stime);		/* set the boottime */
!   map(SYS_VTIMER, do_vtimer);		/* set or retrieve a virtual timer */
! 
!   /* System control. */
!   map(SYS_ABORT, do_abort);		/* abort MINIX */
!   map(SYS_GETINFO, do_getinfo); 	/* request system information */ 
!   map(SYS_SYSCTL, do_sysctl); 		/* misc system manipulation */ 
! 
!   /* Profiling. */
!   map(SYS_SPROF, do_sprofile);         /* start/stop statistical profiling */
!   map(SYS_CPROF, do_cprofile);         /* get/reset call profiling data */
!   map(SYS_PROFBUF, do_profbuf);        /* announce locations to kernel */
! 
!   /* i386-specific. */
! #if defined(__i386__)
!   map(SYS_READBIOS, do_readbios);	/* read from BIOS locations */
!   map(SYS_IOPENABLE, do_iopenable); 	/* Enable I/O */
!   map(SYS_SDEVIO, do_sdevio);		/* phys_insb, _insw, _outsb, _outsw */
! #endif
! 
!   /* Machine state switching. */
!   map(SYS_SETMCONTEXT, do_setmcontext); /* set machine context */
!   map(SYS_GETMCONTEXT, do_getmcontext); /* get machine context */
! 
!   /* Scheduling */
!   map(SYS_SCHEDULE, do_schedule);	/* reschedule a process */
!   map(SYS_SCHEDCTL, do_schedctl);	/* change process scheduler */
! 
! }
! /*===========================================================================*
!  *				get_priv				     *
!  *===========================================================================*/
! int get_priv(rc, priv_id)
! register struct proc *rc;		/* new (child) process pointer */
! int priv_id;				/* privilege id */
! {
! /* Allocate a new privilege structure for a system process. Privilege ids
!  * can be assigned either statically or dynamically.
!  */
!   register struct priv *sp;                 /* privilege structure */
! 
!   if(priv_id == NULL_PRIV_ID) {             /* allocate slot dynamically */
!       for (sp = BEG_DYN_PRIV_ADDR; sp < END_DYN_PRIV_ADDR; ++sp) 
!           if (sp->s_proc_nr == NONE) break;	
!       if (sp >= END_DYN_PRIV_ADDR) return(ENOSPC);
!   }
!   else {                                    /* allocate slot from id */
!       if(!is_static_priv_id(priv_id)) {
!           return EINVAL;                    /* invalid static priv id */
!       }
!       if(priv[priv_id].s_proc_nr != NONE) {
!           return EBUSY;                     /* slot already in use */
!       }
!       sp = &priv[priv_id];
!   }
!   rc->p_priv = sp;			    /* assign new slot */
!   rc->p_priv->s_proc_nr = proc_nr(rc);	    /* set association */
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				set_sendto_bit				     *
!  *===========================================================================*/
! void set_sendto_bit(const struct proc *rp, int id)
! {
! /* Allow a process to send messages to the process(es) associated with the
!  * system privilege structure with the given ID. 
!  */
! 
!   /* Disallow the process from sending to a process privilege structure with no
!    * associated process, and disallow the process from sending to itself.
!    */
!   if (id_to_nr(id) == NONE || priv_id(rp) == id) {
! 	unset_sys_bit(priv(rp)->s_ipc_to, id);
! 	return;
!   }
! 
!   set_sys_bit(priv(rp)->s_ipc_to, id);
! 
!   /* The process that this process can now send to, must be able to reply (or
!    * vice versa). Therefore, its send mask should be updated as well. Ignore
!    * receivers that don't support traps other than RECEIVE, they can't reply
!    * or send messages anyway.
!    */
!   if (priv_addr(id)->s_trap_mask & ~((1 << RECEIVE)))
!       set_sys_bit(priv_addr(id)->s_ipc_to, priv_id(rp));
! }
! 
! /*===========================================================================*
!  *				unset_sendto_bit			     *
!  *===========================================================================*/
! void unset_sendto_bit(const struct proc *rp, int id)
! {
! /* Prevent a process from sending to another process. Retain the send mask
!  * symmetry by also unsetting the bit for the other direction.
!  */
! 
!   unset_sys_bit(priv(rp)->s_ipc_to, id);
! 
!   unset_sys_bit(priv_addr(id)->s_ipc_to, priv_id(rp));
! }
! 
! /*===========================================================================*
!  *			      fill_sendto_mask				     *
!  *===========================================================================*/
! void fill_sendto_mask(const struct proc *rp, sys_map_t *map)
! {
!   int i;
! 
!   for (i=0; i < NR_SYS_PROCS; i++) {
!   	if (get_sys_bit(*map, i))
!   		set_sendto_bit(rp, i);
!   	else
!   		unset_sendto_bit(rp, i);
!   }
! }
! 
! /*===========================================================================*
!  *				send_sig				     *
!  *===========================================================================*/
! int send_sig(endpoint_t ep, int sig_nr)
! {
! /* Notify a system process about a signal. This is straightforward. Simply
!  * set the signal that is to be delivered in the pending signals map and 
!  * send a notification with source SYSTEM.
!  */ 
!   register struct proc *rp;
!   struct priv *priv;
!   int proc_nr;
! 
!   if(!isokendpt(ep, &proc_nr) || isemptyn(proc_nr))
! 	return EINVAL;
! 
!   rp = proc_addr(proc_nr);
!   priv = priv(rp);
!   if(!priv) return ENOENT;
!   sigaddset(&priv->s_sig_pending, sig_nr);
!   mini_notify(proc_addr(SYSTEM), rp->p_endpoint);
! 
!   return OK;
! }
! 
! /*===========================================================================*
!  *				cause_sig				     *
!  *===========================================================================*/
! void cause_sig(proc_nr, sig_nr)
! proc_nr_t proc_nr;		/* process to be signalled */
! int sig_nr;			/* signal to be sent */
! {
! /* A system process wants to send a signal to a process.  Examples are:
!  *  - HARDWARE wanting to cause a SIGSEGV after a CPU exception
!  *  - TTY wanting to cause SIGINT upon getting a DEL
!  *  - FS wanting to cause SIGPIPE for a broken pipe 
!  * Signals are handled by sending a message to the signal manager assigned to
!  * the process. This function handles the signals and makes sure the signal
!  * manager gets them by sending a notification. The process being signaled
!  * is blocked while the signal manager has not finished all signals for it.
!  * Race conditions between calls to this function and the system calls that
!  * process pending kernel signals cannot exist. Signal related functions are
!  * only called when a user process causes a CPU exception and from the kernel 
!  * process level, which runs to completion.
!  */
!   register struct proc *rp, *sig_mgr_rp;
!   endpoint_t sig_mgr;
!   int sig_mgr_proc_nr;
! 
!   /* Lookup signal manager. */
!   rp = proc_addr(proc_nr);
!   sig_mgr = priv(rp)->s_sig_mgr;
!   if(sig_mgr == SELF) sig_mgr = rp->p_endpoint;
! 
!   /* If the target is the signal manager of itself, send the signal directly. */
!   if(rp->p_endpoint == sig_mgr) {
!        if(SIGS_IS_LETHAL(sig_nr)) {
!            /* If the signal is lethal, see if a backup signal manager exists. */
!            sig_mgr = priv(rp)->s_bak_sig_mgr;
!            if(sig_mgr != NONE && isokendpt(sig_mgr, &sig_mgr_proc_nr)) {
!                priv(rp)->s_sig_mgr = sig_mgr;
!                priv(rp)->s_bak_sig_mgr = NONE;
!                sig_mgr_rp = proc_addr(sig_mgr_proc_nr);
!                RTS_UNSET(sig_mgr_rp, RTS_NO_PRIV);
!                cause_sig(proc_nr, sig_nr); /* try again with the new sig mgr. */
!                return;
!            }
!            /* We are out of luck. Time to panic. */
!            proc_stacktrace(rp);
!            panic("cause_sig: sig manager %d gets lethal signal %d for itself",
! 	   	rp->p_endpoint, sig_nr);
!        }
!        sigaddset(&priv(rp)->s_sig_pending, sig_nr);
!        if(OK != send_sig(rp->p_endpoint, SIGKSIGSM))
!        	panic("send_sig failed");
!        return;
!   }
! 
!   /* Check if the signal is already pending. Process it otherwise. */
!   if (! sigismember(&rp->p_pending, sig_nr)) {
!       sigaddset(&rp->p_pending, sig_nr);
!       if (! (RTS_ISSET(rp, RTS_SIGNALED))) {		/* other pending */
! 	  RTS_SET(rp, RTS_SIGNALED | RTS_SIG_PENDING);
!           if(OK != send_sig(sig_mgr, SIGKSIG))
! 	  	panic("send_sig failed");
!       }
!   }
! }
! 
! /*===========================================================================*
!  *				sig_delay_done				     *
!  *===========================================================================*/
! void sig_delay_done(struct proc *rp)
! {
! /* A process is now known not to send any direct messages.
!  * Tell PM that the stop delay has ended, by sending a signal to the process.
!  * Used for actual signal delivery.
!  */
! 
!   rp->p_misc_flags &= ~MF_SIG_DELAY;
! 
!   cause_sig(proc_nr(rp), SIGSNDELAY);
! }
! 
! /*===========================================================================*
!  *			         clear_ipc				     *
!  *===========================================================================*/
! static void clear_ipc(
!   register struct proc *rc	/* slot of process to clean up */
! )
! {
! /* Clear IPC data for a given process slot. */
!   struct proc **xpp;			/* iterate over caller queue */
! 
!   if (RTS_ISSET(rc, RTS_SENDING)) {
!       int target_proc;
! 
!       okendpt(rc->p_sendto_e, &target_proc);
!       xpp = &proc_addr(target_proc)->p_caller_q; /* destination's queue */
!       while (*xpp) {		/* check entire queue */
!           if (*xpp == rc) {			/* process is on the queue */
!               *xpp = (*xpp)->p_q_link;		/* replace by next process */
! #if DEBUG_ENABLE_IPC_WARNINGS
! 	      printf("endpoint %d / %s removed from queue at %d\n",
! 	          rc->p_endpoint, rc->p_name, rc->p_sendto_e);
! #endif
!               break;				/* can only be queued once */
!           }
!           xpp = &(*xpp)->p_q_link;		/* proceed to next queued */
!       }
!       RTS_UNSET(rc, RTS_SENDING);
!   }
!   RTS_UNSET(rc, RTS_RECEIVING);
! }
! 
! /*===========================================================================*
!  *			         clear_endpoint				     *
!  *===========================================================================*/
! void clear_endpoint(rc)
! register struct proc *rc;		/* slot of process to clean up */
! {
!   if(isemptyp(rc)) panic("clear_proc: empty process: %d",  rc->p_endpoint);
! 
! 
! #if DEBUG_IPC_HOOK
!   hook_ipc_clear(rc);
! #endif
! 
!   /* Make sure that the exiting process is no longer scheduled. */
!   RTS_SET(rc, RTS_NO_ENDPOINT);
!   if (priv(rc)->s_flags & SYS_PROC)
!   {
! 	priv(rc)->s_asynsize= 0;
!   }
! 
!   /* If the process happens to be queued trying to send a
!    * message, then it must be removed from the message queues.
!    */
!   clear_ipc(rc);
! 
!   /* Likewise, if another process was sending or receive a message to or from 
!    * the exiting process, it must be alerted that process no longer is alive.
!    * Check all processes. 
!    */
!   clear_ipc_refs(rc, EDEADSRCDST);
! 
! }
! 
! /*===========================================================================*
!  *			       clear_ipc_refs				     *
!  *===========================================================================*/
! void clear_ipc_refs(rc, caller_ret)
! register struct proc *rc;		/* slot of process to clean up */
! int caller_ret;				/* code to return on callers */
! {
! /* Clear IPC references for a given process slot. */
!   struct proc *rp;			/* iterate over process table */
!   int src_id;
! 
!   /* Tell processes that sent asynchronous messages to 'rc' they are not
!    * going to be delivered */
!   while ((src_id = has_pending_asend(rc, ANY)) != NULL_PRIV_ID) 
!       cancel_async(proc_addr(id_to_nr(src_id)), rc);
! 
!   for (rp = BEG_PROC_ADDR; rp < END_PROC_ADDR; rp++) {
!       if(isemptyp(rp))
! 	continue;
! 
!       /* Unset pending notification bits. */
!       unset_sys_bit(priv(rp)->s_notify_pending, priv(rc)->s_id);
! 
!       /* Unset pending asynchronous messages */
!       unset_sys_bit(priv(rp)->s_asyn_pending, priv(rc)->s_id);
! 
!       /* Check if process depends on given process. */
!       if (P_BLOCKEDON(rp) == rc->p_endpoint) {
!           rp->p_reg.retreg = caller_ret;	/* return requested code */
! 	  clear_ipc(rp);
!       }
!   }
! }
! 
! /*===========================================================================*
!  *                              kernel_call_resume                           *
!  *===========================================================================*/
! void kernel_call_resume(struct proc *caller)
! {
! 	int result;
! 
! 	assert(!RTS_ISSET(caller, RTS_SLOT_FREE));
! 	assert(!RTS_ISSET(caller, RTS_VMREQUEST));
! 
! 	assert(caller->p_vmrequest.saved.reqmsg.m_source == caller->p_endpoint);
! 
! 	/*
! 	printf("KERNEL_CALL restart from %s / %d rts 0x%08x misc 0x%08x\n",
! 			caller->p_name, caller->p_endpoint,
! 			caller->p_rts_flags, caller->p_misc_flags);
! 	 */
! 
! 	/* re-execute the kernel call, with MF_KCALL_RESUME still set so
! 	 * the call knows this is a retry.
! 	 */
! 	result = kernel_call_dispatch(caller, &caller->p_vmrequest.saved.reqmsg);
! 	/*
! 	 * we are resuming the kernel call so we have to remove this flag so it
! 	 * can be set again
! 	 */
! 	caller->p_misc_flags &= ~MF_KCALL_RESUME;
! 	kernel_call_finish(caller, &caller->p_vmrequest.saved.reqmsg, result);
! }
! 
! /*===========================================================================*
!  *                               sched_proc                                  *
!  *===========================================================================*/
! int sched_proc(struct proc *p,
! 			int priority,
! 			int quantum,
! 			int cpu)
! {
! 	/* Make sure the values given are within the allowed range.*/
! 	if ((priority < TASK_Q && priority != -1) || priority > NR_SCHED_QUEUES)
! 		return(EINVAL);
! 
! 	if (quantum < 1 && quantum != -1)
! 		return(EINVAL);
! 
! #ifdef CONFIG_SMP
! 	if ((cpu < 0 && cpu != -1) || (cpu > 0 && (unsigned) cpu >= ncpus))
! 		return(EINVAL);
! 	if (cpu != -1 && !(cpu_is_ready(cpu)))
! 		return EBADCPU;
! #endif
! 
! 	/* In some cases, we might be rescheduling a runnable process. In such
! 	 * a case (i.e. if we are updating the priority) we set the NO_QUANTUM
! 	 * flag before the generic unset to dequeue/enqueue the process
! 	 */
! 
! 	/* FIXME this preempts the process, do we really want to do that ?*/
! 
! 	/* FIXME this is a problem for SMP if the processes currently runs on a
! 	 * different CPU */
! 	if (proc_is_runnable(p)) {
! #ifdef CONFIG_SMP
! 		if (p->p_cpu != cpuid && cpu != -1 && cpu != p->p_cpu) {
! 			smp_schedule_migrate_proc(p, cpu);
! 		}
! #endif
! 
! 		RTS_SET(p, RTS_NO_QUANTUM);
! 	}
! 
! 	if (proc_is_runnable(p))
! 		RTS_SET(p, RTS_NO_QUANTUM);
! 
! 	if (priority != -1)
! 		p->p_priority = priority;
! 
!     //new added, 2016.12.3
!     if (p->p_deadline.tmr_exp_time > 0 )//if proc has deadline, then put it into highest user queue
!         p->p_priority = 0;//highest user queue
! 
! 	if (quantum != -1) {
! 		p->p_quantum_size_ms = quantum;
! 		p->p_cpu_time_left = ms_2_cpu_time(quantum);
! 	}
! #ifdef CONFIG_SMP
! 	if (cpu != -1)
! 		p->p_cpu = cpu;
! #endif
! 
! 	/* Clear the scheduling bit and enqueue the process */
! 	RTS_UNSET(p, RTS_NO_QUANTUM);
! 
! 	return OK;
! }
! 
diff -crN usr_orig/src/kernel/system.h EDF/src/kernel/system.h
*** usr_orig/src/kernel/system.h	2013-02-15 19:18:13.000000000 +0800
--- EDF/src/kernel/system.h	2016-12-08 00:17:19.607910742 +0800
***************
*** 1,211 ****
! /* Function prototypes for the system library.  The prototypes in this file 
!  * are undefined to NULL if the kernel call is not enabled in config.h.
!  * The implementation is contained in src/kernel/system/.  
!  *
!  * The system library allows to access system services by doing a kernel call.
!  * System calls are transformed into request messages to the SYS task that is 
!  * responsible for handling the call. By convention, sys_call() is transformed 
!  * into a message with type SYS_CALL that is handled in a function do_call(). 
!  * 
!  * Changes:
!  *   Mar 01, 2010   SYS_CLEAR and SYS_EXIT split (Cristiano Giuffrida)
!  *   Jul 30, 2005   created SYS_INT86 to support BIOS driver  (Philip Homburg) 
!  *   Jul 13, 2005   created SYS_PRIVCTL to manage services  (Jorrit N. Herder) 
!  *   Jul 09, 2005   updated SYS_KILL to signal services  (Jorrit N. Herder) 
!  *   Jun 21, 2005   created SYS_NICE for nice(2) kernel call  (Ben J. Gras)
!  *   Jun 21, 2005   created SYS_MEMSET to speed up exec(2)  (Ben J. Gras)
!  *   Jan 20, 2005   updated SYS_COPY for virtual_copy()  (Jorrit N. Herder)
!  *   Oct 24, 2004   created SYS_GETKSIG to support PM  (Jorrit N. Herder) 
!  *   Oct 10, 2004   created handler for unused calls  (Jorrit N. Herder) 
!  *   Sep 09, 2004   updated SYS_EXIT to let services exit  (Jorrit N. Herder) 
!  *   Aug 25, 2004   rewrote SYS_SETALARM to clean up code  (Jorrit N. Herder)
!  *   Jul 13, 2004   created SYS_SEGCTL to support drivers  (Jorrit N. Herder) 
!  *   May 24, 2004   created SYS_SDEVIO to support drivers  (Jorrit N. Herder) 
!  *   May 24, 2004   created SYS_GETINFO to retrieve info  (Jorrit N. Herder) 
!  *   Apr 18, 2004   created SYS_VDEVIO to support drivers  (Jorrit N. Herder) 
!  *   Feb 24, 2004   created SYS_IRQCTL to support drivers  (Jorrit N. Herder) 
!  *   Feb 02, 2004   created SYS_DEVIO to support drivers  (Jorrit N. Herder) 
!  */ 
! 
! #ifndef SYSTEM_H
! #define SYSTEM_H
! 
! #include "kernel/kernel.h"
! 
! int do_exec(struct proc * caller, message *m_ptr);
! #if ! USE_EXEC
! #define do_exec NULL
! #endif
! 
! int do_fork(struct proc * caller, message *m_ptr);
! #if ! USE_FORK
! #define do_fork NULL
! #endif
! 
! int do_clear(struct proc * caller, message *m_ptr);
! #if ! USE_CLEAR
! #define do_clear NULL
! #endif
! 
! int do_trace(struct proc * caller, message *m_ptr);
! #if ! USE_TRACE
! #define do_trace NULL
! #endif
! 
! int do_runctl(struct proc * caller, message *m_ptr);
! #if ! USE_RUNCTL
! #define do_runctl NULL
! #endif
! 
! int do_update(struct proc * caller, message *m_ptr);
! #if ! USE_UPDATE
! #define do_update NULL
! #endif
! 
! int do_exit(struct proc * caller, message *m_ptr);
! #if ! USE_EXIT
! #define do_exit NULL
! #endif
! 
! int do_copy(struct proc * caller, message *m_ptr);
! #define do_vircopy 	do_copy
! #if ! (USE_VIRCOPY || USE_PHYSCOPY)
! #define do_copy NULL
! #endif
! 
! int do_umap(struct proc * caller, message *m_ptr);
! #if ! USE_UMAP
! #define do_umap NULL
! #endif
! 
! int do_umap_remote(struct proc * caller, message *m_ptr);
! #if ! USE_UMAP_REMOTE
! #define do_umap_remote NULL
! #endif
! 
! int do_vumap(struct proc * caller, message *m_ptr);
! #if ! USE_VUMAP
! #define do_vumap NULL
! #endif
! 
! int do_memset(struct proc * caller, message *m_ptr);
! #if ! USE_MEMSET
! #define do_memset NULL
! #endif
! 
! int do_abort(struct proc * caller, message *m_ptr);
! #if ! USE_ABORT
! #define do_abort NULL
! #endif
! 
! int do_getinfo(struct proc * caller, message *m_ptr);
! #if ! USE_GETINFO
! #define do_getinfo NULL
! #endif
! 
! int do_privctl(struct proc * caller, message *m_ptr);
! #if ! USE_PRIVCTL
! #define do_privctl NULL
! #endif
! 
! int do_irqctl(struct proc * caller, message *m_ptr);
! #if ! USE_IRQCTL
! #define do_irqctl NULL
! #endif
! 
! int do_devio(struct proc * caller, message *m_ptr);
! #if ! USE_DEVIO
! #define do_devio NULL
! #endif
! 
! int do_vdevio(struct proc * caller, message *m_ptr);
! #if ! USE_VDEVIO
! #define do_vdevio NULL
! #endif
! 
! int do_sdevio(struct proc * caller, message *m_ptr);
! #if ! USE_SDEVIO
! #define do_sdevio NULL
! #endif
! 
! int do_kill(struct proc * caller, message *m_ptr);
! #if ! USE_KILL
! #define do_kill NULL
! #endif
! 
! int do_getksig(struct proc * caller, message *m_ptr);
! #if ! USE_GETKSIG
! #define do_getksig NULL
! #endif
! 
! int do_endksig(struct proc * caller, message *m_ptr);
! #if ! USE_ENDKSIG
! #define do_endksig NULL
! #endif
! 
! int do_sigsend(struct proc * caller, message *m_ptr);
! #if ! USE_SIGSEND
! #define do_sigsend NULL
! #endif
! 
! int do_sigreturn(struct proc * caller, message *m_ptr);
! #if ! USE_SIGRETURN
! #define do_sigreturn NULL
! #endif
! 
! int do_times(struct proc * caller, message *m_ptr);
! #if ! USE_TIMES
! #define do_times NULL
! #endif
! 
! int do_setalarm(struct proc * caller, message *m_ptr);
! #if ! USE_SETALARM
! #define do_setalarm NULL
! #endif
! 
! int do_stime(struct proc * caller, message *m_ptr);
! 
! int do_vtimer(struct proc * caller, message *m_ptr);
! #if ! USE_VTIMER
! #define do_vtimer NULL
! #endif
! 
! int do_safecopy_to(struct proc * caller, message *m_ptr);
! int do_safecopy_from(struct proc * caller, message *m_ptr);
! int do_vsafecopy(struct proc * caller, message *m_ptr);
! int do_iopenable(struct proc * caller, message *m_ptr);
! int do_vmctl(struct proc * caller, message *m_ptr);
! int do_setgrant(struct proc * caller, message *m_ptr);
! int do_readbios(struct proc * caller, message *m_ptr);
! 
! int do_safememset(struct proc * caller, message *m_ptr);
! 
! int do_sprofile(struct proc * caller, message *m_ptr);
! #if ! SPROFILE
! #define do_sprofile NULL
! #endif
! 
! int do_cprofile(struct proc * caller, message *m_ptr);
! int do_profbuf(struct proc * caller, message *m_ptr);
! #if ! CPROFILE
! #define do_cprofile NULL
! #define do_profbuf NULL
! #endif
! 
! int do_getmcontext(struct proc * caller, message *m_ptr);
! int do_setmcontext(struct proc * caller, message *m_ptr);
! #if ! USE_MCONTEXT
! #define do_getmcontext NULL
! #define do_setmcontext NULL
! #endif
! 
! int do_schedule(struct proc * caller, message *m_ptr);
! int do_schedctl(struct proc * caller, message *m_ptr);
! 
! int do_statectl(struct proc * caller, message *m_ptr);
! #if ! USE_STATECTL
! #define do_statectl NULL
! #endif
! 
! #endif	/* SYSTEM_H */
! 
--- 1,216 ----
! /* Function prototypes for the system library.  The prototypes in this file 
!  * are undefined to NULL if the kernel call is not enabled in config.h.
!  * The implementation is contained in src/kernel/system/.  
!  *
!  * The system library allows to access system services by doing a kernel call.
!  * System calls are transformed into request messages to the SYS task that is 
!  * responsible for handling the call. By convention, sys_call() is transformed 
!  * into a message with type SYS_CALL that is handled in a function do_call(). 
!  * 
!  * Changes:
!  *   Mar 01, 2010   SYS_CLEAR and SYS_EXIT split (Cristiano Giuffrida)
!  *   Jul 30, 2005   created SYS_INT86 to support BIOS driver  (Philip Homburg) 
!  *   Jul 13, 2005   created SYS_PRIVCTL to manage services  (Jorrit N. Herder) 
!  *   Jul 09, 2005   updated SYS_KILL to signal services  (Jorrit N. Herder) 
!  *   Jun 21, 2005   created SYS_NICE for nice(2) kernel call  (Ben J. Gras)
!  *   Jun 21, 2005   created SYS_MEMSET to speed up exec(2)  (Ben J. Gras)
!  *   Jan 20, 2005   updated SYS_COPY for virtual_copy()  (Jorrit N. Herder)
!  *   Oct 24, 2004   created SYS_GETKSIG to support PM  (Jorrit N. Herder) 
!  *   Oct 10, 2004   created handler for unused calls  (Jorrit N. Herder) 
!  *   Sep 09, 2004   updated SYS_EXIT to let services exit  (Jorrit N. Herder) 
!  *   Aug 25, 2004   rewrote SYS_SETALARM to clean up code  (Jorrit N. Herder)
!  *   Jul 13, 2004   created SYS_SEGCTL to support drivers  (Jorrit N. Herder) 
!  *   May 24, 2004   created SYS_SDEVIO to support drivers  (Jorrit N. Herder) 
!  *   May 24, 2004   created SYS_GETINFO to retrieve info  (Jorrit N. Herder) 
!  *   Apr 18, 2004   created SYS_VDEVIO to support drivers  (Jorrit N. Herder) 
!  *   Feb 24, 2004   created SYS_IRQCTL to support drivers  (Jorrit N. Herder) 
!  *   Feb 02, 2004   created SYS_DEVIO to support drivers  (Jorrit N. Herder) 
!  */ 
! 
! #ifndef SYSTEM_H
! #define SYSTEM_H
! 
! #include "kernel/kernel.h"
! 
! int do_chrealtime(struct proc * caller, message *m_ptr);
! #if ! USE_CHREALTIME
! #define do_chrealtime NULL
! #endif
! 
! int do_exec(struct proc * caller, message *m_ptr);
! #if ! USE_EXEC
! #define do_exec NULL
! #endif
! 
! int do_fork(struct proc * caller, message *m_ptr);
! #if ! USE_FORK
! #define do_fork NULL
! #endif
! 
! int do_clear(struct proc * caller, message *m_ptr);
! #if ! USE_CLEAR
! #define do_clear NULL
! #endif
! 
! int do_trace(struct proc * caller, message *m_ptr);
! #if ! USE_TRACE
! #define do_trace NULL
! #endif
! 
! int do_runctl(struct proc * caller, message *m_ptr);
! #if ! USE_RUNCTL
! #define do_runctl NULL
! #endif
! 
! int do_update(struct proc * caller, message *m_ptr);
! #if ! USE_UPDATE
! #define do_update NULL
! #endif
! 
! int do_exit(struct proc * caller, message *m_ptr);
! #if ! USE_EXIT
! #define do_exit NULL
! #endif
! 
! int do_copy(struct proc * caller, message *m_ptr);
! #define do_vircopy 	do_copy
! #if ! (USE_VIRCOPY || USE_PHYSCOPY)
! #define do_copy NULL
! #endif
! 
! int do_umap(struct proc * caller, message *m_ptr);
! #if ! USE_UMAP
! #define do_umap NULL
! #endif
! 
! int do_umap_remote(struct proc * caller, message *m_ptr);
! #if ! USE_UMAP_REMOTE
! #define do_umap_remote NULL
! #endif
! 
! int do_vumap(struct proc * caller, message *m_ptr);
! #if ! USE_VUMAP
! #define do_vumap NULL
! #endif
! 
! int do_memset(struct proc * caller, message *m_ptr);
! #if ! USE_MEMSET
! #define do_memset NULL
! #endif
! 
! int do_abort(struct proc * caller, message *m_ptr);
! #if ! USE_ABORT
! #define do_abort NULL
! #endif
! 
! int do_getinfo(struct proc * caller, message *m_ptr);
! #if ! USE_GETINFO
! #define do_getinfo NULL
! #endif
! 
! int do_privctl(struct proc * caller, message *m_ptr);
! #if ! USE_PRIVCTL
! #define do_privctl NULL
! #endif
! 
! int do_irqctl(struct proc * caller, message *m_ptr);
! #if ! USE_IRQCTL
! #define do_irqctl NULL
! #endif
! 
! int do_devio(struct proc * caller, message *m_ptr);
! #if ! USE_DEVIO
! #define do_devio NULL
! #endif
! 
! int do_vdevio(struct proc * caller, message *m_ptr);
! #if ! USE_VDEVIO
! #define do_vdevio NULL
! #endif
! 
! int do_sdevio(struct proc * caller, message *m_ptr);
! #if ! USE_SDEVIO
! #define do_sdevio NULL
! #endif
! 
! int do_kill(struct proc * caller, message *m_ptr);
! #if ! USE_KILL
! #define do_kill NULL
! #endif
! 
! int do_getksig(struct proc * caller, message *m_ptr);
! #if ! USE_GETKSIG
! #define do_getksig NULL
! #endif
! 
! int do_endksig(struct proc * caller, message *m_ptr);
! #if ! USE_ENDKSIG
! #define do_endksig NULL
! #endif
! 
! int do_sigsend(struct proc * caller, message *m_ptr);
! #if ! USE_SIGSEND
! #define do_sigsend NULL
! #endif
! 
! int do_sigreturn(struct proc * caller, message *m_ptr);
! #if ! USE_SIGRETURN
! #define do_sigreturn NULL
! #endif
! 
! int do_times(struct proc * caller, message *m_ptr);
! #if ! USE_TIMES
! #define do_times NULL
! #endif
! 
! int do_setalarm(struct proc * caller, message *m_ptr);
! #if ! USE_SETALARM
! #define do_setalarm NULL
! #endif
! 
! int do_stime(struct proc * caller, message *m_ptr);
! 
! int do_vtimer(struct proc * caller, message *m_ptr);
! #if ! USE_VTIMER
! #define do_vtimer NULL
! #endif
! 
! int do_safecopy_to(struct proc * caller, message *m_ptr);
! int do_safecopy_from(struct proc * caller, message *m_ptr);
! int do_vsafecopy(struct proc * caller, message *m_ptr);
! int do_iopenable(struct proc * caller, message *m_ptr);
! int do_vmctl(struct proc * caller, message *m_ptr);
! int do_setgrant(struct proc * caller, message *m_ptr);
! int do_readbios(struct proc * caller, message *m_ptr);
! 
! int do_safememset(struct proc * caller, message *m_ptr);
! 
! int do_sprofile(struct proc * caller, message *m_ptr);
! #if ! SPROFILE
! #define do_sprofile NULL
! #endif
! 
! int do_cprofile(struct proc * caller, message *m_ptr);
! int do_profbuf(struct proc * caller, message *m_ptr);
! #if ! CPROFILE
! #define do_cprofile NULL
! #define do_profbuf NULL
! #endif
! 
! int do_getmcontext(struct proc * caller, message *m_ptr);
! int do_setmcontext(struct proc * caller, message *m_ptr);
! #if ! USE_MCONTEXT
! #define do_getmcontext NULL
! #define do_setmcontext NULL
! #endif
! 
! int do_schedule(struct proc * caller, message *m_ptr);
! int do_schedctl(struct proc * caller, message *m_ptr);
! 
! int do_statectl(struct proc * caller, message *m_ptr);
! #if ! USE_STATECTL
! #define do_statectl NULL
! #endif
! 
! #endif	/* SYSTEM_H */
! 
diff -crN usr_orig/src/lib/libc/sys-minix/chrealtime.c EDF/src/lib/libc/sys-minix/chrealtime.c
*** usr_orig/src/lib/libc/sys-minix/chrealtime.c	1970-01-01 08:00:00.000000000 +0800
--- EDF/src/lib/libc/sys-minix/chrealtime.c	2016-12-08 00:17:19.731910739 +0800
***************
*** 0 ****
--- 1,12 ----
+ #include <lib.h>
+ #include <unistd.h>
+ #include <stdio.h>
+ 
+ int chrealtime( long deadline)
+ {
+ 	printf("chrealtime in libc is called \n");
+       message m;
+       m.m2_l1 = deadline;
+       alarm((unsigned int) deadline);
+       return(_syscall(PM_PROC_NR, CHREALTIME, &m));
+ }
diff -crN usr_orig/src/lib/libc/sys-minix/Makefile.inc EDF/src/lib/libc/sys-minix/Makefile.inc
*** usr_orig/src/lib/libc/sys-minix/Makefile.inc	2013-02-15 19:18:14.000000000 +0800
--- EDF/src/lib/libc/sys-minix/Makefile.inc	2016-12-08 00:17:19.731910739 +0800
***************
*** 16,22 ****
  	vectorio.c shutdown.c sigaction.c sigpending.c sigreturn.c sigsuspend.c\
  	sigprocmask.c socket.c socketpair.c stat.c statvfs.c symlink.c \
  	sync.c syscall.c sysuname.c truncate.c umask.c unlink.c write.c \
! 	_exit.c _ucontext.c environ.c __getcwd.c vfork.c sizeup.c init.c
  
  # Minix specific syscalls.
  SRCS+= cprofile.c lseek64.c sprofile.c _mcontext.c
--- 16,23 ----
  	vectorio.c shutdown.c sigaction.c sigpending.c sigreturn.c sigsuspend.c\
  	sigprocmask.c socket.c socketpair.c stat.c statvfs.c symlink.c \
  	sync.c syscall.c sysuname.c truncate.c umask.c unlink.c write.c \
! 	_exit.c _ucontext.c environ.c __getcwd.c vfork.c sizeup.c init.c \
! 	chrealtime.c
  
  # Minix specific syscalls.
  SRCS+= cprofile.c lseek64.c sprofile.c _mcontext.c
diff -crN usr_orig/src/lib/libsys/Makefile EDF/src/lib/libsys/Makefile
*** usr_orig/src/lib/libsys/Makefile	2013-02-15 19:18:14.000000000 +0800
--- EDF/src/lib/libsys/Makefile	2016-12-08 00:17:19.683910741 +0800
***************
*** 86,92 ****
  	vm_umap.c \
  	vm_yield_get_block.c \
  	vm_procctl.c \
! 	vprintf.c
  
  .if ${MKPCI} != "no"
  SRCS+=	pci_attr_r16.c \
--- 86,93 ----
  	vm_umap.c \
  	vm_yield_get_block.c \
  	vm_procctl.c \
! 	vprintf.c \
! 	sys_chrealtime.c
  
  .if ${MKPCI} != "no"
  SRCS+=	pci_attr_r16.c \
diff -crN usr_orig/src/lib/libsys/sys_chrealtime.c EDF/src/lib/libsys/sys_chrealtime.c
*** usr_orig/src/lib/libsys/sys_chrealtime.c	1970-01-01 08:00:00.000000000 +0800
--- EDF/src/lib/libsys/sys_chrealtime.c	2016-12-08 00:17:19.683910741 +0800
***************
*** 0 ****
--- 1,11 ----
+ #include "syslib.h"
+ #include <stdio.h>
+ 
+ int sys_chrealtime(endpoint_t proc_ep,long deadline)
+ {
+ 	printf("sys_chrealtime is called in libsys\n");
+     message m;
+     m.m2_i1 = proc_ep;
+     m.m2_l1 = deadline;
+     return(_kernel_call(SYS_CHREALTIME, &m));
+ }
diff -crN usr_orig/src/servers/pm/misc.c EDF/src/servers/pm/misc.c
*** usr_orig/src/servers/pm/misc.c	2013-02-15 19:18:14.000000000 +0800
--- EDF/src/servers/pm/misc.c	2016-12-08 00:17:19.699910740 +0800
***************
*** 1,497 ****
! /* Miscellaneous system calls.				Author: Kees J. Bot
!  *								31 Mar 2000
!  * The entry points into this file are:
!  *   do_reboot: kill all processes, then reboot system
!  *   do_getsysinfo: request copy of PM data structure  (Jorrit N. Herder)
!  *   do_getprocnr: lookup process slot number  (Jorrit N. Herder)
!  *   do_getepinfo: get the pid/uid/gid of a process given its endpoint
!  *   do_getsetpriority: get/set process priority
!  *   do_svrctl: process manager control
!  */
! 
! #define brk _brk
! 
! #include "pm.h"
! #include <minix/callnr.h>
! #include <signal.h>
! #include <sys/svrctl.h>
! #include <sys/resource.h>
! #include <sys/utsname.h>
! #include <minix/com.h>
! #include <minix/config.h>
! #include <minix/sysinfo.h>
! #include <minix/type.h>
! #include <minix/vm.h>
! #include <string.h>
! #include <machine/archtypes.h>
! #include <lib.h>
! #include <assert.h>
! #include "mproc.h"
! #include "param.h"
! #include "kernel/proc.h"
! 
! struct utsname uts_val = {
!   "Minix",		/* system name */
!   "noname",		/* node/network name */
!   OS_RELEASE,		/* O.S. release (e.g. 1.5) */
!   OS_VERSION,		/* O.S. version (e.g. 10) */
!   "xyzzy",		/* machine (cpu) type (filled in later) */
! #if defined(__i386__)
!   "i386",		/* architecture */
! #elif defined(__arm__)
!   "arm",		/* architecture */
! #else
! #error			/* oops, no 'uname -mk' */
! #endif
! };
! 
! static char *uts_tbl[] = {
!   uts_val.arch,
!   NULL,			/* No kernel architecture */
!   uts_val.machine,
!   NULL,			/* No hostname */
!   uts_val.nodename,
!   uts_val.release,
!   uts_val.version,
!   uts_val.sysname,
!   NULL,			/* No bus */			/* No bus */
! };
! 
! #if ENABLE_SYSCALL_STATS
! unsigned long calls_stats[NCALLS];
! #endif
! 
! /*===========================================================================*
!  *				do_sysuname				     *
!  *===========================================================================*/
! int do_sysuname()
! {
! /* Set or get uname strings. */
! 
!   int r;
!   size_t n;
!   char *string;
! #if 0 /* for updates */
!   char tmp[sizeof(uts_val.nodename)];
!   static short sizes[] = {
! 	0,	/* arch, (0 = read-only) */
! 	0,	/* kernel */
! 	0,	/* machine */
! 	0,	/* sizeof(uts_val.hostname), */
! 	sizeof(uts_val.nodename),
! 	0,	/* release */
! 	0,	/* version */
! 	0,	/* sysname */
!   };
! #endif
! 
!   if ((unsigned) m_in.sysuname_field >= _UTS_MAX) return(EINVAL);
! 
!   string = uts_tbl[m_in.sysuname_field];
!   if (string == NULL)
! 	return EINVAL;	/* Unsupported field */
! 
!   switch (m_in.sysuname_req) {
!   case _UTS_GET:
! 	/* Copy an uname string to the user. */
! 	n = strlen(string) + 1;
! 	if (n > m_in.sysuname_len) n = m_in.sysuname_len;
! 	r = sys_vircopy(SELF, (phys_bytes) string, 
! 		mp->mp_endpoint, (phys_bytes) m_in.sysuname_value,
! 		(phys_bytes) n);
! 	if (r < 0) return(r);
! 	break;
! 
! #if 0	/* no updates yet */
!   case _UTS_SET:
! 	/* Set an uname string, needs root power. */
! 	len = sizes[m_in.sysuname_field];
! 	if (mp->mp_effuid != 0 || len == 0) return(EPERM);
! 	n = len < m_in.sysuname_len ? len : m_in.sysuname_len;
! 	if (n <= 0) return(EINVAL);
! 	r = sys_vircopy(mp->mp_endpoint, (phys_bytes) m_in.sysuname_value,
! 		SELF, (phys_bytes) tmp, (phys_bytes) n);
! 	if (r < 0) return(r);
! 	tmp[n-1] = 0;
! 	strcpy(string, tmp);
! 	break;
! #endif
! 
!   default:
! 	return(EINVAL);
!   }
!   /* Return the number of bytes moved. */
!   return(n);
! }
! 
! 
! /*===========================================================================*
!  *				do_getsysinfo			       	     *
!  *===========================================================================*/
! int do_getsysinfo()
! {
!   vir_bytes src_addr, dst_addr;
!   size_t len;
! 
!   /* This call leaks important information. In the future, requests from
!    * non-system processes should be denied.
!    */
!   if (mp->mp_effuid != 0)
!   {
! 	printf("PM: unauthorized call of do_getsysinfo by proc %d '%s'\n",
! 		mp->mp_endpoint, mp->mp_name);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
!   switch(m_in.SI_WHAT) {
!   case SI_PROC_TAB:			/* copy entire process table */
!         src_addr = (vir_bytes) mproc;
!         len = sizeof(struct mproc) * NR_PROCS;
!         break;
! #if ENABLE_SYSCALL_STATS
!   case SI_CALL_STATS:
!   	src_addr = (vir_bytes) calls_stats;
!   	len = sizeof(calls_stats);
!   	break; 
! #endif
!   default:
!   	return(EINVAL);
!   }
! 
!   if (len != m_in.SI_SIZE)
! 	return(EINVAL);
! 
!   dst_addr = (vir_bytes) m_in.SI_WHERE;
!   return sys_datacopy(SELF, src_addr, who_e, dst_addr, len);
! }
! 
! /*===========================================================================*
!  *				do_getprocnr			             *
!  *===========================================================================*/
! int do_getprocnr()
! {
!   register struct mproc *rmp;
!   static char search_key[PROC_NAME_LEN+1];
!   int key_len;
!   int s;
! 
!   /* This call should be moved to DS. */
!   if (mp->mp_effuid != 0)
!   {
! 	/* For now, allow non-root processes to request their own endpoint. */
! 	if (m_in.pid < 0 && m_in.namelen == 0) {
! 		mp->mp_reply.PM_ENDPT = who_e;
! 		mp->mp_reply.PM_PENDPT = NONE;
! 		return OK;
! 	}
! 
! 	printf("PM: unauthorized call of do_getprocnr by proc %d\n",
! 		mp->mp_endpoint);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
! #if 0
!   printf("PM: do_getprocnr(%d) call from endpoint %d, %s\n",
! 	m_in.pid, mp->mp_endpoint, mp->mp_name);
! #endif
! 
!   if (m_in.pid >= 0) {			/* lookup process by pid */
! 	if ((rmp = find_proc(m_in.pid)) != NULL) {
! 		mp->mp_reply.PM_ENDPT = rmp->mp_endpoint;
! #if 0
! 		printf("PM: pid result: %d\n", rmp->mp_endpoint);
! #endif
! 		return(OK);
! 	}
!   	return(ESRCH);			
!   } else if (m_in.namelen > 0) {	/* lookup process by name */
!   	key_len = MIN(m_in.namelen, PROC_NAME_LEN);
!  	if (OK != (s=sys_datacopy(who_e, (vir_bytes) m_in.PMBRK_ADDR, 
!  			SELF, (vir_bytes) search_key, key_len))) 
!  		return(s);
!  	search_key[key_len] = '\0';	/* terminate for safety */
!   	for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 		if (((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE) && 
! 			strncmp(rmp->mp_name, search_key, key_len)==0) {
!   			mp->mp_reply.PM_ENDPT = rmp->mp_endpoint;
!   			return(OK);
! 		} 
! 	}
!   	return(ESRCH);			
!   } else {			/* return own/parent process number */
! #if 0
! 	printf("PM: endpt result: %d\n", mp->mp_reply.PM_ENDPT);
! #endif
!   	mp->mp_reply.PM_ENDPT = who_e;
! 	mp->mp_reply.PM_PENDPT = mproc[mp->mp_parent].mp_endpoint;
!   }
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				do_getepinfo			             *
!  *===========================================================================*/
! int do_getepinfo()
! {
!   register struct mproc *rmp;
!   endpoint_t ep;
! 
!   ep = m_in.PM_ENDPT;
! 
!   for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 	if ((rmp->mp_flags & IN_USE) && (rmp->mp_endpoint == ep)) {
! 		mp->mp_reply.reply_res2 = rmp->mp_effuid;
! 		mp->mp_reply.reply_res3 = rmp->mp_effgid;
! 		return(rmp->mp_pid);
! 	}
!   }
! 
!   /* Process not found */
!   return(ESRCH);
! }
! 
! /*===========================================================================*
!  *				do_getepinfo_o			             *
!  *===========================================================================*/
! int do_getepinfo_o()
! {
!   register struct mproc *rmp;
!   endpoint_t ep;
! 
!   /* This call should be moved to DS. */
!   if (mp->mp_effuid != 0) {
! 	printf("PM: unauthorized call of do_getepinfo_o by proc %d\n",
! 		mp->mp_endpoint);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
!   ep = m_in.PM_ENDPT;
! 
!   for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 	if ((rmp->mp_flags & IN_USE) && (rmp->mp_endpoint == ep)) {
! 		mp->mp_reply.reply_res2 = (short) rmp->mp_effuid;
! 		mp->mp_reply.reply_res3 = (char) rmp->mp_effgid;
! 		return(rmp->mp_pid);
! 	}
!   }
! 
!   /* Process not found */
!   return(ESRCH);
! }
! 
! /*===========================================================================*
!  *				do_reboot				     *
!  *===========================================================================*/
! int do_reboot()
! {
!   message m;
! 
!   /* Check permission to abort the system. */
!   if (mp->mp_effuid != SUPER_USER) return(EPERM);
! 
!   /* See how the system should be aborted. */
!   abort_flag = (unsigned) m_in.reboot_flag;
!   if (abort_flag >= RBT_INVALID) return(EINVAL); 
! 
!   /* Order matters here. When VFS is told to reboot, it exits all its
!    * processes, and then would be confused if they're exited again by
!    * SIGKILL. So first kill, then reboot. 
!    */
! 
!   check_sig(-1, SIGKILL, FALSE /* ksig*/); /* kill all users except init */
!   sys_stop(INIT_PROC_NR);		   /* stop init, but keep it around */
! 
!   /* Tell VFS to reboot */
!   m.m_type = PM_REBOOT;
! 
!   tell_vfs(&mproc[VFS_PROC_NR], &m);
! 
!   return(SUSPEND);			/* don't reply to caller */
! }
! 
! /*===========================================================================*
!  *				do_getsetpriority			     *
!  *===========================================================================*/
! int do_getsetpriority()
! {
! 	int r, arg_which, arg_who, arg_pri;
! 	struct mproc *rmp;
! 
! 	arg_which = m_in.m1_i1;
! 	arg_who = m_in.m1_i2;
! 	arg_pri = m_in.m1_i3;	/* for SETPRIORITY */
! 
! 	/* Code common to GETPRIORITY and SETPRIORITY. */
! 
! 	/* Only support PRIO_PROCESS for now. */
! 	if (arg_which != PRIO_PROCESS)
! 		return(EINVAL);
! 
! 	if (arg_who == 0)
! 		rmp = mp;
! 	else
! 		if ((rmp = find_proc(arg_who)) == NULL)
! 			return(ESRCH);
! 
! 	if (mp->mp_effuid != SUPER_USER &&
! 	   mp->mp_effuid != rmp->mp_effuid && mp->mp_effuid != rmp->mp_realuid)
! 		return EPERM;
! 
! 	/* If GET, that's it. */
! 	if (call_nr == GETPRIORITY) {
! 		return(rmp->mp_nice - PRIO_MIN);
! 	}
! 
! 	/* Only root is allowed to reduce the nice level. */
! 	if (rmp->mp_nice > arg_pri && mp->mp_effuid != SUPER_USER)
! 		return(EACCES);
! 	
! 	/* We're SET, and it's allowed.
! 	 *
! 	 * The value passed in is currently between PRIO_MIN and PRIO_MAX.
! 	 * We have to scale this between MIN_USER_Q and MAX_USER_Q to match
! 	 * the kernel's scheduling queues.
! 	 */
! 
! 	if ((r = sched_nice(rmp, arg_pri)) != OK) {
! 		return r;
! 	}
! 
! 	rmp->mp_nice = arg_pri;
! 	return(OK);
! }
! 
! /*===========================================================================*
!  *				do_svrctl				     *
!  *===========================================================================*/
! int do_svrctl()
! {
!   int s, req;
!   vir_bytes ptr;
! #define MAX_LOCAL_PARAMS 2
!   static struct {
!   	char name[30];
!   	char value[30];
!   } local_param_overrides[MAX_LOCAL_PARAMS];
!   static int local_params = 0;
! 
!   req = m_in.svrctl_req;
!   ptr = (vir_bytes) m_in.svrctl_argp;
! 
!   /* Is the request indeed for the PM? */
!   if (((req >> 8) & 0xFF) != 'M') return(EINVAL);
! 
!   /* Control operations local to the PM. */
!   switch(req) {
!   case PMSETPARAM:
!   case PMGETPARAM: {
!       struct sysgetenv sysgetenv;
!       char search_key[64];
!       char *val_start;
!       size_t val_len;
!       size_t copy_len;
! 
!       /* Copy sysgetenv structure to PM. */
!       if (sys_datacopy(who_e, ptr, SELF, (vir_bytes) &sysgetenv, 
!               sizeof(sysgetenv)) != OK) return(EFAULT);  
! 
!       /* Set a param override? */
!       if (req == PMSETPARAM) {
!   	if (local_params >= MAX_LOCAL_PARAMS) return ENOSPC;
!   	if (sysgetenv.keylen <= 0
!   	 || sysgetenv.keylen >=
!   	 	 sizeof(local_param_overrides[local_params].name)
!   	 || sysgetenv.vallen <= 0
!   	 || sysgetenv.vallen >=
!   	 	 sizeof(local_param_overrides[local_params].value))
!   		return EINVAL;
!   		
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.key,
!             SELF, (vir_bytes) local_param_overrides[local_params].name,
!                sysgetenv.keylen)) != OK)
!                	return s;
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.val,
!             SELF, (vir_bytes) local_param_overrides[local_params].value,
!               sysgetenv.vallen)) != OK)
!                	return s;
!             local_param_overrides[local_params].name[sysgetenv.keylen] = '\0';
!             local_param_overrides[local_params].value[sysgetenv.vallen] = '\0';
! 
!   	local_params++;
! 
!   	return OK;
!       }
! 
!       if (sysgetenv.keylen == 0) {	/* copy all parameters */
!           val_start = monitor_params;
!           val_len = sizeof(monitor_params);
!       } 
!       else {				/* lookup value for key */
!       	  int p;
!           /* Try to get a copy of the requested key. */
!           if (sysgetenv.keylen > sizeof(search_key)) return(EINVAL);
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.key,
!                   SELF, (vir_bytes) search_key, sysgetenv.keylen)) != OK)
!               return(s);
! 
!           /* Make sure key is null-terminated and lookup value.
!            * First check local overrides.
!            */
!           search_key[sysgetenv.keylen-1]= '\0';
!           for(p = 0; p < local_params; p++) {
!           	if (!strcmp(search_key, local_param_overrides[p].name)) {
!           		val_start = local_param_overrides[p].value;
!           		break;
!           	}
!           }
!           if (p >= local_params && (val_start = find_param(search_key)) == NULL)
!                return(ESRCH);
!           val_len = strlen(val_start) + 1;
!       }
! 
!       /* See if it fits in the client's buffer. */
!       if (val_len > sysgetenv.vallen)
!       	return E2BIG;
! 
!       /* Value found, make the actual copy (as far as possible). */
!       copy_len = MIN(val_len, sysgetenv.vallen); 
!       if ((s=sys_datacopy(SELF, (vir_bytes) val_start, 
!               who_e, (vir_bytes) sysgetenv.val, copy_len)) != OK)
!           return(s);
! 
!       return OK;
!   }
! 
!   default:
! 	return(EINVAL);
!   }
! }
! 
! /*===========================================================================*
!  *				_brk				             *
!  *===========================================================================*/
! 
! extern char *_brksize;
! int brk(brk_addr)
! #ifdef __NBSD_LIBC
! void *brk_addr;
! #else
! char *brk_addr;
! #endif
! {
! 	int r;
! /* PM wants to call brk() itself. */
! 	if((r=vm_brk(PM_PROC_NR, brk_addr)) != OK) {
! #if 0
! 		printf("PM: own brk(%p) failed: vm_brk() returned %d\n",
! 			brk_addr, r);
! #endif
! 		return -1;
! 	}
! 	_brksize = brk_addr;
! 	return 0;
! }
--- 1,508 ----
! /* Miscellaneous system calls.				Author: Kees J. Bot
!  *								31 Mar 2000
!  * The entry points into this file are:
!  *   do_reboot: kill all processes, then reboot system
!  *   do_getsysinfo: request copy of PM data structure  (Jorrit N. Herder)
!  *   do_getprocnr: lookup process slot number  (Jorrit N. Herder)
!  *   do_getepinfo: get the pid/uid/gid of a process given its endpoint
!  *   do_getsetpriority: get/set process priority
!  *   do_svrctl: process manager control
!  */
! 
! #define brk _brk
! 
! #include "pm.h"
! #include <minix/callnr.h>
! #include <signal.h>
! #include <sys/svrctl.h>
! #include <sys/resource.h>
! #include <sys/utsname.h>
! #include <minix/com.h>
! #include <minix/config.h>
! #include <minix/sysinfo.h>
! #include <minix/type.h>
! #include <minix/vm.h>
! #include <string.h>
! #include <machine/archtypes.h>
! #include <lib.h>
! #include <assert.h>
! #include "mproc.h"
! #include "param.h"
! #include "kernel/proc.h"
!  #include <stdio.h>
! 
! struct utsname uts_val = {
!   "Minix",		/* system name */
!   "noname",		/* node/network name */
!   OS_RELEASE,		/* O.S. release (e.g. 1.5) */
!   OS_VERSION,		/* O.S. version (e.g. 10) */
!   "xyzzy",		/* machine (cpu) type (filled in later) */
! #if defined(__i386__)
!   "i386",		/* architecture */
! #elif defined(__arm__)
!   "arm",		/* architecture */
! #else
! #error			/* oops, no 'uname -mk' */
! #endif
! };
! 
! static char *uts_tbl[] = {
!   uts_val.arch,
!   NULL,			/* No kernel architecture */
!   uts_val.machine,
!   NULL,			/* No hostname */
!   uts_val.nodename,
!   uts_val.release,
!   uts_val.version,
!   uts_val.sysname,
!   NULL,			/* No bus */			/* No bus */
! };
! 
! #if ENABLE_SYSCALL_STATS
! unsigned long calls_stats[NCALLS];
! #endif
! 
! /*===========================================================================*
!  *				do_chrealtime				     *
!  *===========================================================================*/
! int do_chrealtime()
! {
!   printf("do_chrealtime in pm is called.\n" );
! 	sys_chrealtime(who_p, m_in.m2_l1);
! 	return OK;
! }
! 
! /*===========================================================================*
!  *				do_sysuname				     *
!  *===========================================================================*/
! int do_sysuname()
! {
! /* Set or get uname strings. */
! 
!   int r;
!   size_t n;
!   char *string;
! #if 0 /* for updates */
!   char tmp[sizeof(uts_val.nodename)];
!   static short sizes[] = {
! 	0,	/* arch, (0 = read-only) */
! 	0,	/* kernel */
! 	0,	/* machine */
! 	0,	/* sizeof(uts_val.hostname), */
! 	sizeof(uts_val.nodename),
! 	0,	/* release */
! 	0,	/* version */
! 	0,	/* sysname */
!   };
! #endif
! 
!   if ((unsigned) m_in.sysuname_field >= _UTS_MAX) return(EINVAL);
! 
!   string = uts_tbl[m_in.sysuname_field];
!   if (string == NULL)
! 	return EINVAL;	/* Unsupported field */
! 
!   switch (m_in.sysuname_req) {
!   case _UTS_GET:
! 	/* Copy an uname string to the user. */
! 	n = strlen(string) + 1;
! 	if (n > m_in.sysuname_len) n = m_in.sysuname_len;
! 	r = sys_vircopy(SELF, (phys_bytes) string, 
! 		mp->mp_endpoint, (phys_bytes) m_in.sysuname_value,
! 		(phys_bytes) n);
! 	if (r < 0) return(r);
! 	break;
! 
! #if 0	/* no updates yet */
!   case _UTS_SET:
! 	/* Set an uname string, needs root power. */
! 	len = sizes[m_in.sysuname_field];
! 	if (mp->mp_effuid != 0 || len == 0) return(EPERM);
! 	n = len < m_in.sysuname_len ? len : m_in.sysuname_len;
! 	if (n <= 0) return(EINVAL);
! 	r = sys_vircopy(mp->mp_endpoint, (phys_bytes) m_in.sysuname_value,
! 		SELF, (phys_bytes) tmp, (phys_bytes) n);
! 	if (r < 0) return(r);
! 	tmp[n-1] = 0;
! 	strcpy(string, tmp);
! 	break;
! #endif
! 
!   default:
! 	return(EINVAL);
!   }
!   /* Return the number of bytes moved. */
!   return(n);
! }
! 
! 
! /*===========================================================================*
!  *				do_getsysinfo			       	     *
!  *===========================================================================*/
! int do_getsysinfo()
! {
!   vir_bytes src_addr, dst_addr;
!   size_t len;
! 
!   /* This call leaks important information. In the future, requests from
!    * non-system processes should be denied.
!    */
!   if (mp->mp_effuid != 0)
!   {
! 	printf("PM: unauthorized call of do_getsysinfo by proc %d '%s'\n",
! 		mp->mp_endpoint, mp->mp_name);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
!   switch(m_in.SI_WHAT) {
!   case SI_PROC_TAB:			/* copy entire process table */
!         src_addr = (vir_bytes) mproc;
!         len = sizeof(struct mproc) * NR_PROCS;
!         break;
! #if ENABLE_SYSCALL_STATS
!   case SI_CALL_STATS:
!   	src_addr = (vir_bytes) calls_stats;
!   	len = sizeof(calls_stats);
!   	break; 
! #endif
!   default:
!   	return(EINVAL);
!   }
! 
!   if (len != m_in.SI_SIZE)
! 	return(EINVAL);
! 
!   dst_addr = (vir_bytes) m_in.SI_WHERE;
!   return sys_datacopy(SELF, src_addr, who_e, dst_addr, len);
! }
! 
! /*===========================================================================*
!  *				do_getprocnr			             *
!  *===========================================================================*/
! int do_getprocnr()
! {
!   register struct mproc *rmp;
!   static char search_key[PROC_NAME_LEN+1];
!   int key_len;
!   int s;
! 
!   /* This call should be moved to DS. */
!   if (mp->mp_effuid != 0)
!   {
! 	/* For now, allow non-root processes to request their own endpoint. */
! 	if (m_in.pid < 0 && m_in.namelen == 0) {
! 		mp->mp_reply.PM_ENDPT = who_e;
! 		mp->mp_reply.PM_PENDPT = NONE;
! 		return OK;
! 	}
! 
! 	printf("PM: unauthorized call of do_getprocnr by proc %d\n",
! 		mp->mp_endpoint);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
! #if 0
!   printf("PM: do_getprocnr(%d) call from endpoint %d, %s\n",
! 	m_in.pid, mp->mp_endpoint, mp->mp_name);
! #endif
! 
!   if (m_in.pid >= 0) {			/* lookup process by pid */
! 	if ((rmp = find_proc(m_in.pid)) != NULL) {
! 		mp->mp_reply.PM_ENDPT = rmp->mp_endpoint;
! #if 0
! 		printf("PM: pid result: %d\n", rmp->mp_endpoint);
! #endif
! 		return(OK);
! 	}
!   	return(ESRCH);			
!   } else if (m_in.namelen > 0) {	/* lookup process by name */
!   	key_len = MIN(m_in.namelen, PROC_NAME_LEN);
!  	if (OK != (s=sys_datacopy(who_e, (vir_bytes) m_in.PMBRK_ADDR, 
!  			SELF, (vir_bytes) search_key, key_len))) 
!  		return(s);
!  	search_key[key_len] = '\0';	/* terminate for safety */
!   	for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 		if (((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE) && 
! 			strncmp(rmp->mp_name, search_key, key_len)==0) {
!   			mp->mp_reply.PM_ENDPT = rmp->mp_endpoint;
!   			return(OK);
! 		} 
! 	}
!   	return(ESRCH);			
!   } else {			/* return own/parent process number */
! #if 0
! 	printf("PM: endpt result: %d\n", mp->mp_reply.PM_ENDPT);
! #endif
!   	mp->mp_reply.PM_ENDPT = who_e;
! 	mp->mp_reply.PM_PENDPT = mproc[mp->mp_parent].mp_endpoint;
!   }
! 
!   return(OK);
! }
! 
! /*===========================================================================*
!  *				do_getepinfo			             *
!  *===========================================================================*/
! int do_getepinfo()
! {
!   register struct mproc *rmp;
!   endpoint_t ep;
! 
!   ep = m_in.PM_ENDPT;
! 
!   for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 	if ((rmp->mp_flags & IN_USE) && (rmp->mp_endpoint == ep)) {
! 		mp->mp_reply.reply_res2 = rmp->mp_effuid;
! 		mp->mp_reply.reply_res3 = rmp->mp_effgid;
! 		return(rmp->mp_pid);
! 	}
!   }
! 
!   /* Process not found */
!   return(ESRCH);
! }
! 
! /*===========================================================================*
!  *				do_getepinfo_o			             *
!  *===========================================================================*/
! int do_getepinfo_o()
! {
!   register struct mproc *rmp;
!   endpoint_t ep;
! 
!   /* This call should be moved to DS. */
!   if (mp->mp_effuid != 0) {
! 	printf("PM: unauthorized call of do_getepinfo_o by proc %d\n",
! 		mp->mp_endpoint);
! 	sys_sysctl_stacktrace(mp->mp_endpoint);
! 	return EPERM;
!   }
! 
!   ep = m_in.PM_ENDPT;
! 
!   for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
! 	if ((rmp->mp_flags & IN_USE) && (rmp->mp_endpoint == ep)) {
! 		mp->mp_reply.reply_res2 = (short) rmp->mp_effuid;
! 		mp->mp_reply.reply_res3 = (char) rmp->mp_effgid;
! 		return(rmp->mp_pid);
! 	}
!   }
! 
!   /* Process not found */
!   return(ESRCH);
! }
! 
! /*===========================================================================*
!  *				do_reboot				     *
!  *===========================================================================*/
! int do_reboot()
! {
!   message m;
! 
!   /* Check permission to abort the system. */
!   if (mp->mp_effuid != SUPER_USER) return(EPERM);
! 
!   /* See how the system should be aborted. */
!   abort_flag = (unsigned) m_in.reboot_flag;
!   if (abort_flag >= RBT_INVALID) return(EINVAL); 
! 
!   /* Order matters here. When VFS is told to reboot, it exits all its
!    * processes, and then would be confused if they're exited again by
!    * SIGKILL. So first kill, then reboot. 
!    */
! 
!   check_sig(-1, SIGKILL, FALSE /* ksig*/); /* kill all users except init */
!   sys_stop(INIT_PROC_NR);		   /* stop init, but keep it around */
! 
!   /* Tell VFS to reboot */
!   m.m_type = PM_REBOOT;
! 
!   tell_vfs(&mproc[VFS_PROC_NR], &m);
! 
!   return(SUSPEND);			/* don't reply to caller */
! }
! 
! /*===========================================================================*
!  *				do_getsetpriority			     *
!  *===========================================================================*/
! int do_getsetpriority()
! {
! 	int r, arg_which, arg_who, arg_pri;
! 	struct mproc *rmp;
! 
! 	arg_which = m_in.m1_i1;
! 	arg_who = m_in.m1_i2;
! 	arg_pri = m_in.m1_i3;	/* for SETPRIORITY */
! 
! 	/* Code common to GETPRIORITY and SETPRIORITY. */
! 
! 	/* Only support PRIO_PROCESS for now. */
! 	if (arg_which != PRIO_PROCESS)
! 		return(EINVAL);
! 
! 	if (arg_who == 0)
! 		rmp = mp;
! 	else
! 		if ((rmp = find_proc(arg_who)) == NULL)
! 			return(ESRCH);
! 
! 	if (mp->mp_effuid != SUPER_USER &&
! 	   mp->mp_effuid != rmp->mp_effuid && mp->mp_effuid != rmp->mp_realuid)
! 		return EPERM;
! 
! 	/* If GET, that's it. */
! 	if (call_nr == GETPRIORITY) {
! 		return(rmp->mp_nice - PRIO_MIN);
! 	}
! 
! 	/* Only root is allowed to reduce the nice level. */
! 	if (rmp->mp_nice > arg_pri && mp->mp_effuid != SUPER_USER)
! 		return(EACCES);
! 	
! 	/* We're SET, and it's allowed.
! 	 *
! 	 * The value passed in is currently between PRIO_MIN and PRIO_MAX.
! 	 * We have to scale this between MIN_USER_Q and MAX_USER_Q to match
! 	 * the kernel's scheduling queues.
! 	 */
! 
! 	if ((r = sched_nice(rmp, arg_pri)) != OK) {
! 		return r;
! 	}
! 
! 	rmp->mp_nice = arg_pri;
! 	return(OK);
! }
! 
! /*===========================================================================*
!  *				do_svrctl				     *
!  *===========================================================================*/
! int do_svrctl()
! {
!   int s, req;
!   vir_bytes ptr;
! #define MAX_LOCAL_PARAMS 2
!   static struct {
!   	char name[30];
!   	char value[30];
!   } local_param_overrides[MAX_LOCAL_PARAMS];
!   static int local_params = 0;
! 
!   req = m_in.svrctl_req;
!   ptr = (vir_bytes) m_in.svrctl_argp;
! 
!   /* Is the request indeed for the PM? */
!   if (((req >> 8) & 0xFF) != 'M') return(EINVAL);
! 
!   /* Control operations local to the PM. */
!   switch(req) {
!   case PMSETPARAM:
!   case PMGETPARAM: {
!       struct sysgetenv sysgetenv;
!       char search_key[64];
!       char *val_start;
!       size_t val_len;
!       size_t copy_len;
! 
!       /* Copy sysgetenv structure to PM. */
!       if (sys_datacopy(who_e, ptr, SELF, (vir_bytes) &sysgetenv, 
!               sizeof(sysgetenv)) != OK) return(EFAULT);  
! 
!       /* Set a param override? */
!       if (req == PMSETPARAM) {
!   	if (local_params >= MAX_LOCAL_PARAMS) return ENOSPC;
!   	if (sysgetenv.keylen <= 0
!   	 || sysgetenv.keylen >=
!   	 	 sizeof(local_param_overrides[local_params].name)
!   	 || sysgetenv.vallen <= 0
!   	 || sysgetenv.vallen >=
!   	 	 sizeof(local_param_overrides[local_params].value))
!   		return EINVAL;
!   		
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.key,
!             SELF, (vir_bytes) local_param_overrides[local_params].name,
!                sysgetenv.keylen)) != OK)
!                	return s;
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.val,
!             SELF, (vir_bytes) local_param_overrides[local_params].value,
!               sysgetenv.vallen)) != OK)
!                	return s;
!             local_param_overrides[local_params].name[sysgetenv.keylen] = '\0';
!             local_param_overrides[local_params].value[sysgetenv.vallen] = '\0';
! 
!   	local_params++;
! 
!   	return OK;
!       }
! 
!       if (sysgetenv.keylen == 0) {	/* copy all parameters */
!           val_start = monitor_params;
!           val_len = sizeof(monitor_params);
!       } 
!       else {				/* lookup value for key */
!       	  int p;
!           /* Try to get a copy of the requested key. */
!           if (sysgetenv.keylen > sizeof(search_key)) return(EINVAL);
!           if ((s = sys_datacopy(who_e, (vir_bytes) sysgetenv.key,
!                   SELF, (vir_bytes) search_key, sysgetenv.keylen)) != OK)
!               return(s);
! 
!           /* Make sure key is null-terminated and lookup value.
!            * First check local overrides.
!            */
!           search_key[sysgetenv.keylen-1]= '\0';
!           for(p = 0; p < local_params; p++) {
!           	if (!strcmp(search_key, local_param_overrides[p].name)) {
!           		val_start = local_param_overrides[p].value;
!           		break;
!           	}
!           }
!           if (p >= local_params && (val_start = find_param(search_key)) == NULL)
!                return(ESRCH);
!           val_len = strlen(val_start) + 1;
!       }
! 
!       /* See if it fits in the client's buffer. */
!       if (val_len > sysgetenv.vallen)
!       	return E2BIG;
! 
!       /* Value found, make the actual copy (as far as possible). */
!       copy_len = MIN(val_len, sysgetenv.vallen); 
!       if ((s=sys_datacopy(SELF, (vir_bytes) val_start, 
!               who_e, (vir_bytes) sysgetenv.val, copy_len)) != OK)
!           return(s);
! 
!       return OK;
!   }
! 
!   default:
! 	return(EINVAL);
!   }
! }
! 
! /*===========================================================================*
!  *				_brk				             *
!  *===========================================================================*/
! 
! extern char *_brksize;
! int brk(brk_addr)
! #ifdef __NBSD_LIBC
! void *brk_addr;
! #else
! char *brk_addr;
! #endif
! {
! 	int r;
! /* PM wants to call brk() itself. */
! 	if((r=vm_brk(PM_PROC_NR, brk_addr)) != OK) {
! #if 0
! 		printf("PM: own brk(%p) failed: vm_brk() returned %d\n",
! 			brk_addr, r);
! #endif
! 		return -1;
! 	}
! 	_brksize = brk_addr;
! 	return 0;
! }
diff -crN usr_orig/src/servers/pm/proto.h EDF/src/servers/pm/proto.h
*** usr_orig/src/servers/pm/proto.h	2013-02-15 19:18:14.000000000 +0800
--- EDF/src/servers/pm/proto.h	2016-12-08 00:17:19.699910740 +0800
***************
*** 1,105 ****
! /* Function prototypes. */
! 
! struct mproc;
! struct stat;
! struct mem_map;
! struct memory;
! 
! #include <timers.h>
! 
! /* alarm.c */
! int do_alarm(void);
! int do_itimer(void);
! void set_alarm(struct mproc *rmp, clock_t ticks);
! void check_vtimer(int proc_nr, int sig);
! 
! /* break.c */
! int do_brk(void);
! 
! /* exec.c */
! int do_exec(void);
! int do_newexec(void);
! int do_execrestart(void);
! void exec_restart(struct mproc *rmp, int result, vir_bytes pc, vir_bytes sp);
! 
! /* forkexit.c */
! int do_fork(void);
! int do_srv_fork(void);
! int do_exit(void);
! void exit_proc(struct mproc *rmp, int exit_status, int dump_core);
! void exit_restart(struct mproc *rmp, int dump_core);
! int do_waitpid(void);
! int wait_test(struct mproc *rmp, struct mproc *child);
! 
! /* getset.c */
! int do_get(void);
! int do_set(void);
! 
! /* main.c */
! int main(void);
! void setreply(int proc_nr, int result);
! 
! /* mcontext.c */
! int do_getmcontext(void);
! int do_setmcontext(void);
! #if ! USE_MCONTEXT
! #define do_getmcontext no_sys
! #define do_setmcontext no_sys
! #endif
! 
! /* misc.c */
! int do_reboot(void);
! int do_sysuname(void);
! int do_getsysinfo(void);
! int do_getprocnr(void);
! int do_getepinfo(void);
! int do_getepinfo_o(void);
! int do_svrctl(void);
! int do_getsetpriority(void);
! 
! /* schedule.c */
! void sched_init(void);
! int sched_start_user(endpoint_t ep, struct mproc *rmp);
! int sched_nice(struct mproc *rmp, int nice);
! 
! /* profile.c */
! int do_sprofile(void);
! int do_cprofile(void);
! 
! /* signal.c */
! int do_kill(void);
! int do_srv_kill(void);
! int process_ksig(endpoint_t proc_nr_e, int signo);
! int do_pause(void);
! int check_sig(pid_t proc_id, int signo, int ksig);
! void sig_proc(struct mproc *rmp, int signo, int trace, int ksig);
! int do_sigaction(void);
! int do_sigpending(void);
! int do_sigprocmask(void);
! int do_sigreturn(void);
! int do_sigsuspend(void);
! void check_pending(struct mproc *rmp);
! void restart_sigs(struct mproc *rmp);
! void vm_notify_sig_wrapper(endpoint_t ep);
! 
! /* time.c */
! int do_stime(void);
! int do_time(void);
! int do_times(void);
! 
! /* trace.c */
! int do_trace(void);
! void stop_proc(struct mproc *rmp, int sig_nr);
! #if ! USE_TRACE
! #define do_trace no_sys
! #define stop_proc no_sys
! #endif
! 
! /* utility.c */
! pid_t get_free_pid(void);
! int no_sys(void);
! char *find_param(const char *key);
! struct mproc *find_proc(pid_t lpid);
! int nice_to_priority(int nice, unsigned *new_q);
! int pm_isokendpt(int ep, int *proc);
! void tell_vfs(struct mproc *rmp, message *m_ptr);
--- 1,106 ----
! /* Function prototypes. */
! 
! struct mproc;
! struct stat;
! struct mem_map;
! struct memory;
! 
! #include <timers.h>
! 
! /* alarm.c */
! int do_alarm(void);
! int do_itimer(void);
! void set_alarm(struct mproc *rmp, clock_t ticks);
! void check_vtimer(int proc_nr, int sig);
! 
! /* break.c */
! int do_brk(void);
! 
! /* exec.c */
! int do_exec(void);
! int do_newexec(void);
! int do_execrestart(void);
! void exec_restart(struct mproc *rmp, int result, vir_bytes pc, vir_bytes sp);
! 
! /* forkexit.c */
! int do_fork(void);
! int do_srv_fork(void);
! int do_exit(void);
! void exit_proc(struct mproc *rmp, int exit_status, int dump_core);
! void exit_restart(struct mproc *rmp, int dump_core);
! int do_waitpid(void);
! int wait_test(struct mproc *rmp, struct mproc *child);
! 
! /* getset.c */
! int do_get(void);
! int do_set(void);
! 
! /* main.c */
! int main(void);
! void setreply(int proc_nr, int result);
! 
! /* mcontext.c */
! int do_getmcontext(void);
! int do_setmcontext(void);
! #if ! USE_MCONTEXT
! #define do_getmcontext no_sys
! #define do_setmcontext no_sys
! #endif
! 
! /* misc.c */
! int do_reboot(void);
! int do_sysuname(void);
! int do_getsysinfo(void);
! int do_getprocnr(void);
! int do_getepinfo(void);
! int do_getepinfo_o(void);
! int do_svrctl(void);
! int do_getsetpriority(void);
! int do_chrealtime(void); //new added sys call 2016.12.3
! 
! /* schedule.c */
! void sched_init(void);
! int sched_start_user(endpoint_t ep, struct mproc *rmp);
! int sched_nice(struct mproc *rmp, int nice);
! 
! /* profile.c */
! int do_sprofile(void);
! int do_cprofile(void);
! 
! /* signal.c */
! int do_kill(void);
! int do_srv_kill(void);
! int process_ksig(endpoint_t proc_nr_e, int signo);
! int do_pause(void);
! int check_sig(pid_t proc_id, int signo, int ksig);
! void sig_proc(struct mproc *rmp, int signo, int trace, int ksig);
! int do_sigaction(void);
! int do_sigpending(void);
! int do_sigprocmask(void);
! int do_sigreturn(void);
! int do_sigsuspend(void);
! void check_pending(struct mproc *rmp);
! void restart_sigs(struct mproc *rmp);
! void vm_notify_sig_wrapper(endpoint_t ep);
! 
! /* time.c */
! int do_stime(void);
! int do_time(void);
! int do_times(void);
! 
! /* trace.c */
! int do_trace(void);
! void stop_proc(struct mproc *rmp, int sig_nr);
! #if ! USE_TRACE
! #define do_trace no_sys
! #define stop_proc no_sys
! #endif
! 
! /* utility.c */
! pid_t get_free_pid(void);
! int no_sys(void);
! char *find_param(const char *key);
! struct mproc *find_proc(pid_t lpid);
! int nice_to_priority(int nice, unsigned *new_q);
! int pm_isokendpt(int ep, int *proc);
! void tell_vfs(struct mproc *rmp, message *m_ptr);
diff -crN usr_orig/src/servers/pm/table.c EDF/src/servers/pm/table.c
*** usr_orig/src/servers/pm/table.c	2013-02-15 19:18:14.000000000 +0800
--- EDF/src/servers/pm/table.c	2016-12-08 00:17:19.707910740 +0800
***************
*** 1,130 ****
! /* This file contains the table used to map system call numbers onto the
!  * routines that perform them.
!  */
! 
! #define _TABLE
! 
! #include "pm.h"
! #include <minix/callnr.h>
! #include <signal.h>
! #include "mproc.h"
! #include "param.h"
! 
! int (*call_vec[])(void) = {
! 	no_sys,		/*  0 = unused	*/
! 	do_exit,	/*  1 = exit	*/
! 	do_fork,	/*  2 = fork	*/
! 	no_sys,		/*  3 = read	*/
! 	no_sys, 	/*  4 = write	*/
! 	no_sys,		/*  5 = open	*/
! 	no_sys,		/*  6 = close	*/
! 	do_waitpid,	/*  7 = wait	*/
! 	no_sys,		/*  8 = creat	*/
! 	no_sys,		/*  9 = link	*/
! 	no_sys,		/* 10 = unlink	*/
! 	do_waitpid,	/* 11 = waitpid	*/
! 	no_sys,		/* 12 = chdir	*/
! 	do_time,	/* 13 = time	*/
! 	no_sys,		/* 14 = mknod	*/
! 	no_sys,		/* 15 = chmod	*/
! 	no_sys,		/* 16 = chown	*/
! 	do_brk,		/* 17 = break	*/
! 	no_sys,		/* 18 = stat	*/
! 	no_sys,		/* 19 = lseek	*/
! 	do_get,		/* 20 = getpid	*/
! 	no_sys,		/* 21 = mount	*/
! 	no_sys,		/* 22 = umount	*/
! 	do_set,		/* 23 = setuid	*/
! 	do_get,		/* 24 = getuid	*/
! 	do_stime,	/* 25 = stime	*/
! 	do_trace,	/* 26 = ptrace	*/
! 	do_alarm,	/* 27 = alarm	*/
! 	no_sys,		/* 28 = fstat	*/
! 	do_pause,	/* 29 = pause	*/
! 	no_sys,		/* 30 = utime	*/
! 	do_getepinfo,	/* 31 = getepinfo */
! 	do_set, 	/* 32 = setgroups */
! 	no_sys,		/* 33 = access	*/
! 	do_get,		/* 34 = getgroups */
! 	no_sys,		/* 35 = unused	*/
! 	no_sys,		/* 36 = sync	*/
! 	do_kill,	/* 37 = kill	*/
! 	no_sys,		/* 38 = rename	*/
! 	no_sys,		/* 39 = mkdir	*/
! 	no_sys,		/* 40 = rmdir	*/
! 	no_sys,		/* 41 = dup	*/
! 	no_sys,		/* 42 = pipe	*/
! 	do_times,	/* 43 = times	*/
! 	no_sys,		/* 44 = unused	*/
! 	no_sys,		/* 45 = unused	*/
! 	do_set,		/* 46 = setgid	*/
! 	do_get,		/* 47 = getgid	*/
! 	no_sys,		/* 48 = (signal)*/
! 	no_sys,		/* 49 = unused	*/
! 	no_sys,		/* 50 = lstat	*/
! 	no_sys,		/* 51 = (stat)	*/
! 	no_sys,		/* 52 = (fstat)	*/
! 	no_sys,		/* 53 = (lstat)	*/
! 	no_sys,		/* 54 = ioctl	*/
! 	no_sys,		/* 55 = fcntl	*/
! 	no_sys,		/* 56 = unused	*/
! 	no_sys,		/* 57 = unused	*/
! 	no_sys,		/* 58 = unused	*/
! 	do_exec,	/* 59 = execve	*/
! 	no_sys,		/* 60 = umask	*/
! 	no_sys,		/* 61 = chroot	*/
! 	do_set,		/* 62 = setsid	*/
! 	do_get,		/* 63 = getpgrp	*/
! 	do_itimer,	/* 64 = itimer  */
! 	do_get,		/* 65 = getgroups */
! 	do_set, 	/* 66 = setgroups */
! 	do_getmcontext,	/* 67 = getmcontext */
! 	do_setmcontext,	/* 68 = setmcontext */
! 	no_sys,		/* 69 = unused	*/
! 	no_sys,		/* 70 = unused	*/
! 	do_sigaction,	/* 71 = sigaction   */
! 	do_sigsuspend,	/* 72 = sigsuspend  */
! 	do_sigpending,	/* 73 = sigpending  */
! 	do_sigprocmask,	/* 74 = sigprocmask */
! 	do_sigreturn,	/* 75 = sigreturn   */
! 	do_reboot,	/* 76 = reboot	*/
! 	do_svrctl,	/* 77 = svrctl	*/
! 	do_sysuname,	/* 78 = sysuname */
! 	no_sys,		/* 79 = unused */
! 	no_sys,		/* 80 = (getdents) */
! 	no_sys, 	/* 81 = unused */
! 	no_sys, 	/* 82 = (fstatfs) */
! 	no_sys, 	/* 83 = unused */
! 	no_sys, 	/* 84 = unused */
! 	no_sys,		/* 85 = (select) */
! 	no_sys,		/* 86 = (fchdir) */
! 	no_sys,		/* 87 = (fsync) */
! 	do_getsetpriority, /* 88 = getpriority */
! 	do_getsetpriority, /* 89 = setpriority */
! 	do_time,	/* 90 = gettimeofday */
! 	do_set,		/* 91 = seteuid	*/
! 	do_set,		/* 92 = setegid	*/
! 	no_sys,		/* 93 = (truncate) */
! 	no_sys,		/* 94 = (ftruncate) */
! 	no_sys,		/* 95 = (fchmod) */
! 	no_sys,		/* 96 = (fchown) */
! 	no_sys,		/* 97 = unused */
! 	do_sprofile,	/* 98 = sprofile */
! 	do_cprofile,	/* 99 = cprofile */
! 	do_newexec,	/* 100 = newexec */
! 	do_srv_fork,	/* 101 = srv_fork */
! 	do_execrestart,	/* 102 = exec_restart */
! 	no_sys,		/* 103 = unused */
! 	do_getprocnr,	/* 104 = getprocnr */
! 	no_sys,		/* 105 = unused */
! 	do_get,		/* 106 = issetugid */
! 	do_getepinfo_o,	/* 107 = getepinfo XXX: old implementation*/
! 	no_sys,		/* 108 = unused */
! 	no_sys,		/* 109 = unused */
! 	no_sys,		/* 110 = unused */
! 	do_srv_kill,	/* 111 = srv_kill */
!  	no_sys, 	/* 112 = gcov_flush */
! 	do_get,		/* 113 = getsid	*/
! };
! /* This should not fail with "array size is negative": */
! extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
--- 1,130 ----
! /* This file contains the table used to map system call numbers onto the
!  * routines that perform them.
!  */
! 
! #define _TABLE
! 
! #include "pm.h"
! #include <minix/callnr.h>
! #include <signal.h>
! #include "mproc.h"
! #include "param.h"
! 
! int (*call_vec[])(void) = {
! 	no_sys,		/*  0 = unused	*/
! 	do_exit,	/*  1 = exit	*/
! 	do_fork,	/*  2 = fork	*/
! 	no_sys,		/*  3 = read	*/
! 	no_sys, 	/*  4 = write	*/
! 	no_sys,		/*  5 = open	*/
! 	no_sys,		/*  6 = close	*/
! 	do_waitpid,	/*  7 = wait	*/
! 	no_sys,		/*  8 = creat	*/
! 	no_sys,		/*  9 = link	*/
! 	no_sys,		/* 10 = unlink	*/
! 	do_waitpid,	/* 11 = waitpid	*/
! 	no_sys,		/* 12 = chdir	*/
! 	do_time,	/* 13 = time	*/
! 	no_sys,		/* 14 = mknod	*/
! 	no_sys,		/* 15 = chmod	*/
! 	no_sys,		/* 16 = chown	*/
! 	do_brk,		/* 17 = break	*/
! 	no_sys,		/* 18 = stat	*/
! 	no_sys,		/* 19 = lseek	*/
! 	do_get,		/* 20 = getpid	*/
! 	no_sys,		/* 21 = mount	*/
! 	no_sys,		/* 22 = umount	*/
! 	do_set,		/* 23 = setuid	*/
! 	do_get,		/* 24 = getuid	*/
! 	do_stime,	/* 25 = stime	*/
! 	do_trace,	/* 26 = ptrace	*/
! 	do_alarm,	/* 27 = alarm	*/
! 	no_sys,		/* 28 = fstat	*/
! 	do_pause,	/* 29 = pause	*/
! 	no_sys,		/* 30 = utime	*/
! 	do_getepinfo,	/* 31 = getepinfo */
! 	do_set, 	/* 32 = setgroups */
! 	no_sys,		/* 33 = access	*/
! 	do_get,		/* 34 = getgroups */
! 	no_sys,		/* 35 = unused	*/
! 	no_sys,		/* 36 = sync	*/
! 	do_kill,	/* 37 = kill	*/
! 	no_sys,		/* 38 = rename	*/
! 	no_sys,		/* 39 = mkdir	*/
! 	no_sys,		/* 40 = rmdir	*/
! 	no_sys,		/* 41 = dup	*/
! 	no_sys,		/* 42 = pipe	*/
! 	do_times,	/* 43 = times	*/
! 	no_sys,		/* 44 = unused	*/
! 	no_sys,		/* 45 = unused	*/
! 	do_set,		/* 46 = setgid	*/
! 	do_get,		/* 47 = getgid	*/
! 	no_sys,		/* 48 = (signal)*/
! 	no_sys,		/* 49 = unused	*/
! 	no_sys,		/* 50 = lstat	*/
! 	no_sys,		/* 51 = (stat)	*/
! 	no_sys,		/* 52 = (fstat)	*/
! 	no_sys,		/* 53 = (lstat)	*/
! 	no_sys,		/* 54 = ioctl	*/
! 	no_sys,		/* 55 = fcntl	*/
! 	no_sys,		/* 56 = unused	*/
! 	no_sys,		/* 57 = unused	*/
! 	no_sys,		/* 58 = unused	*/
! 	do_exec,	/* 59 = execve	*/
! 	no_sys,		/* 60 = umask	*/
! 	no_sys,		/* 61 = chroot	*/
! 	do_set,		/* 62 = setsid	*/
! 	do_get,		/* 63 = getpgrp	*/
! 	do_itimer,	/* 64 = itimer  */
! 	do_get,		/* 65 = getgroups */
! 	do_set, 	/* 66 = setgroups */
! 	do_getmcontext,	/* 67 = getmcontext */
! 	do_setmcontext,	/* 68 = setmcontext */
! 	do_chrealtime,		/* 69 = chrealtime	*/
! 	no_sys,		/* 70 = unused	*/
! 	do_sigaction,	/* 71 = sigaction   */
! 	do_sigsuspend,	/* 72 = sigsuspend  */
! 	do_sigpending,	/* 73 = sigpending  */
! 	do_sigprocmask,	/* 74 = sigprocmask */
! 	do_sigreturn,	/* 75 = sigreturn   */
! 	do_reboot,	/* 76 = reboot	*/
! 	do_svrctl,	/* 77 = svrctl	*/
! 	do_sysuname,	/* 78 = sysuname */
! 	no_sys,		/* 79 = unused */
! 	no_sys,		/* 80 = (getdents) */
! 	no_sys, 	/* 81 = unused */
! 	no_sys, 	/* 82 = (fstatfs) */
! 	no_sys, 	/* 83 = unused */
! 	no_sys, 	/* 84 = unused */
! 	no_sys,		/* 85 = (select) */
! 	no_sys,		/* 86 = (fchdir) */
! 	no_sys,		/* 87 = (fsync) */
! 	do_getsetpriority, /* 88 = getpriority */
! 	do_getsetpriority, /* 89 = setpriority */
! 	do_time,	/* 90 = gettimeofday */
! 	do_set,		/* 91 = seteuid	*/
! 	do_set,		/* 92 = setegid	*/
! 	no_sys,		/* 93 = (truncate) */
! 	no_sys,		/* 94 = (ftruncate) */
! 	no_sys,		/* 95 = (fchmod) */
! 	no_sys,		/* 96 = (fchown) */
! 	no_sys,		/* 97 = unused */
! 	do_sprofile,	/* 98 = sprofile */
! 	do_cprofile,	/* 99 = cprofile */
! 	do_newexec,	/* 100 = newexec */
! 	do_srv_fork,	/* 101 = srv_fork */
! 	do_execrestart,	/* 102 = exec_restart */
! 	no_sys,		/* 103 = unused */
! 	do_getprocnr,	/* 104 = getprocnr */
! 	no_sys,		/* 105 = unused */
! 	do_get,		/* 106 = issetugid */
! 	do_getepinfo_o,	/* 107 = getepinfo XXX: old implementation*/
! 	no_sys,		/* 108 = unused */
! 	no_sys,		/* 109 = unused */
! 	no_sys,		/* 110 = unused */
! 	do_srv_kill,	/* 111 = srv_kill */
!  	no_sys, 	/* 112 = gcov_flush */
! 	do_get,		/* 113 = getsid	*/
! };
! /* This should not fail with "array size is negative": */
! extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
